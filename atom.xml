<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TO BE BTTER ME</title>
  
  <subtitle>Hacker</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://HackerFreedom.github.io/"/>
  <updated>2018-03-13T10:32:56.501Z</updated>
  <id>http://HackerFreedom.github.io/</id>
  
  <author>
    <name>Sam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>黑客之路</title>
    <link href="http://HackerFreedom.github.io/2018/03/12/%E9%BB%91%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    <id>http://HackerFreedom.github.io/2018/03/12/黑客之路/</id>
    <published>2018-03-12T00:40:00.000Z</published>
    <updated>2018-03-13T10:32:56.501Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3TfVoGg.jpg" alt=""><br><a id="more"></a><br>bookmark 基础必备<br>HTTP抓包与调试<br>Firefox插件<br>Firebug<br>抓包与各种调试<br>Tamper Data<br>拦截修改<br>Live Http Header<br>重放功能<br>Hackbar<br>编码解码/POST提交<br>Modify Headers<br>修改头部<br>Fiddler<br>浏览器代理神器<br>拦截请求或响应<br>抓包<br>重放<br>模拟请求<br>编码解码<br>第三方扩展<br>Watcher<br>Web前端安全的自动审计工具<br>Wireshark<br>各种强大的过滤器语法<br>Tcpdump<br>命令行的类Wireshark抓包神器<br>Python<br>urllib2<br>打开请求响应调试<br>编辑urllib2的do_open里的h.set_debuglevel<br>改为h.set_debuglevel(1)，这时可以清晰看到请求响应数据，包括https<br>什么是跳转<br>服务端跳转<br>302<br>&lt;?php header(“Location: 3.php”); ?&gt;<br>301<br>&lt;?php header(“HTTP/1.1 301 Moved Permanently”); header(“Location: 2.php”); ?&gt;<br>u=urllib2.urlopen(url)后，u.url能得到服务端跳转后的地址<br>urllib2自己的特性<br>所谓的会跟进去<br>客户端跳转</p><p><meta http-equiv="refresh" content="0; url=http://www.evilcos.me"><br>htmlparse解析就行了<br>location.href=”http:/“ + “/evilcos.me”;<br>正则解析（弱）<br>JavaScript引擎解析（强）<br>Office能力<br>Word文档编写，看去要专业，尤其对外的<br>Excel里面大量的统计、图表功能，需要善于使用<br>PPT演讲、培训等必备，如何做好PPT？百度一下…<br>ksmiletris 进一步<br>yEd<br>Visio<br>FreeMind<br>本技能表就是这个制作<br>上手Linux<br>《鸟哥的Linux私房菜》<br>熟练VIM<br>实战至少3回合：<a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">http://coolshell.cn/articles/5426.html</a> User Link<br>上手Python<br>idea <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a> User Link<br>idea <a href="http://learnpythonthehardway.org/book/" target="_blank" rel="noopener">http://learnpythonthehardway.org/book/</a> User Link<br>《Python核心编程2》<br>第4章 Python对象<br>完整熟练<br>6.8 Unicode<br>完整熟练<br>8.11 迭代器和iter()函数<br>完整熟练<br>第9章 文件的输入和输出<br>完整熟练<br>第10章 错误和异常<br>完整熟练<br>第11章 函数和函数式编程<br>完整熟练<br>第12章 模块<br>完整熟练<br>第14章 执行环境<br>完整熟练<br>第15章 正则表达式<br>idea 完整熟练<br>第18章 多线程编程<br>完整熟练<br>20.2 使用Python进行Web应用：创建一个简单的Web客户端<br>完整熟练<br>算法<br>快排<br>二分<br>正则表达式<br>调试工具<br>ksmiletris Kodos<br>idea RegexBuddy<br>支持多种语言<br>支持调试优化<br>ksmiletris <a href="http://www.regexper.com/" target="_blank" rel="noopener">http://www.regexper.com/</a> User Link<br>正则图解<br>正则表达式30分钟入门教程：<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">http://deerchao.net/tutorials/regex/regex.htm</a> User Link<br><a href="http://wiki.ubuntu.org.cn/Python正则表达式操作指南" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/Python正则表达式操作指南</a> User Link<br>《精通正则表达式》<br>研发能力<br>瀑布模型<br>需求-&gt;需求分析-&gt;设计-&gt;开发-&gt;测试-&gt;上线-&gt;运维/运营<br>idea 需求分析能力<br>给你一个需求，如何给出一个优美的执行思路——方法论<br>这个能力非常非常非常的关键<br>调试能力<br>只要定位出，就没有解决不了的Bugs<br>肉眼看到的都是假象<br>一定要专业的工具与经验配合<br>Bugs在哪出现，最终就在哪进行真实模拟调试<br>缩小范围<br>构建自己的测试样例<br>排除网络复杂未知情况<br>关联模块一个个排除<br>Python单步调试<br>import pdb;pdb.set_trace()<br>在需要单步调试的地方加上面这句，运行程序后中断在此，然后h查看指令进行一步步细细调试<br>粗暴调试：print<br>敏捷思想<br>快速迭代<br>任务拆细<br>idea v1原则：定义好v1的目标，快速完成v1为优先<br>习惯Wiki记录，利于沉淀与分享<br>翻墙<br>优雅解决方案<br>shadowsocks + 一台海外 VPS + Chrome(SwitchyOmega)/Firefox(AutoProxy)<br>详情了解：<a href="http://mp.weixin.qq.com/s?__biz=MzA3NTEzMTUwNA==&amp;mid=210457700&amp;idx=1&amp;sn=322d1e4c13d3f33ade848e3889c410bf#rd" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzA3NTEzMTUwNA==&amp;mid=210457700&amp;idx=1&amp;sn=322d1e4c13d3f33ade848e3889c410bf#rd</a> User Link<br>SSH隧道<br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/index.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/index.html</a> User Link<br>本地转发<br>ssh -L <local port="">:<remote host="">:<remote port=""> <ssh hostname=""><br>远程转发<br>反弹<br>ssh -R <local port="">:<remote host="">:<remote port=""> <ssh hostname=""><br>动态转发<br>ssh -D <local port=""> <ssh server=""><br>Web安全<br>零基础如何学习Web安全<br><a href="http://www.zhihu.com/question/21606800/answer/22268855" target="_blank" rel="noopener">http://www.zhihu.com/question/21606800/answer/22268855</a> User Link<br>Web服务组件<br>8+1：一图胜千言哎:) User Link<br>钟馗之眼<br>网络空间搜索引擎<br><a href="http://zoomeye.org" target="_blank" rel="noopener">http://zoomeye.org</a> User Link<br>大量样例：<a href="http://www.zoomeye.org/search/dork" target="_blank" rel="noopener">http://www.zoomeye.org/search/dork</a> User Link<br>组件具有影响面，越底层的组件影响面可能越大<br>安全维度<br>漏洞<br>风险<br>事件<br>Web安全标准<br>OWASP<br>WASC<br>实战环境<br>XSS<br>内部平台：ks-xsslab_open<br>可以上手<br>XSS<br>CSRF<br>ClickJacking<br><a href="http://xss-quiz.int21h.jp/" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/</a> User Link<br>attach 答案：xss<em>quiz.txt User Link<br><a href="http://prompt.ml/0" target="_blank" rel="noopener">http://prompt.ml/0</a> User Link<br>答案：<a href="https://github.com/cure53/XSSChallengeWiki/wiki/prompt.ml" target="_blank" rel="noopener">https://github.com/cure53/XSSChallengeWiki/wiki/prompt.ml</a> User Link<br><a href="http://escape.alf.nu/" target="_blank" rel="noopener">http://escape.alf.nu/</a> User Link<br>答案：<a href="http://blog.nsfocus.net/alert1-to-win-write-up/" target="_blank" rel="noopener">http://blog.nsfocus.net/alert1-to-win-write-up/</a> User Link<br>SQL<br><a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">https://github.com/Audi-1/sqli-labs</a> User Link<br>SQLI-LABS is a platform to learn SQLI<br>i春秋<br><a href="http://www.ichunqiu.com/" target="_blank" rel="noopener">http://www.ichunqiu.com/</a> User Link<br>Seebug + ZoomEye<br><a href="http://seebug.org" target="_blank" rel="noopener">http://seebug.org</a> User Link<br><a href="http://zoomeye.org" target="_blank" rel="noopener">http://zoomeye.org</a> User Link<br>你懂得…<br>工具<br>我的渗透利器<br>Firefox<br>Firebug<br>调试JavaScript，HTTP请求响应观察，Cookie，DOM树观察等<br>Tamper Data<br>拦截修改<br>Live Http Header<br>重放功能<br>Hackbar<br>编码解码/POST提交<br>Modify Headers<br>修改头部<br>GreaseMonkey<br>Original Cookie Injector for Greasemonkey User Link<br>NoScript<br>进行一些JavaScript的阻断<br>AutoProxy<br>翻墙必备<br>Chrome<br>F12<br>打开开发者工具，功能==Firebug+本地存储观察等<br>SwichySharp<br>翻墙必备<br>CookieHacker<br><a href="http://evilcos.me/?p=366" target="_blank" rel="noopener">http://evilcos.me/?p=366</a> User Link<br>Web2.0 Hacking<br>XSS’OR<br>常用其中加解密与代码生成<br><a href="http://evilcos.me/lab/xssor/" target="_blank" rel="noopener">http://evilcos.me/lab/xssor/</a> User Link<br>源码：<a href="https://github.com/evilcos/xssor" target="_blank" rel="noopener">https://github.com/evilcos/xssor</a> User Link<br>XSSEE 3.0 Beta<br>Monyer开发的，加解密最好用神器<br><a href="http://evilcos.me/lab/xssee/" target="_blank" rel="noopener">http://evilcos.me/lab/xssee/</a> User Link<br>Online JavaScript beautifier<br>JavaScript美化工具，分析JavaScript常用<br><a href="http://jsbeautifier.org/" target="_blank" rel="noopener">http://jsbeautifier.org/</a> User Link<br>BeEF<br>The Browser Exploitation Framework<br><a href="http://beefproject.com/" target="_blank" rel="noopener">http://beefproject.com/</a> User Link<br>HTTP代理<br>Fiddler<br>非常经典好用的Web调试代理工具<br>Burp Suite<br>神器，不仅HTTP代理，还有爬虫、漏洞扫描、渗透、爆破等功能<br>mitmproxy<br>Python写的，基于这个框架写神器实在太方便了<br>漏洞扫描<br>AWVS<br>不仅漏扫方便，自带的一些小工具也好用<br>Nmap<br>绝对不仅仅是端口扫描！几百个脚本<br>Python自写脚本/工具<br>漏洞利用<br>sqlmap<br>SQL注入利用最牛神器，没有之一<br>Metasploit<br>最经典的渗透框架<br>Hydra<br>爆破必备<br>抓包工具<br>Wireshark<br>抓包必备<br>Tcpdump<br>Linux下命令行抓包，结果可以给Wireshark分析<br>Seebug + ZoomEye<br>类似这类平台都是我们需要的<br>Seebug类似的<br><a href="https://www.exploit-db.com/" target="_blank" rel="noopener">https://www.exploit-db.com/</a><br>ZoomEye类似的<br><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a><br>Kali Linux<br>除了上面介绍的一些工具，其他海量各类型黑客工具，自己去摸索<br>书<br>《黑客攻防技术宝典（Web实战篇）》<br>《白帽子讲Web安全》<br>《Web前端黑客技术揭秘》<br>我和xisigr出品<br>《Web之困》<br>《SQL注入攻击与防御》<br>papers<br><a href="http://www.exploit-db.com/papers/" target="_blank" rel="noopener">http://www.exploit-db.com/papers/</a> User Link<br>BlackHat/Defcon/XCon/KCon/国内各安全沙龙等相关Papers需要持续跟进<br>idea 嵌入式安全<br>路由器安全<br>基础<br>嵌入式Linux系统方面知识<br>开放系统互联参考模型-第三层网络层<br>MIPS/ARM汇编知识<br>VxWorks系统方面知识<br>JTAG调试接口规范<br>嵌入式系统交叉环境开发<br>路由器芯片方案提供商<br>博通<br>Atheros<br>TrendChip<br>ACROSPEED<br>IC+<br>瑞昱<br>…<br>站点<br><a href="https://www.openwrt.org/" target="_blank" rel="noopener">https://www.openwrt.org/</a> User Link<br>OpenWrt is described as a Linux distribution for embedded devices<br><a href="http://routerpwn.com" target="_blank" rel="noopener">http://routerpwn.com</a> User Link<br>全球主流路由器相关漏洞大集合<br><a href="http://see.sl088.com/wiki/Uboot" target="_blank" rel="noopener">http://see.sl088.com/wiki/Uboot</a></em>%E7%BC%96%E8%AF%91 User Link<br>Uboot_编译<br><a href="http://www.devttys0.com/" target="_blank" rel="noopener">http://www.devttys0.com/</a> User Link<br>Embedded Device Hacking<br>工具<br>Binwalk<br>IDA Pro<br>gdb/gdbserver<br>qemu-system<br>qemu-user-static<br>Smiasm<br>Metasm<br>JTAG硬件调试器<br>书<br>《揭秘家用路由器0day漏洞挖掘技术》<br>《Hacking the XBOX: An Introduction to Reverse Engineering》<br>《Hacking the Cable Modem: What Cable Companies Don’t Want You to Know》<br>《MIPS体系结构透视 》<br>《计算机组成与设计：硬件、软件接口》<br>摄像头安全<br><a href="http://www.openipcam.com/" target="_blank" rel="noopener">http://www.openipcam.com/</a> User Link<br><a href="https://media.blackhat.com/us-13/US-13-Heffner-Exploiting-Network-Surveillance-Cameras-Like-A-Hollywood-Hacker-Slides.pdf" target="_blank" rel="noopener">https://media.blackhat.com/us-13/US-13-Heffner-Exploiting-Network-Surveillance-Cameras-Like-A-Hollywood-Hacker-Slides.pdf</a> User Link<br>工控安全<br>基础<br>工业生产环境的基本结构，如：SCADA、PCS<br>工业生产环境的信息安全风险点（可参考DHS出版物）<br>Improving Industrial Control Systems Cybersecurity with Defense-In-Depth Strategies<br>工控网络组态、逻辑开发、应用组态的基本技术方法<br>抓包、看RFC分析几个常规工业以太网协议，如：Profinet、Modbus<br>买两款PLC玩玩，会真实感受到工业环境的信息安全问题（一定记得买以太网模块，不贵二手几百块）<br>站点<br>事件跟踪分析<br><a href="http://plcscan.org/blog/" target="_blank" rel="noopener">http://plcscan.org/blog/</a> User Link<br><a href="http://scadastrangelove.blogspot.kr" target="_blank" rel="noopener">http://scadastrangelove.blogspot.kr</a> User Link<br><a href="http://www.phdays.com/" target="_blank" rel="noopener">http://www.phdays.com/</a> User Link<br><a href="http://www.scadasl.org" target="_blank" rel="noopener">http://www.scadasl.org</a> User Link<br><a href="https://scadahacker.com" target="_blank" rel="noopener">https://scadahacker.com</a> User Link<br>Duqu<br><a href="https://scadahacker.com/resources/duqu.html" target="_blank" rel="noopener">https://scadahacker.com/resources/duqu.html</a> User Link<br>Stuxnet<br><a href="https://scadahacker.com/resources/stuxnet.html" target="_blank" rel="noopener">https://scadahacker.com/resources/stuxnet.html</a> User Link<br>Havex<br><a href="https://scadahacker.com/resources/havex.html" target="_blank" rel="noopener">https://scadahacker.com/resources/havex.html</a> User Link<br>标准协会/测试工具<br>DHS CET套件<br><a href="http://ics-cert.us-cert.gov/Assessments" target="_blank" rel="noopener">http://ics-cert.us-cert.gov/Assessments</a> User Link<br>NERC ES-ISAC<br><a href="http://www.esisac.com/SitePages/Home.aspx" target="_blank" rel="noopener">http://www.esisac.com/SitePages/Home.aspx</a> User Link<br>ICS-ISAC<br><a href="http://ics-isac.org" target="_blank" rel="noopener">http://ics-isac.org</a> User Link<br>NTSB美国国家工控测试床<br><a href="http://energy.gov/oe/downloads/common-cyber-security-vulnerabilitiesobserved-control-system-assessments-inl-nstb" target="_blank" rel="noopener">http://energy.gov/oe/downloads/common-cyber-security-vulnerabilitiesobserved-control-system-assessments-inl-nstb</a> User Link<br>NIST SP 800-82<br><a href="http://csrc.nist.gov/publications/nistpubs/800-82/SP800-82-final.pdf" target="_blank" rel="noopener">http://csrc.nist.gov/publications/nistpubs/800-82/SP800-82-final.pdf</a> User Link<br>ISA-99控制系统安全协会<br><a href="http://isa99.isa.org/ISA99%20Wiki/Home.aspx" target="_blank" rel="noopener">http://isa99.isa.org/ISA99%20Wiki/Home.aspx</a> User Link<br>NERC CIP标准<br><a href="http://www.nerc.com/pa/Stand/Pages/ReliabilityStandards.aspx" target="_blank" rel="noopener">http://www.nerc.com/pa/Stand/Pages/ReliabilityStandards.aspx</a> User Link<br>工具<br>仿真类<br>电力仿真软件testhaness<br>Modbus仿真软件ModScan<br>电力104协议仿真软件PMA<br>测试类<br>Wurldtech Achilles<br>Codenomicon Defensics<br>Spirent<br>BPS<br>源代码<br>发现<br><a href="https://code.google.com/p/plcscan/" target="_blank" rel="noopener">https://code.google.com/p/plcscan/</a>  User Link<br><a href="https://code.google.com/p/modscan/" target="_blank" rel="noopener">https://code.google.com/p/modscan/</a>  User Link<br><a href="https://github.com/arnaudsoullie/scan7" target="_blank" rel="noopener">https://github.com/arnaudsoullie/scan7</a>  User Link<br><a href="https://github.com/atimorin" target="_blank" rel="noopener">https://github.com/atimorin</a> User Link<br><a href="https://github.com/digitalbond/Redpoint" target="_blank" rel="noopener">https://github.com/digitalbond/Redpoint</a> User Link<br>操纵<br><a href="https://www.scadaforce.com/modbus" target="_blank" rel="noopener">https://www.scadaforce.com/modbus</a> User Link<br><a href="https://github.com/bashwork/pymodbus" target="_blank" rel="noopener">https://github.com/bashwork/pymodbus</a> User Link<br><a href="https://rubygems.org/gems/modbus-cli" target="_blank" rel="noopener">https://rubygems.org/gems/modbus-cli</a> User Link<br><a href="http://libnodave.sourceforge.net" target="_blank" rel="noopener">http://libnodave.sourceforge.net</a> User Link<br><a href="https://code.google.com/p/dnp3" target="_blank" rel="noopener">https://code.google.com/p/dnp3</a> User Link<br>异常监测<br><a href="http://blog.snort.org/2012/01/snort-292-scada-preprocessors.html" target="_blank" rel="noopener">http://blog.snort.org/2012/01/snort-292-scada-preprocessors.html</a>  User Link<br><a href="http://www.digitalbond.com/tools/quickdraw/" target="_blank" rel="noopener">http://www.digitalbond.com/tools/quickdraw/</a> User Link<br>Fuzz<br><a href="https://github.com/jseidl/peach-pit/blob/master/modbus/modbus.xml" target="_blank" rel="noopener">https://github.com/jseidl/peach-pit/blob/master/modbus/modbus.xml</a> User Link<br>其他<br>ZoomEye工控专题： <a href="http://ics.zoomeye.org/" target="_blank" rel="noopener">http://ics.zoomeye.org/</a> User Link<br>Shodan工控专题：<a href="https://www.shodan.io/report/l7VjfVKc" target="_blank" rel="noopener">https://www.shodan.io/report/l7VjfVKc</a> User Link<br><a href="https://github.com/evilcos/papers/blob/master/网络空间工控设备的发现与入侵.ppt" target="_blank" rel="noopener">https://github.com/evilcos/papers/blob/master/网络空间工控设备的发现与入侵.ppt</a> User Link<br>zoomeye.org<br>全球可以找到无数真实路由器/摄像头/工控设备等<br>如：<a href="http://www.zoomeye.org/search?q=app:%22MikroTik%20RouterOS%22&amp;from=dork" target="_blank" rel="noopener">http://www.zoomeye.org/search?q=app:%22MikroTik%20RouterOS%22&amp;from=dork</a> User Link<br>研发清单<br>编码环境<br>pip<br>Docker/Vagrant<br>tmux/screen<br>vim<br>Markdown<br>zsh + oh-my-zsh<br>Python2.7+/3+</ssh></local></ssh></remote></remote></local></ssh></remote></remote></local></p><blockquote><p>Django1.4<br><a href="http://djangobook.py3k.cn/2.0/" target="_blank" rel="noopener">http://djangobook.py3k.cn/2.0/</a> User Link<br>Django Debug Toolbar User Link<br>其他框架<br>web.py<br>Flask<br>Tornado<br>node.js<br>Ubuntu/Gentoo/Centos<br>ipython<br>版本控制<br>废弃SVN，全面拥抱Git<br>GitLab<br>Nginx+uWSGI<br>Python<br>官方手册<br>至少过一遍，这都没过一遍，视野会局限<br>行之说：「我没看过Python的书，却熟读官方手册…」<br>Linux/UNIX<br>书<br>《鸟哥的Linux私房菜》<br>《Linux Shell脚本攻略》<br>《UNIX编程艺术》<br>《Software Design 中文版 01》《Software Design 中文版 02》《Software Design 中文版 03》<br>让你的电脑默认操作系统就是Linux…<br>前端<br>书<br>《JavaScript DOM编程艺术》<br>了解DOM<br>这同样是搞好前端安全的必要基础<br>库<br>jQuery<br>优秀的插件应该体验一遍，并做些尝试<br>官方文档得过一遍<br>D3.js<br>ECharts<br>来自百度<br>Google API<br>ZoomEye Map组件<br>ZoomEye团队自己基于开源的打造<br>AngularJS<br>Google出品的颠覆性前端框架<br>Bootstrap<br>应该使用一遍<br>爬虫进阶<br>代理池<br>爬虫「稳定」需要<br>网络请求<br>wget/curl<br>urllib2/httplib2/requests<br>idea scrapy<br>验证码破解<br>pytesser<br>调度<br>crontab是最原生的定时调度<br>基于redis实现的分布式调度<br>基于rpyc实现的分布式调度<br>celery/gearman等调度框架<br>并发<br>线程池<br>进程内优美的并发方案<br>协程<br>进程内另一种优美的并发方案<br>gevent<br>多进程<br>os.fork<br>idea multiprocessing<br>数据结构<br>JSON<br>cPickle<br>protobuf<br>数据存储及处理<br>数据库<br>MySQL<br>MongoDB<br>Cassandra<br>Hadoop体系<br>Redis<br>Sqlite<br>bsddb<br>ElasticSearch<br>大数据处理<br>Hive<br>Spark<br>ELK<br>ElasticSearch<br>Logstash<br>Kibana<br>DevOps<br>SSH证书<br>Fabric<br>SaltStack<br>puppet<br>pssh/dsh<br>运维进阶<br>运维工程师必须掌握的基础技能有哪些？<br><a href="http://www.zhihu.com/question/23665108/answer/25299881" target="_blank" rel="noopener">http://www.zhihu.com/question/23665108/answer/25299881</a> User Link<br>调试<br>pdb<br>logging<br>Sentry<br>strace/ltrace<br>lsof<br>性能<br>Python内<br>timeit<br>cProfile<br>Python性能分析指南：<a href="http://www.oschina.net/translate/python-performance-analysis" target="_blank" rel="noopener">http://www.oschina.net/translate/python-performance-analysis</a> User Link<br>Python外<br>top/htop/free/iostat/vmstat/ifconfig/iftop…<br>算法<br>分词<br>贝叶斯<br>神经元<br>遗传算法<br>聚类/分类<br>…<br>持续集成<br>自测试<br>nose<br>Jenkins<br>idea 安全<br>我的分享<br>程序员与黑客：<a href="http://www.infoq.com/cn/presentations/programmers-and-hackers" target="_blank" rel="noopener">http://www.infoq.com/cn/presentations/programmers-and-hackers</a> User Link<br>程序员与黑客2：<a href="http://www.infoq.com/cn/presentations/programmers-and-hackers-part02" target="_blank" rel="noopener">http://www.infoq.com/cn/presentations/programmers-and-hackers-part02</a> User Link<br>协作<br>类似Trello的在线协同平台<br>Slack<br>微信<br>立会<br>设计思想<br>人人都是架构师：具备架构思想是一件多酷的事<br>实战出真知<br>如何设计<br>attach 任务架构设计变迁.pdf User Link<br>松耦合、紧内聚<br>单元与单元属性<br>生产者与消费者<br>结构<br>队列<br>LRU<br>分布式<br>存储<br>计算<br>资源考虑<br>CPU<br>内存<br>带宽<br>粗暴美学/暴力美学<br>大数据，先考虑run it，然后才能知道规律在哪<br>「run it优先」能快速打通整体，洞察问题<br>「run it优先」能摆脱细节（繁枝末节）的束缚<br>「run it优先」能快速迭代出伟大的v1<br>一个字总结<br>美<br>牛人1,2,3<br>1研究：研究东西，有足够洞察力，研究水准不错<br>2研发：Hack Idea自己有魄力实现，不懂研发的黑客如同不会游泳的海盗<br>3工程：研发出来的需要实战、需要工程化，否则只是玩具，而不能成为真的武器<br>优质资源<br>书<br>多关注电子工业/图灵/机械工业/人民邮电等出版社，他们有专业团队来保障每年输出优质书籍<br>自己需要掌握鉴别好书的能力<br>站点<br>知乎周刊：<a href="http://zhuanlan.zhihu.com/Weekly" target="_blank" rel="noopener">http://zhuanlan.zhihu.com/Weekly</a> User Link<br>码农周刊：<a href="http://weekly.manong.io/" target="_blank" rel="noopener">http://weekly.manong.io/</a> User Link<br>Pycoder’s Weekly：<a href="http://pycoders.com/archive/" target="_blank" rel="noopener">http://pycoders.com/archive/</a> User Link<br>Hacker News：<a href="https://news.ycombinator.com/" target="_blank" rel="noopener">https://news.ycombinator.com/</a> User Link<br>Startup News：<a href="http://news.dbanotes.net/" target="_blank" rel="noopener">http://news.dbanotes.net/</a> User Link<br>开发者头条：<a href="http://toutiao.io/" target="_blank" rel="noopener">http://toutiao.io/</a> User Link<br>极客头条：<a href="http://geek.csdn.net/" target="_blank" rel="noopener">http://geek.csdn.net/</a> User Link<br>InfoQ：<a href="http://www.infoq.com/cn" target="_blank" rel="noopener">http://www.infoq.com/cn</a> User Link<br>Stack Overflow：<a href="http://stackoverflow.com/" target="_blank" rel="noopener">http://stackoverflow.com/</a> User Link<br>GitHub：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> User Link<br>FreeBuf：<a href="http://www.freebuf.com/" target="_blank" rel="noopener">http://www.freebuf.com/</a> User Link<br>WooYun：<a href="http://drops.wooyun.org/" target="_blank" rel="noopener">http://drops.wooyun.org/</a> User Link<br>深蓝阅读：<a href="http://bluereader.org/" target="_blank" rel="noopener">http://bluereader.org/</a> User Link<br>RSS订阅<br>漏洞相关<br><a href="http://seebug.org/rss.xml" target="_blank" rel="noopener">http://seebug.org/rss.xml</a> User Link<br><a href="https://www.exploit-db.com/rss.xml" target="_blank" rel="noopener">https://www.exploit-db.com/rss.xml</a> User Link<br><a href="https://rss.packetstormsecurity.com" target="_blank" rel="noopener">https://rss.packetstormsecurity.com</a> User Link<br><a href="http://www.wooyun.org/feeds/public" target="_blank" rel="noopener">http://www.wooyun.org/feeds/public</a> User Link<br>强烈推荐圈内人打造的深蓝阅读<br><a href="http://bluereader.org/" target="_blank" rel="noopener">http://bluereader.org/</a> User Link<br>这上面已经很多黑客/技术类似的RSS资源了<br>威胁情报<br>本来不想提任何这方面的，想想还是抖个资源，如下<br><a href="https://github.com/kbandla/APTnotes" target="_blank" rel="noopener">https://github.com/kbandla/APTnotes</a> User Link<br>安全平台<br>在线学习平台<br>i春秋：<a href="http://www.ichunqiu.com" target="_blank" rel="noopener">http://www.ichunqiu.com</a> User Link<br><a href="https://pentesterlab.com" target="_blank" rel="noopener">https://pentesterlab.com</a> User Link<br>PoC提交与学习<br>Seebug: <a href="http://seebug.org" target="_blank" rel="noopener">http://seebug.org</a> User Link<br>Beebeeto: <a href="http://www.beebeeto.com" target="_blank" rel="noopener">http://www.beebeeto.com</a> User Link<br>Bugscan: <a href="http://www.bugscan.net" target="_blank" rel="noopener">http://www.bugscan.net</a> User Link<br>Tangscan: <a href="http://www.tangscan.com" target="_blank" rel="noopener">http://www.tangscan.com</a> User Link</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3TfVoGg.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="黑客之路" scheme="http://HackerFreedom.github.io/categories/%E9%BB%91%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="黑客" scheme="http://HackerFreedom.github.io/tags/%E9%BB%91%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>如何自律</title>
    <link href="http://HackerFreedom.github.io/2018/03/12/%E8%87%AA%E5%BE%8B/"/>
    <id>http://HackerFreedom.github.io/2018/03/12/自律/</id>
    <published>2018-03-12T00:40:00.000Z</published>
    <updated>2018-03-12T06:15:16.962Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/03/12/自律/wall01.png" alt=""><br><a id="more"></a></p><p>我之前坚持每天读半小时书，坚持了两个月，后来工作忙，放下了几天，就把这个习惯忘掉了。再拿起来的时候，又觉得读不下去，这是为什么？不是说好21天就能养成一个习惯吗？</p><p>我想，这种情况，在你的身上，是不是也曾经发生过？</p><p>今天，看到一个「早起打卡」活动，兴冲冲加入了，每天睡眼惺忪起来关闹钟、打卡、做运动，强迫自己进入状态。一个月过去，活动结束了，一切打回原形，该熬夜熬夜，早上照常睡到9点起床。</p><p>明天，又看到一个「每天一篇千字文」活动，觉得很有意义。于是，报了名，每天下了班吭哧吭哧地写，哪怕没有灵感也要绞尽脑汁。一个月过去了，悄悄松了一口气：终于不用写了，解脱了。</p><p>后天，又看到一个「100天打败拖延症」……</p><p>打住。</p><p>这些活动都很好，很有价值，但它们真的有用吗？</p><p>恐怕对许多人来说，并没有什么用。</p><p>原因非常简单：如果一件事情，你必须「逼着自己」才能去做，那为什么要做呢？</p><p>人类作为一个自然演化的生物体，在设计上有许多缺陷 —— 就连我们的大脑也不例外。在人类文明已经高度发达的今天，大脑所遵循的，仍然是原始的生物本能：趋利避害。</p><p>一件事情，大脑从中感受到乐趣，就会倾向于去做。从中感受到痛苦，就会倾向于逃避 —— 这是我们的动物本能。</p><p>从这个角度上讲，自律，其实是一个伪概念。</p><p>因为，任何时候你坚持不下去，放弃了，那些鼓吹「自律」的人都可以告诉你：这是因为你不够自律。</p><p>那如何才能做到「自律」，坚持养成好习惯呢？</p><p>他们不会告诉你，只会说：你需要自律。</p><p>这是没有任何意义的。它没错，但是毫无作用。</p><p>试想，跟自己的大脑相对抗，凡事都逆着它的本能来 —— 这除了不断地内耗，还有什么用呢？</p><p>我们应该去调整它，因势利导，而不是如此简单粗暴地对它下指令。</p><p>好的习惯永远都不需要刻意去「坚持」，更不需要虚无缥缈的「自律」—— 我们应该让它来适应我们，而不是我们去适应它。</p><p>那些自律的人，过得还好吗？<br>Lachel • 2018-03-09 • 技能Get<br>那些自律的人，真的像你以为的那样成功吗<br>4.53MB 04:57<br>从某种程度上讲，自律其实是一个伪概念。<br>编者按：本文来自微信公众号“L先生说”（ID：lxianshengmiao），作者：Lachel；36氪经授权转载</p><p>先祝女性同胞们节日快乐。</p><p>这一次，我要对「自律」开刀了。</p><p>如果你读过这个时代「自我提升」「自我成长」的文章，那你对「自律」一定不陌生。</p><p>这些文章，都会苦口婆心地告诉你：</p><p>你之所以不够成功，是因为你不自律；</p><p>成功没有什么秘诀，只不过是人家能够坚持而已；</p><p>自律才能自由，所有的症结都是因为你懒；</p><p>……</p><p>他们会告诉你：你要自律，要坚持每天健身、早起、读书、打卡、写作、学英语……坚持下去，你就能走在别人前列。</p><p>以及，各种随处可见的「晨读会」「共读会」「早起打卡社群」「习惯养成训练营」……都在提醒着你：</p><p>不够自律，就会分分钟被时代抛弃。</p><p>这些说法对不对？</p><p>不能说不对，确实有道理。</p><p>但我特别想问问那些「坚持自律」的朋友：你们，过得还好吗？</p><p>01<br>前几天有读者问我，说：我之前坚持每天读半小时书，坚持了两个月，后来工作忙，放下了几天，就把这个习惯忘掉了。再拿起来的时候，又觉得读不下去，这是为什么？不是说好21天就能养成一个习惯吗？</p><p>我想，这种情况，在你的身上，是不是也曾经发生过？</p><p>今天，看到一个「早起打卡」活动，兴冲冲加入了，每天睡眼惺忪起来关闹钟、打卡、做运动，强迫自己进入状态。一个月过去，活动结束了，一切打回原形，该熬夜熬夜，早上照常睡到9点起床。</p><p>明天，又看到一个「每天一篇千字文」活动，觉得很有意义。于是，报了名，每天下了班吭哧吭哧地写，哪怕没有灵感也要绞尽脑汁。一个月过去了，悄悄松了一口气：终于不用写了，解脱了。</p><p>后天，又看到一个「100天打败拖延症」……</p><p>打住。</p><p>这些活动都很好，很有价值，但它们真的有用吗？</p><p>恐怕对许多人来说，并没有什么用。</p><p>原因非常简单：如果一件事情，你必须「逼着自己」才能去做，那为什么要做呢？</p><p>人类作为一个自然演化的生物体，在设计上有许多缺陷 —— 就连我们的大脑也不例外。在人类文明已经高度发达的今天，大脑所遵循的，仍然是原始的生物本能：趋利避害。</p><p>一件事情，大脑从中感受到乐趣，就会倾向于去做。从中感受到痛苦，就会倾向于逃避 —— 这是我们的动物本能。</p><p>从这个角度上讲，自律，其实是一个伪概念。</p><p>因为，任何时候你坚持不下去，放弃了，那些鼓吹「自律」的人都可以告诉你：这是因为你不够自律。</p><p>那如何才能做到「自律」，坚持养成好习惯呢？</p><p>他们不会告诉你，只会说：你需要自律。</p><p>这是没有任何意义的。它没错，但是毫无作用。</p><p>试想，跟自己的大脑相对抗，凡事都逆着它的本能来 —— 这除了不断地内耗，还有什么用呢？</p><p>我们应该去调整它，因势利导，而不是如此简单粗暴地对它下指令。</p><h2 id="好的习惯永远都不需要刻意去「坚持」，更不需要虚无缥缈的「自律」——-我们应该让它来适应我们，而不是我们去适应它。"><a href="#好的习惯永远都不需要刻意去「坚持」，更不需要虚无缥缈的「自律」——-我们应该让它来适应我们，而不是我们去适应它。" class="headerlink" title="好的习惯永远都不需要刻意去「坚持」，更不需要虚无缥缈的「自律」—— 我们应该让它来适应我们，而不是我们去适应它。"></a>好的习惯永远都不需要刻意去「坚持」，更不需要虚无缥缈的「自律」—— 我们应该让它来适应我们，而不是我们去适应它。</h2><p>02<br>关于「自律」的研究，最初的来源，是非常经典的「棉花糖实验」。</p><p>这个实验你一定听说过：把一群孩子关在一个小房间里，每个人发一个棉花糖，告诉他们：棉花糖可以吃。但如果你等待15分钟，就可以得到两个棉花糖。如果你抵制不了诱惑，把手上的糖吃掉，你就什么也得不到了。</p><p>实验的结果是：那些等待研究者回来的孩子们，在今后的人生中，表现均优于「吃掉棉花糖」的孩子 —— 包括人际关系、SAT成绩、同学评价，等等。</p><p>这个实验是上世纪66-70年代早期，在斯坦福进行的一系列实验。它提出了一个振聋发聩的概念，叫做「延迟满足」：</p><p>一个人，如果足够自律，能抵制眼前的诱惑，那他就会更容易成功。</p><p>也是从这个实验开始，「自制力」「自控力」「意志力」等相关研究、概念层出不穷，都围绕着「延迟满足」在大做文章。</p><p>它们往往都是一个调调：人与人之间的差距，就在于自律（或者其它随便哪个名字）的程度。</p><p>但这个实验真的靠谱吗？</p><p>其实，如果查一下心理学的相关文献，就会发现，这个实验一直饱受质疑。比如，13年一篇发表在《认知》期刊的文章表示：实验之所以呈现这样的结果，很大可能是由环境造成的。</p><p>更不用说，这里面存在着诸如研究方法不精确、过分夸大相关性、相关性不等于因果性……等等一大堆问题。</p><p>因此，这几年的研究，开始慢慢将目光从「自律」「意志力」「自我耗损」上转移开，进而关注人的自身。</p><p>自律当然不是一件坏事。但过分夸大「自律」的作用，后果可能是很严重的：它会带来对自我的无助、沮丧和不自信。</p><p>举个例子：</p><p>前阵子有学员问我，说：老师，我文化程度不高，最近在读一本书，一直读不太懂，甚至读几页就想睡觉，是我太笨了吗？怎么样才能坚持下去？</p><p>我告诉他：你这不是自律，而是自虐。</p><p>读不懂就放下，换别的书呀，为什么一定要强迫自己呢？</p><p>自律的本质，和「一万小时定律」一样，都属于简单归因：它们有用，也绝对不坏，但远远没有被吹捧和宣称的那么有用。</p><p>除了它们，还有许多其他的因素，这些才是使我们去的成功、走在别人前列的关键。</p><hr><p>那些自律的人，过得还好吗？<br>Lachel • 2018-03-09 • 技能Get<br>那些自律的人，真的像你以为的那样成功吗<br>4.53MB 04:57<br>从某种程度上讲，自律其实是一个伪概念。<br>编者按：本文来自微信公众号“L先生说”（ID：lxianshengmiao），作者：Lachel；36氪经授权转载</p><p>先祝女性同胞们节日快乐。</p><p>这一次，我要对「自律」开刀了。</p><p>如果你读过这个时代「自我提升」「自我成长」的文章，那你对「自律」一定不陌生。</p><p>这些文章，都会苦口婆心地告诉你：</p><p>你之所以不够成功，是因为你不自律；</p><p>成功没有什么秘诀，只不过是人家能够坚持而已；</p><p>自律才能自由，所有的症结都是因为你懒；</p><p>……</p><p>他们会告诉你：你要自律，要坚持每天健身、早起、读书、打卡、写作、学英语……坚持下去，你就能走在别人前列。</p><p>以及，各种随处可见的「晨读会」「共读会」「早起打卡社群」「习惯养成训练营」……都在提醒着你：</p><p>不够自律，就会分分钟被时代抛弃。</p><p>这些说法对不对？</p><p>不能说不对，确实有道理。</p><p>但我特别想问问那些「坚持自律」的朋友：你们，过得还好吗？</p><p>01<br>前几天有读者问我，说：我之前坚持每天读半小时书，坚持了两个月，后来工作忙，放下了几天，就把这个习惯忘掉了。再拿起来的时候，又觉得读不下去，这是为什么？不是说好21天就能养成一个习惯吗？</p><p>我想，这种情况，在你的身上，是不是也曾经发生过？</p><p>今天，看到一个「早起打卡」活动，兴冲冲加入了，每天睡眼惺忪起来关闹钟、打卡、做运动，强迫自己进入状态。一个月过去，活动结束了，一切打回原形，该熬夜熬夜，早上照常睡到9点起床。</p><p>明天，又看到一个「每天一篇千字文」活动，觉得很有意义。于是，报了名，每天下了班吭哧吭哧地写，哪怕没有灵感也要绞尽脑汁。一个月过去了，悄悄松了一口气：终于不用写了，解脱了。</p><p>后天，又看到一个「100天打败拖延症」……</p><p>打住。</p><p>这些活动都很好，很有价值，但它们真的有用吗？</p><p>恐怕对许多人来说，并没有什么用。</p><p>原因非常简单：如果一件事情，你必须「逼着自己」才能去做，那为什么要做呢？</p><p>人类作为一个自然演化的生物体，在设计上有许多缺陷 —— 就连我们的大脑也不例外。在人类文明已经高度发达的今天，大脑所遵循的，仍然是原始的生物本能：趋利避害。</p><p>一件事情，大脑从中感受到乐趣，就会倾向于去做。从中感受到痛苦，就会倾向于逃避 —— 这是我们的动物本能。</p><p>从这个角度上讲，自律，其实是一个伪概念。</p><p>因为，任何时候你坚持不下去，放弃了，那些鼓吹「自律」的人都可以告诉你：这是因为你不够自律。</p><p>那如何才能做到「自律」，坚持养成好习惯呢？</p><p>他们不会告诉你，只会说：你需要自律。</p><p>这是没有任何意义的。它没错，但是毫无作用。</p><p>试想，跟自己的大脑相对抗，凡事都逆着它的本能来 —— 这除了不断地内耗，还有什么用呢？</p><p>我们应该去调整它，因势利导，而不是如此简单粗暴地对它下指令。</p><p>好的习惯永远都不需要刻意去「坚持」，更不需要虚无缥缈的「自律」—— 我们应该让它来适应我们，而不是我们去适应它。</p><p>02<br>关于「自律」的研究，最初的来源，是非常经典的「棉花糖实验」。</p><p>这个实验你一定听说过：把一群孩子关在一个小房间里，每个人发一个棉花糖，告诉他们：棉花糖可以吃。但如果你等待15分钟，就可以得到两个棉花糖。如果你抵制不了诱惑，把手上的糖吃掉，你就什么也得不到了。</p><p>实验的结果是：那些等待研究者回来的孩子们，在今后的人生中，表现均优于「吃掉棉花糖」的孩子 —— 包括人际关系、SAT成绩、同学评价，等等。</p><p>这个实验是上世纪66-70年代早期，在斯坦福进行的一系列实验。它提出了一个振聋发聩的概念，叫做「延迟满足」：</p><p>一个人，如果足够自律，能抵制眼前的诱惑，那他就会更容易成功。</p><p>也是从这个实验开始，「自制力」「自控力」「意志力」等相关研究、概念层出不穷，都围绕着「延迟满足」在大做文章。</p><p>它们往往都是一个调调：人与人之间的差距，就在于自律（或者其它随便哪个名字）的程度。</p><p>但这个实验真的靠谱吗？</p><p>其实，如果查一下心理学的相关文献，就会发现，这个实验一直饱受质疑。比如，13年一篇发表在《认知》期刊的文章表示：实验之所以呈现这样的结果，很大可能是由环境造成的。</p><p>更不用说，这里面存在着诸如研究方法不精确、过分夸大相关性、相关性不等于因果性……等等一大堆问题。</p><p>因此，这几年的研究，开始慢慢将目光从「自律」「意志力」「自我耗损」上转移开，进而关注人的自身。</p><p>自律当然不是一件坏事。但过分夸大「自律」的作用，后果可能是很严重的：它会带来对自我的无助、沮丧和不自信。</p><p>举个例子：</p><p>前阵子有学员问我，说：老师，我文化程度不高，最近在读一本书，一直读不太懂，甚至读几页就想睡觉，是我太笨了吗？怎么样才能坚持下去？</p><p>我告诉他：你这不是自律，而是自虐。</p><p>读不懂就放下，换别的书呀，为什么一定要强迫自己呢？</p><p>自律的本质，和「一万小时定律」一样，都属于简单归因：它们有用，也绝对不坏，但远远没有被吹捧和宣称的那么有用。</p><p>除了它们，还有许多其他的因素，这些才是使我们去的成功、走在别人前列的关键。</p><p>03<br>那么，如果自律是一个伪概念，我们该如何培养习惯、去作出行动呢？</p><p>举个例子：</p><p>你今晚加班，明天给你发一万块奖金。你干吗？肯定干，对吧。</p><p>你今晚加班，否则明天项目就丢了，工作就没了。你干吗？多半也会，对吧。</p><p>这个时候的你，「自律」吗？并不是，你只是单纯被结果所驱动而已。</p><p>第一种「做了就会有收获」，叫做反馈；第二种「不做就会有损失」，叫做惩罚。它们是构成我们「去做某件事情」动力的两大部分。</p><p>本质上，我们的一切行动，乃至于习惯，都是由「动力」和「阻力」的博弈而决定的。</p><p>那么，「自律」的实质是什么呢？非常简单，无非就是「动力」超过了「阻力」，我们循着大脑的指令去行动罢了。</p><p>很多人之所以能够「自律」，并不是他们喜欢苦行、喜欢逼迫自己，而是因为，他们从中获得了乐趣。</p><p>这种乐趣，可能是「解决一个问题」的快感，可能是「成功证明自己」的成就感，可能是「朝目标近了一步」的愉悦感 —— 总而言之，他们认同自己所做的事情，并能从中感受到价值。</p><p>我在之前的文章讲过：麦克利兰认为，人的动机有三种：成就，影响和亲和。高成就动机的人，促成他们行动的动力，就是「把一件事情做好」。</p><p>你会发现，我们身边那种不知疲倦的人，比如念书时期的学霸，废寝忘食做项目的骨干，很多就是这种类型。</p><p>他们并不是靠意志力在逼迫自己，而是因为，他们享受「突破自己」的感觉，喜欢这种不断攻克一个又一个挑战的过程。</p><p>这种无视一切的驱动力，才是一个人制胜的秘诀。</p><p>之前和一些朋友聊天，我说，我没有什么娱乐，不看电影，不看剧，也没什么聚会、活动，平时的生活就是读书、写作、学习、开发新产品。</p><p>他们往往会「哇」的一声，问我：你是怎么坚持下来的？怎么才能做到如此自律？</p><p>这根本就不是自律的问题。我没有娱乐，是因为……我本来就不喜欢娱乐啊。</p><p>我在很多文章讲过：如何才能长时间学习？最有效的办法，就是从学习中找到乐趣，将学习和愉悦感链接起来。而不是靠意志力去驱动。</p><p>这是真的。</p><p>在上一篇文章中，我写道：构建知识体系，很重要的一点，就是问题导向、问题驱动。原因也是一样的。</p><p>人的天性就是发现问题、解决问题，而解决问题之后的小小的成就感，又能给人以充分的反馈，不断地提高你的动力和兴趣。</p><p>所以，我读一本书的时候，绝不会出于「我要把这本书读完」的心态，而是：我有一个问题，这本书能解答我的疑惑。</p><p>抱持着前者的心态，很容易蜻蜓点水，草草翻完；抱着后者的心态，哪怕一本书只精读了十分之一，也能真正把这部分内容吃透。</p><p>同样，如果你读一本书，读不进去，每次打开就想睡觉，那只能说明一件事情：这本书不适合现在的你，是时候换一本了。</p><p>学习本就应当如此：在你的能力基础上，去读需要稍微动脑子才能理解的书。那么，这个「遇到问题 - 动脑思考 - 解决问题」的过程，就会给你带来充足的成就感，一次次累加起来，让你对学习产生强烈的动机。</p><p>这才是长时间高效学习的秘诀。而不是对自己说「我要坚持下去」。</p><p>所以，为什么我不太支持目前这些鼓吹「自律」的各种文章、活动？很大程度上是因为，他们本末倒置了。</p><p>他们将一切症结，归因于你本身不够自律，寄希望于通过创造外部条件和压力，来「逼迫」你去自律 —— 这就南辕北辙了。</p><p>真正的自律，应该是反过来，从内在出发，寻找内部的驱动力，而不是从外部入手。</p><p>这就叫做「内驱力」。</p><p>它才是使一个人成长，最重要的力量。</p><p>04<br>那么，如何提高内驱力，让自己能真正「坚持」下去呢？</p><ol><li>体验</li></ol><p>你可能会碰到这样的问题：你说得很对，但我就是对一切都不感兴趣，找不到动力，怎么办？</p><p>很多时候，往往不是「你对什么事情都缺乏动力」，而是因为你尝试和体验的太少了。</p><p>举个例子，可能有朋友知道，我很少玩任何户外运动，唯一玩得多的是射箭。怎么接触的？其实也是朋友带着出去，接触了一下，觉得十分有意思，这才开始上手。</p><p>我们最大的症状，往往就是想得太多、做得太少。</p><p>一个开放的心态，尤其对于年轻人来说，至关重要。大多数事情，必须亲自上手体验，你才能知道，自己是否适合，是否感兴趣，是否能够长期「坚持」下去。</p><p>哪怕这些尝试到最后都没有结果，这些积累下来的宝贵经验，也能拓展你跟这个世界的触点，让你更好地融入社会，或者更进一步，成为你的护城河。</p><p>没有什么比体验新鲜事物更重要。往前走一步，你会得到整个人生。</p><ol><li>设计</li></ol><p>一件事情，能够长久做下去，无非两个方法：</p><p>1）降低它的阻力；2）提高它的动力。</p><p>这是一个简单而又极其有效的分析方法。你会发现，小到个人成长，大到行业趋势、国家政策、经济发展，都适用。</p><p>就拿个人来说，要坚持健身，不妨最大限度降低阻力。比如：健身一定要有器材、场地、装备吗？晚上下楼去超市买日用品，能不能顺手绕着小区跑两圈？</p><p>很多方法都能帮到你，比如分解任务，降低触及成本，缩短路径，等等。这些都能有效降低阻力。</p><p>大多数时候，我们需要的其实是一个「初始」的动力。只要动起来，后面就会简单许多。</p><p>再比如，早起。与其强迫自己起床打卡，不如考虑，能否在「动力」上下功夫？</p><p>比如：</p><p>买个咖啡机，每天早起给自己做一杯不一样的咖啡；</p><p>做一个手帐，每天早起半小时，给自己做点早餐，争取每天都不重样；</p><p>再比如，你喜欢写作，那么试试每天早起半小时，把自己脑子里的念头、灵感记录下来，练练笔。</p><p>简而言之，把早起和你喜欢、感兴趣的事物联系起来，赋予它以动力，让自己每天都处于这种微小的乐趣和幸福感之中。</p><p>这是一种更有效的方法。</p><ol><li>优势</li></ol><p>我们常常有一个误区：很多时候，我们说自己「喜欢」某件事情，其实未必真的是喜欢 —— 更大的可能性，是因为自己在这件事情上面，做得更好。</p><p>这跟前面提到的「趋利避害」是一致的。一件任务，我们做得得心应手 —— 可能花的时间更少、性价比更高，也可能质量比别人好，那么，我们就会从中得到反馈，借此激活大脑的「奖赏回路」，让我们更加倾向于去做这件事。</p><p>这其实就是「喜欢」。</p><p>所以，很多时候，喜欢来源于什么？源自「适合」和「擅长」。</p><p>不妨想一想，你这几十年的记忆里，受到肯定和奖赏的时候，被别人夸奖的时候，感受到自身价值的时候 —— 哪怕只是微不足道的一瞬间，是在什么样的情境下？</p><p>然后，往深处去审问内心：为什么我在这些情景下表现更好？我的优势是什么？是哪一个特点、行为，让我觉得「自己能够做好」？</p><p>接下来，就是想办法，将这些触点，跟你的生活、工作建立联系，让它们在生活中，能够发挥用武之地。</p><p>你会发现，当你将它们跟生活建立联系之后，一切都变得轻巧、明亮、简单了起来。</p><p>你不再需要「自律」，因为你的内心会有用之不竭的动力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/03/12/自律/wall01.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="自律的要求" scheme="http://HackerFreedom.github.io/categories/%E8%87%AA%E5%BE%8B%E7%9A%84%E8%A6%81%E6%B1%82/"/>
    
    
      <category term="自律" scheme="http://HackerFreedom.github.io/tags/%E8%87%AA%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>java框架</title>
    <link href="http://HackerFreedom.github.io/2018/03/10/spring%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%92%8C%E4%BA%8B%E5%8A%A1/"/>
    <id>http://HackerFreedom.github.io/2018/03/10/spring连接池和事务/</id>
    <published>2018-03-10T11:55:00.000Z</published>
    <updated>2018-03-10T12:21:57.669Z</updated>
    
    <content type="html"><![CDATA[<p>课程目标:<br>    能够独立完成数据连接池的配置<br>    能够使用JdbcTemplate完成数据的增删改差操作<br>    能够清晰的描述出spring事务管理的机制<br>    能够分别说出spring事务管理三个接口的作用<br>    能够使用xml配置的方式实现声明式事务管理<br>    能够使用注解的方法实现声明式事务管理</p><h1 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h1><h1 id="springjabcTemplate介绍"><a href="#springjabcTemplate介绍" class="headerlink" title="springjabcTemplate介绍"></a>springjabcTemplate介绍</h1><p>Spring提供了一个jdbc模板，它类似于dbutils工具。<br><code>spring-jdbc-4.2.4.RELEASE.jar</code><br><code>spring-tx-4.2.4.RELEASE.jar</code><br>还需要导入相关的数据库驱动jar包</p><h1 id="连接池的配置"><a href="#连接池的配置" class="headerlink" title="连接池的配置"></a>连接池的配置</h1><h2 id="内置连接池DriverManagerDataSource配置使用"><a href="#内置连接池DriverManagerDataSource配置使用" class="headerlink" title="内置连接池DriverManagerDataSource配置使用"></a>内置连接池DriverManagerDataSource配置使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;driverManagerDateSource&quot;</span><br><span class="line">   class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">   &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///springtest&quot; /&gt;</span><br><span class="line">   &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">   &lt;property name=&quot;password&quot; value=&quot;abc&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"> 配置jdbcTemplate</span><br><span class="line">&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line"> &lt;property name=&quot;dataSource&quot; ref=&quot;driverManagerDateSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h1 id="配置c3p0连接池"><a href="#配置c3p0连接池" class="headerlink" title="配置c3p0连接池"></a>配置c3p0连接池</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 创建c3p0连接滨 --&gt;</span><br><span class="line">&lt;bean id=&quot;c3p0DataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">&lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///springtest&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;user&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">&lt;/bean</span><br></pre></td></tr></table></figure><p>Spring支持将经常修改属性，在properties文件中声明，在xml配置文件中引入外部的properties文件的信息<br><code>&lt;!-- 引入外部的properties文件 --&gt;</code><br><code>&lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;</code><br>在配置中需要从properties文件中引入的信息可以使用${name}方式来获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 创建c3p0连接滨 --&gt;</span><br><span class="line">&lt;bean id=&quot;c3p0DataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">------</span><br></pre></td></tr></table></figure></p><h1 id="JDBCTemplate应用（CRUD）"><a href="#JDBCTemplate应用（CRUD）" class="headerlink" title="JDBCTemplate应用（CRUD）"></a>JDBCTemplate应用（CRUD）</h1><p><em>支持的mysql语句</em></p><ul><li>数据修改<br><code>jdbcTemplate.update(&quot;update t_user set name=? where id=?&quot;, &quot;tom&quot;, 1);</code></li><li>数据插入<br><code>jdbcTemplate.update(&quot;insert into t_user values(null,?,?,?)&quot;, &quot;赵六&quot;, 30, &quot;男&quot;);</code></li><li>数据删除<br><code>jdbcTemplate.update(&quot;delete from t_user where id=?&quot;, 4);</code></li></ul><hr><h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><p>Spring事务管理的四个优点:</p><ol><li>提供一致的对于不同的事务管理的API</li><li>支持声明式事务管理(重点)</li><li>编程事务管理(在开发中应用比较少)</li><li>优秀的整合与Spring的数据访问</li></ol><p><strong>Spring事务管理主要提供了三个接口来完成</strong></p><ol><li>org.springframework.transaction.PlatformTransactionManager<br>这是一个事务管理器，可以来选择相关的平台(jdbc  hibernate  jpa…)</li><li>TransactionDefinition<br>它定义事务的一些相关信息 例如 隔离 传播 超时 只读</li><li>TransactionStatus<br>它主要描述事务具体的运行状态<br><img src="/2018/03/10/spring01.png" alt="事务">;<h2 id="PlatformTransactionManager接口"><a href="#PlatformTransactionManager接口" class="headerlink" title="PlatformTransactionManager接口"></a>PlatformTransactionManager接口</h2></li></ol><p><code>PlatformTransactionManager</code>平台事务管理器在不同的持久化层解决技术它的事务代码不一样<br><code>DataSourceTransactionManager</code> 主要针对于JdbcTemplate开发  MyBatis开发<br><code>HibernateTransactionManasger</code> 主要针对于Hibernate开发<br><code>JpaTransactionManager</code> 主要针对于JPA开发</p><h2 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h2><p><em>TransactionDefinition它描述的是事务的定义信息，在TransactionDefinition中定义了大量的常量</em><br><strong> 隔离</strong><br>事务的四个特性 ACID  <code>原子性 一致性 隔离性 持久性</code>。<br>不考虑事务隔离性有什么问题？脏读，不可重复读 虚读。<br><code>ISOLATION_DEFUALT</code> 它使用后端数据库的默认隔离级别(spring中选项)<br><code>ISOLATION_READ_UNCOMMITTED</code>不能解决问题，会发生脏读 不可重复读 虚读<br><code>ISOLATION_READ_COMMITTED</code> 可以解决脏读 会产生不可重复读与虚读。<br><code>ISOLATION_REPEATABLE_READ</code> 可以解决脏读，不可重复读 解决不了虚读<br><code>ISOLATION_SERIALIZABLE</code>串行化，可以解决所有问题<br>对于不现的数据库，它的底层默认事务隔离级别不一样。<br>Oracle数据库它默认的是read_committed<br>Mysql数据库它默认的是repeatable_read.<br><strong>超时</strong><br>int TIMEOUT_DEFAULT = -1;<br>默认值是-1 它使用的是数据库默认的超时时间。</p><p><strong> 只读</strong><br>它的值有两个true/false,如果选择true一般是在select操作时</p><p><strong> 传播</strong><br>它解决的是两个被事务管理的方法互相调用问题。它与数据库没关系，是程序内部维护的问题。</p><p>以上操作中最常用的三种:<br><code>PROPAGATION_REQUIRED</code> 默认值 两个操作处于同一个事务，如果之前没有事务，新建一个事务<br><code>PROPAGATION_REQUIRES_NEW</code> 两个操作处于不同的事务<br><code>PROPAGATION_NESTED</code>它是一种嵌套事务，它是使用SavePoint来实现的。事务回滚时可以回滚到指定的savepoint,注意：它只对DataSourceTransactionManager有作用</p><h2 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h2><p><em>它定义了事务状态信息，在事务运行过程中，得到某个时间点的状态</em></p><h1 id="事务管理两种方式"><a href="#事务管理两种方式" class="headerlink" title="事务管理两种方式"></a>事务管理两种方式</h1><ol><li>编码方案 不建议使用，它具有侵入性。在原有的业务代码基础上去添加事务管理代码</li><li>声明式事务控制，基于<code>AOP</code>对目标进行代理，添加<code>around环绕通知</code>。<br>这种方案，它不具有侵入性，不需要修改原来的业务代码</li></ol><hr><h1 id="xml配置声明式事务管理"><a href="#xml配置声明式事务管理" class="headerlink" title="xml配置声明式事务管理"></a>xml配置声明式事务管理</h1><ol><li>在applicationContext.xml文件中添加aop与tx的名称空间</li><li><p>配置事务管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">&lt;property name=&quot;dataSource&quot; ref=&quot;c3p0DataSource&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置通知<br>Spring为我们提供了一个TransactionInterceptor来完成增强, 对于这个增强，可以使用spring为我们提供的一个标签<tx:advice>来完成操作    </tx:advice></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">&lt;tx:attributes&gt;</span><br><span class="line">&lt;tx:method name=&quot;account&quot; /&gt;</span><br><span class="line">&lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line">name:必须的，对哪些方法进行事务控制</span><br><span class="line">isolation 可选 设置事务隔离级别 默认是DEFAULT </span><br><span class="line">propagation:可选 设置事务传播 默认值 REQUIRED</span><br><span class="line">timeout 可选 超时时间 默认值-1 </span><br><span class="line">read-only 可选 默认值是false 如果不是只读，它可以对insert update delete操作，如果是只读不可以。</span><br><span class="line">rollback-for 可选 可以设置一个异常，如果产生这个异常，触发事务回滚</span><br><span class="line">no-rolback-for 可选 可以设置一个异常，如果产生这个异常，不会触发事务回滚</span><br></pre></td></tr></table></figure></li><li><p>配置切面<br>因为使用的是传统的spring的advice,需要使用<code>&lt;aop:advisor&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;aop:pointcut </span><br><span class="line">expression=&quot;execution(* cn.itheima.service.IAccountService.account(..))&quot; id=&quot;txPointcut&quot;/&gt;</span><br><span class="line">&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="基于annotation声明式事务管理"><a href="#基于annotation声明式事务管理" class="headerlink" title="基于annotation声明式事务管理"></a>基于annotation声明式事务管理</h1><ol><li><p>配置事务管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">&lt;property name=&quot;dataSource&quot; ref=&quot;c3p0DataSource&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>开启注解事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>方法或者类上配置事务</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void account(String outname, String inname, double money) &#123;</span><br><span class="line">// 从outname转出money</span><br><span class="line">accountDao.accountOut(outname, money);</span><br><span class="line">int a = 10 / 0; // 一定会抛出异常</span><br><span class="line">// 向inname转入money</span><br><span class="line">accountDao.accountIn(inname, money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>反思</em></p><ol><li><p>了解springjdbcTemplate的作用及开发环境的搭建</p></li><li><p>理解spring事务管理的三个核心接口并说出spring事务管理的优点</p></li><li><p>使用基于xml与annotation方式进行spring声明式事务管理操作</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程目标:&lt;br&gt;    能够独立完成数据连接池的配置&lt;br&gt;    能够使用JdbcTemplate完成数据的增删改差操作&lt;br&gt;    能够清晰的描述出spring事务管理的机制&lt;br&gt;    能够分别说出spring事务管理三个接口的作用&lt;br&gt;    能够使用xml
      
    
    </summary>
    
      <category term="spring连接池和事务" scheme="http://HackerFreedom.github.io/categories/spring%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%92%8C%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/tags/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>java框架</title>
    <link href="http://HackerFreedom.github.io/2018/03/10/%E5%B1%9E%E6%80%A7%E5%92%8C%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8%E5%8C%BA%E5%88%AB/"/>
    <id>http://HackerFreedom.github.io/2018/03/10/属性和模型驱动区别/</id>
    <published>2018-03-10T06:15:00.000Z</published>
    <updated>2018-03-10T06:15:15.817Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Struts2属性驱动</li><li>在Action类中，属性××通过get××()和set××()方法，把参数在整个生命周期内进行传递，这就是属性驱动</li></ol><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package org.abu.csdn.action.user;</span><br><span class="line"></span><br><span class="line">import com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line">public class RegisterAction extends ActionSupport &#123;  //首先类RegisterAction 必须继承ActionSupport </span><br><span class="line"></span><br><span class="line">    private String uname;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getUname() &#123;</span><br><span class="line"></span><br><span class="line">        return uname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUname(String uname) &#123;</span><br><span class="line">        this.uname = uname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String execute() throws Exception &#123;    //重写execute() 方法执行Action动作</span><br><span class="line">        return ActionSupport.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void validate()&#123;  //重写validate()方法</span><br><span class="line"></span><br><span class="line">if(uname==null || uname.trim().length()==0)&#123;</span><br><span class="line"></span><br><span class="line">    this.addFieldError(&quot;uname&quot;,&quot;用户名不能为空&quot;);  //重写addFieldError()方法来进行错误处理</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.Struts2的模型驱动</p><p>把用户请求参数封装到一个javabean中，Action中使用一个独立的modle实例来封装用户的请求参数和处理结果，action完成业务逻辑调度，使用2个类来分解action任务，这就是模型驱动。</p><p>注意：使用模型驱动时，在继承ActionSupport类或者实现action接口时，必须实现一个ModelDriver接口，该接口的作用建立一个Model对象来代替Action本身把数据存ValueStack</p><p>代码如下：</p><p> //把用户请求参数封装到User中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123; </span><br><span class="line"></span><br><span class="line">    private String uname;</span><br><span class="line">    public String getUname() &#123;</span><br><span class="line"></span><br><span class="line">        return uname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUname(String uname) &#123;</span><br><span class="line">        this.uname = uname;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//Action中使用一个独立的RegisterAction(){}实例来封装用户的请求参数和处理结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package org.abu.csdn.action.user;</span><br><span class="line"></span><br><span class="line">import org.abu.csdn.dto.User;</span><br><span class="line"></span><br><span class="line">import com.opensymphony.xwork2.ActionSupport;</span><br><span class="line">import com.opensymphony.xwork2.ModelDriven;</span><br></pre></td></tr></table></figure></p><p><code>public class RegisterAction extends ActionSupport implements ModelDriven&lt;User&gt;</code> {//实现ModelDriver接口，该接口的作用建立一个Model对象来代替Action本身把数据存入ValueStackAc。</p><p>//<user>： 在这里引入student类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    private User user=new User();</span><br><span class="line">    public User getModel() &#123;// 模型驱动必须实现的方法，也是ModelDriven接口中唯一的方法       </span><br><span class="line"></span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public RegisterAction()&#123;</span><br><span class="line"></span><br><span class="line">getModel() .setUname(&quot;Marry&quot;) ；</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   public String oneNewRegister()&#123;</span><br><span class="line"></span><br><span class="line">getModel() .setUname(&quot;Danny&quot;) ；</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String execute() throws Exception &#123;  //重写execute() 方法执行Action动作      </span><br><span class="line">        return  SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void validate()&#123;  //重写validate()方法</span><br><span class="line"></span><br><span class="line">if(user.getUname() ==null || user.getUname() .trim().length()==0)&#123;</span><br><span class="line"></span><br><span class="line">    this.addFieldError(&quot;uname&quot;,&quot;用户名不能为空&quot;);  //重写addFieldError()方法来进行错误处理</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></user></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Struts2属性驱动&lt;/li&gt;
&lt;li&gt;在Action类中，属性××通过get××()和set××()方法，把参数在整个生命周期内进行传递，这就是属性驱动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plai
      
    
    </summary>
    
      <category term="属性驱动和模型驱动区别" scheme="http://HackerFreedom.github.io/categories/%E5%B1%9E%E6%80%A7%E9%A9%B1%E5%8A%A8%E5%92%8C%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8%E5%8C%BA%E5%88%AB/"/>
    
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/tags/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/03/09/%E6%96%B0%E6%96%87%E6%A1%A3/"/>
    <id>http://HackerFreedom.github.io/2018/03/09/新文档/</id>
    <published>2018-03-09T08:14:37.918Z</published>
    <updated>2018-03-09T08:45:42.120Z</updated>
    
    <content type="html"><![CDATA[<p>属性驱动封装对象</p><p>文件上传要注意，是struts2拦截器在起作用。</p><p>模型驱动</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;属性驱动封装对象&lt;/p&gt;
&lt;p&gt;文件上传要注意，是struts2拦截器在起作用。&lt;/p&gt;
&lt;p&gt;模型驱动&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java框架</title>
    <link href="http://HackerFreedom.github.io/2018/03/08/spring%E6%95%B4%E5%90%88/"/>
    <id>http://HackerFreedom.github.io/2018/03/08/spring整合/</id>
    <published>2018-03-08T11:55:00.000Z</published>
    <updated>2018-03-10T12:18:46.627Z</updated>
    
    <content type="html"><![CDATA[<p>课程目标:<br>    能够清晰的说出spring整合Hibernate框架的方式（两种）和原理（管理sessionfactory）<br>    能够独立完成Spring框架整合Hibernate框架（相关的配置）<br>    能够清晰的说出Spring框架整合Struts框架的原理（ObjectFactory）<br>    能够在ssh框架整合的基础上使用Xml方式完成向数据库添加纪录的操作<br>    能够在ssh框架整合的基础上使用注解方式完成向数据库添加纪录的操作<br>    能够在ssh框架整合的基础上解决延迟加载的问题</p><h1 id="框架整合jar包分析"><a href="#框架整合jar包分析" class="headerlink" title="框架整合jar包分析"></a>框架整合jar包分析</h1><pre><code>Springs整合struts2----------&gt;     spring-web-4.2.4.RELEASE.jar （将spring发布于web上）     struts2-spring-plugin-2.3.24.jar （解决action不能依赖spring工厂问题） Spring整合Hibernate--------&gt;     spring-orm-4.2.4.RELEASE.jar  （加载映射文件）</code></pre><h1 id="基于xml配置方式整合SSH"><a href="#基于xml配置方式整合SSH" class="headerlink" title="基于xml配置方式整合SSH"></a>基于xml配置方式整合SSH</h1><ol><li><p>struts:     struts.xml</p><pre><code>        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt;    &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;&gt;&lt;/constant&gt;&lt;/struts&gt;</code></pre></li><li>hibernate:  xxx.hbm.xml,<pre><code>     &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC  &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;` &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;` &lt;hibernate-mapping&gt; &lt;class name=&quot;&quot; table=&quot;&quot;&gt;       &lt;id name=&quot;id&quot;&gt;             &lt;generator class=&quot;identity&quot; /&gt;           &lt;/id&gt;       &lt;property name=&quot;&quot; /&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt;</code></pre><em>hibernate.cfg.xml</em></li><li><p>spring:     applicationContext.xml</p></li><li><p>web.xml:    struts过滤器，ContextLoaderListener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;    </span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">   &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;listener&gt;`</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line">   &lt;struts2&gt;`</span><br><span class="line">        &lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;struts2&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;struts2&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="Spring整合hibernate"><a href="#Spring整合hibernate" class="headerlink" title="Spring整合hibernate"></a>Spring整合hibernate</h2><p>//只需要使用spring中提供的一个LocalSessionFacotry来加载Hibernate的配置文件。<br><code>&lt;bean class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&gt;    &lt;/bean&gt;</code><br>ssh-xml工程加载到服务器后，如果可以自动创建表，就代表spring整合hibernate ok.<br>注意:必须配置spring的ContextLoaderListener</p><p><em>不在需要hibernate.cfg.xml文件，所有关于hibernate.cfg.xml文件中的配置都在spring的配置文件中来配置</em></p><pre><code>1. 首先配置数据源</code></pre><p><img src="/2018/03/08/spring整合/spring01.png" alt=""></p><pre><code>2. 引入properties文件</code></pre><p><img src="/2018/03/08/spring整合/spring02.png" alt=""></p><pre><code>3. LocalSessionFactoryBean来完成spring管理hibernate中SessionFactory</code></pre><p><img src="/2018/03/08/spring整合/spring03.png" alt=""></p><blockquote><p>mappingResources它类似于我们之前<mapping resource="””"><br>mappingLocations它加载时是根据类路径加载 classpath:路径<br>mappingJarLocations它会加载jar文件中的hbm.xml文件<br>mappingDirectoryLocations 它加载的目录</mapping></p></blockquote><hr><h1 id="spring整合hibernate后的DAO"><a href="#spring整合hibernate后的DAO" class="headerlink" title="spring整合hibernate后的DAO"></a>spring整合hibernate后的DAO</h1><p>Dao—继承JdbcDaoSupport—–注入DataSource——&gt;使用JdbcTemplate来完成操作</p><p><strong>Dao—继承HibernateDaoSupport—–注入sessionFactory——&gt;使用hibernateTemplate来完成操作</strong></p><pre><code>1. userDaoImpl 编写</code></pre><p><img src="/2018/03/08/spring整合/spring04.png" alt=""></p><pre><code>2. 声明dao注入sessionFactory</code></pre><p><img src="/2018/03/08/spring整合/spring05.png" alt=""></p><h2 id="spring整合hibernate的测试"><a href="#spring整合hibernate的测试" class="headerlink" title="spring整合hibernate的测试"></a>spring整合hibernate的测试</h2><p> DataSourceTransactionManager—–&gt;注入DataSource<br>HibernateTransactionManager—–&gt;注入sessionFactory（readOnly错误，不再hibernate模版中配置事务的话。）</p><p><strong> UserServiceImplTest—-&gt;加载applicationContext.xml—-&gt;注入IUserService——&gt;注入IUserDAO</strong></p><pre><code>1. 编写userServiceImpl</code></pre><p><img src="/2018/03/08/spring整合/spring06.png" alt=""></p><pre><code>2. 配置UserServiceImpl注入UserDAOImpl</code></pre><p><img src="/2018/03/08/spring整合/spring07.png" alt=""></p><pre><code>3. 配置事务管理（HibernateTransactionManager）</code></pre><p><img src="/2018/03/08/spring整合/spring08.png" alt=""></p><pre><code>4. 代码测试</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2018/03/08/spring整合/spring09.png" alt=""></h2><h1 id="Sring整合struts2框架"><a href="#Sring整合struts2框架" class="headerlink" title="Sring整合struts2框架"></a>Sring整合struts2框架</h1><ol><li>创建一个jsp页面<br><code>&lt;form action=&quot;${pageContext.request.contextPath}/user_add&quot; method=&quot;post&quot;&gt;name:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;age:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;addUser&quot;&gt;&lt;/form&gt;</code></li><li><p>创建userAction类<br><img src="/2018/03/08/spring整合/spring10.png" alt=""></p></li><li><p>struts.xml文件中配置<br><code>&lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;&lt;action name=&quot;user_*&quot; class=&quot;cn.itheima.action.UserAction&quot; method=&quot;{1}&quot;&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt;</code></p></li></ol><h2 id="ssh整合-spring整合struts2-伪类名方式"><a href="#ssh整合-spring整合struts2-伪类名方式" class="headerlink" title="ssh整合-spring整合struts2 -伪类名方式"></a>ssh整合-spring整合struts2 -伪类名方式</h2><ol><li>在UserAction类提供IUserService属性<br><img src="/2018/03/08/spring整合/spring11.png" alt=""></li><li>在applicationContext.xml文件中配置<br><img src="/2018/03/08/spring整合/spring12.png" alt=""></li><li>在struts.xml文件中引用userAction<br><img src="/2018/03/08/spring整合/spring13.png" alt=""></li></ol><p><strong>注意：必须在web.xml文件中配置struts2框架的Filter</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;struts2&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;struts2&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p><h3 id="ssh整合-spring整合struts2-全类名方式"><a href="#ssh整合-spring整合struts2-全类名方式" class="headerlink" title="ssh整合-spring整合struts2 -全类名方式"></a>ssh整合-spring整合struts2 -全类名方式</h3><ul><li><p><em>struts.xml文件配置class属性是UserAction类的全类名</em><br><img src="/2018/03/08/spring整合/spring14.png" alt=""></p></li><li><p>这时就会将action类中的servcie属性按照属性名称自动注入<br><img src="/2018/03/08/spring整合/spring15.png" alt=""></p></li></ul><p>因为在default.properties中有一段配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**默认这时就会根据名称进行注入**</span><br><span class="line">&lt;constant name=&quot;struts.objectFactory.spring.autoWire&quot; value=&quot;name&quot;/&gt;</span><br></pre></td></tr></table></figure><p>在struts.xml文件中修改了注入的方式为type，就会根据属性里面的<strong>参数类型进行注入(set方法参数)  </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;constant name=&quot;struts.objectFactory.spring.autoWire&quot; value=&quot;type&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p><strong>spring整合struts2框架总结</strong></p><ol><li>如果在struts.xml文件中<code>&lt;action class=”cn.itheima.action.UserAction”&gt;</code>如果写的是全类名，会自动注入service，默认按照名称注入</li><li>如果在struts.xml文件中<code>&lt;action class=”userAction”&gt;</code>伪类名方式，在applicationContext.xml文件要配置<code>&lt;bean id=”userAction” class=”cn.itheima.action.UserAction”&gt;</code>并且需要手动注入service</li><li>以上操作的前提是必须导入struts2-spring-plugin.jar包它改变struts2的bean工厂</li><li>如果采用全类名方式，这时每一次请求都会新创建一个action</li><li>如果采用的是伪类名方式必须在<bean>声明中添加<code>scope=”prototype”,</code>原因是struts2框架的action每一次请求都应该是一个新的action</bean></li></ol><hr><h1 id="基于注解的方式整合SSH"><a href="#基于注解的方式整合SSH" class="headerlink" title="基于注解的方式整合SSH"></a>基于注解的方式整合SSH</h1><ol><li>导入jar包<code>struts2-convention-plugin-2.3.24.jar包；</code></li><li>使用JPA注解来定义PO类<ol><li>@Entity 定义实体类，@Table 定义表，@Id 主键，@GeneratedValue 生成主键策略，@Column 定义列</li><li>dentity由底层数据库生成标识符。identity是由数据库自己生成的，但这个主键必须设置为自增长，使用identity的前提条件是底层数据库支持自动增长字段类型</li><li>native由hibernate根据使用的数据库自行判断</li><li>Hibernate在保存对象时，生成一个UUID字符串作为主键，保证了唯一性<ol><li>特点：uuid长度大，占用空间大，跨数据库，不用访问数据库就生成主键值，所以效率高且能保证唯一性，移植非常方便，推荐使用。</li></ol></li></ol></li><li>要在SessionFactory配置扫描包，这里是扫描PO类和数据库表建立ORM对象关系映射<br><img src="/2018/03/08/spring整合/anno01.png" alt=""></li><li>在dao,service,action类上配置@Repository @Service（在service中添加事务 @Transactional） @Controller来完成bean注册；</li><li>开启注解扫描<br>  <code>&lt;context:component-scan base-package=&quot;cn.itheima&quot;/&gt;</code></li><li><p>声明事务管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">&lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>事务注解驱动<br><code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code></p></li></ol><hr><p><strong>总结</strong></p><ol><li>dao类继承HibernateDaoSupport注入SessionFactory传给父类，在dao中就可以通过getHibernateTemplate()直接获取HibernateTemplate;<br><img src="/2018/03/08/spring整合/anno02.png" alt="">;</li><li>在service及action中使用@Autowire来注入dao及service<br><img src="/2018/03/08/spring整合/anno03.png" alt="">;<br><img src="/2018/03/08/spring整合/anno04.png" alt="">;</li><li>对于Struts2框架需要@Namespace @Action @ParentPakcage @Result来定义struts2流程</li><li>要求action类必须是在包含action actions struts struts2字符串这样的包中才会扫描struts2相关注解,并且action类必须以Action结尾<br><img src="/2018/03/08/spring整合/anno05.png" alt="">;</li></ol><hr><h1 id="NO-Session-问题解决"><a href="#NO-Session-问题解决" class="headerlink" title="NO Session 问题解决"></a>NO Session 问题解决</h1><ol><li>不使用延迟加载</li><li>手动将延迟加载初始化 Hibernate.initialize(延迟对象)</li><li>使用spring提供的一个OpenSessionInViewFilter来解决<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;openSessionInView&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;openSessionInView&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong> 基本的原理就是将session的关闭操作不在service层完成，而是在web层才关闭session.</strong><br><strong> 注意:openSessionInViewFilter一定要在Struts2 Filter前配置.</strong></p><p><em>延迟问题，在获取代理对象时，事务已经关闭。所以获取不到这个对象的值，session已经关闭了</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程目标:&lt;br&gt;    能够清晰的说出spring整合Hibernate框架的方式（两种）和原理（管理sessionfactory）&lt;br&gt;    能够独立完成Spring框架整合Hibernate框架（相关的配置）&lt;br&gt;    能够清晰的说出Spring框架整合Str
      
    
    </summary>
    
      <category term="spring整合" scheme="http://HackerFreedom.github.io/categories/spring%E6%95%B4%E5%90%88/"/>
    
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/tags/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>java框架</title>
    <link href="http://HackerFreedom.github.io/2018/03/08/springAOP/"/>
    <id>http://HackerFreedom.github.io/2018/03/08/springAOP/</id>
    <published>2018-03-08T11:47:00.000Z</published>
    <updated>2018-03-10T14:29:06.718Z</updated>
    
    <content type="html"><![CDATA[<p>课程目标:</p><pre><code>能够说出Spring-AOP的应用场景能够清晰的说出AOP术语（目标对象、连接点、切入点、通知、切面、织入、代理对象）能够描述出AOP底层实现的原理（JDK动态代理）和CGLIb动态代理（字节码增强技术）能够描述出基于切点的AOP开发的步骤，并完成统计Order中添加操作的时间能够使用XML配置完成spring整合aspectj完成对目标类的前置增强、后置增强和环绕增强能够使用注解的方式完成spring整合aspectj完成对目标类的前置增强、后置增强和环绕增强</code></pre><h1 id="Aop介绍"><a href="#Aop介绍" class="headerlink" title="Aop介绍"></a>Aop介绍</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> AOP 为 Aspect Oriented Programming 的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术<br>AOP 是一个概念，并没有设定具体语言的实现，它能克服那些只有单继承特性语言的缺点，spring2.0 之后整合 AspectJ 第三方 AOP 技术<br>AspectJ 是一个面向切面的框架，它扩展了 Java 语言。 AspectJ 定义了 AOP 语法所以它有一个专门的编译器用来生成遵守 Java 字节编码规范的 Class 文件。</p><ol><li>主要功能<br>日志记录，性能统计，安全控制，事务处理， 异常处理等等</li><li>主要意图<br>将日志记录，性能统计，安全控制，事务处理， 异常处理等代码从业务逻辑代码中划<br>分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。<br><strong> AOP 与 OOP 区别 </strong><br>OOP(面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装<br>AOP是面象切面的编程  针对业务处理过程中的切面进行提取<br>OOD/OOP 面向名词领域， AOP 面向动词领域</li></ol><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ol><li><p>目标对象<code>target</code><br> 指的是需要被增强的对象，由于spring aop是通过代理模式实现，从而这个对象永远是被代理对象。</p></li><li><p>连接点<code>join point</code><br> 所谓连接点是指那些被拦截到的点，在spring中这些点指的是方法，因为spring只支持方法类型的连接点</p></li><li><p>切入点<code>pointcut</code><br> 切入点是指我们要对哪些连接点进行拦截的定义</p></li><li><p>通知<code>advice</code><br><em>增强的代码 </em><br> 所谓通知是指拦截到连接点之后所要做的事情就是通知，通知分为前置通知，后置通知，异常通知，最终通知，环绕通知,Advice 定义了在 pointcut 里面定义的程序点具体要做的操作</p></li><li><p>切面<code>aspect</code><br> 是切入点和通知的结合</p></li><li><p>引介<code>introduction</code><br> 引介是一种特殊的通知，在不修改类代码的前提下，introduction可以在运行期为类动态地添加一些方法或属性</p></li><li><p>织入<code>weaving</code><br> 织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期，类装载期，运行期进行。<br> Spring采用动态织入，而aspectj采用静态织入</p></li><li><p>代理Proxy<br> 一个类被AOP织入增强后，就产生一个结果代理类</p></li></ol><hr><h1 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h1><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><ol><li>AOP分为静态AOP和动态AOP。</li><li>静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中。(编译时)</li><li>动态AOP是指将切面代码进行动态织入实现的AOP（运行时）</li><li>Spring的AOP为动态AOP，实现的技术为：<br><code>JDK提供的动态代理技术</code> 和 <code>CGLIB</code>(动态字节码增强技术) <h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><em>注意:  cglib它可以为没有实现接口的类做代理，也可以为接口类做代理.</em><br>问题：<code>spring</code>采用的是哪一种动态机制:<br>如果目标对象，有接口，优先使用jdk动态代理<br>如果目标对象，无接口，使用cglib动态代理。<br>cglib代理：目标对象和代理对象是<code>父子关系</code><br>jdk代理：  目标对象和代理对象是<code>兄弟关系</code></li></ol><hr><h1 id="AOP开发"><a href="#AOP开发" class="headerlink" title="AOP开发"></a>AOP开发</h1><p><em>实现AOP需要导入com.springsource.org.aopalliance-1.0.0.jar</em><br>Spring的传统aop编程—————–&gt;基于AspectJ切点表达式的传统aop开发————-&gt;Spring整合aspectj框架实现Aop</p><h2 id="传统基于代理的AOP"><a href="#传统基于代理的AOP" class="headerlink" title="传统基于代理的AOP"></a>传统基于代理的AOP</h2><p>在传统的spring aop开发中它支持增强(advice)有五种:<br>1.<code>前置通知</code> : 目标方法执行前增强 <code>org.springframework.aop.MethodBeforeAdvice</code><br>2.<code>后置通知</code>:  目标方法执行后增强  <code>org.springframework.aop.AfterReturningAdvice</code><br>3.<code>环绕通知</code>:  目标方法执行前后进行增 <code>org.aopalliance.intercept.MethodInterceptor</code><br>4.<code>异常抛出通知</code>: 目标方法抛出异常后的增 <code>org.springframework.aop.ThrowsAdvice</code><br>5.<code>引介通知</code>: 在目标类中添加一些新的方法或属性(不讲解)<br>AOP步骤：</p><pre><code>1.定义目标2.定义通知3.定义切点4.定义切面（通知+切点）5.定义代理</code></pre><hr><h2 id="基于AspectJ切点表达式的传统aop开发"><a href="#基于AspectJ切点表达式的传统aop开发" class="headerlink" title="基于AspectJ切点表达式的传统aop开发"></a>基于AspectJ切点表达式的传统aop开发</h2><p><em>需要导入com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</em><br>引入aop的名称空间:  <code>http://www.springframework.org/schema/aop/spring-aop.xsd</code></p><h1 id="半自动aop-advisor"><a href="#半自动aop-advisor" class="headerlink" title="半自动aop:advisor"></a>半自动aop:advisor</h1><p>让spring帮我们创建代理对象，我们从spring容器中获取代理对象。所以，我们需要的就是一个目标类（和接口）和切面类，然后配置一下，但是这个切面类我们是要遵循规范的，也就是实现环绕方法并实现了里面的方法，在这个方法里面我们写之前我们写的那些前置和后置代码。然后剩下的生成代理类都是通过spring的xml配置文件配置出来的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.hello.aspect;</span><br><span class="line"></span><br><span class="line">import org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line">import org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line">public class MyAspect implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public Object invoke(MethodInvocation arg0) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;方法前&quot;);</span><br><span class="line">        //手动执行方法</span><br><span class="line">        Object proceed = arg0.proceed();</span><br><span class="line">        System.out.println(&quot;方法后&quot;);</span><br><span class="line">        return proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>定义目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 目标target --&gt;</span><br><span class="line">&lt;bean id=&quot;orderService&quot; class=&quot;cn.itheima.aop.OrderServiceImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义通知</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通知advice --&gt;</span><br><span class="line">&lt;bean id=&quot;orderServiceAdvice&quot; class=&quot;cn.itheima.aop.OrderHelper&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>&lt;aop:xxx&gt;</code>标签来完成切面与切点声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;!-- 定义切点 --&gt;</span><br><span class="line">&lt;aop:pointcut id=&quot;orderServicePointCut&quot;</span><br><span class="line">expression=&quot;execution(* cn.itheima.aop.IOrderService.*(..))&quot;/&gt;</span><br><span class="line">&lt;!-- 定义切面 --&gt;</span><br><span class="line">&lt;aop:advisor advice-ref=&quot;orderServiceAdvice&quot; </span><br><span class="line">pointcut-ref=&quot;orderServicePointCut&quot; /&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong> 总结</strong><br>基于切点达表达式的传统的AOP开发的缺点：</p><ol><li>通知类需要实现相应的接口              </li><li>所有的通知方法只能同时去增强一个目标方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:pointcut id=&quot;orderServicePointCut&quot;</span><br><span class="line">expression=&quot;execution(* cn.itheima.aop.IOrderService.*(..))&quot;/&gt;</span><br><span class="line">这个语法源于aspectJ的语法，spring中aop开发，对aspectj不是完全支持，只支持部分语法,在开发中使用的比较多的是execution语法.</span><br></pre></td></tr></table></figure></li></ol><p>关于execution语法常用:</p><ol><li>execution(public <em> </em>()) 所有的public的方法</li><li>execution(<em> cn.itheima.aop..</em>(..)) 所有的aop包及其子包下的所有类的方法 </li><li><code>execution(* cn.itheima.aop.IOrderService.*(..))</code> IOrderService接口中定义的所有方法</li><li>execution(<em> cn.itheima.aop.IOrderService+.</em>(..)) 匹配实现特定接口所有类的方法</li><li>execution(<em> save</em>(..)) 区配所有的以save开头的方法</li></ol><h1 id="全自动"><a href="#全自动" class="headerlink" title="全自动"></a>全自动</h1><p>全自动的配置思路和这个不太一样，全自动的配置意思就是，我们还是在xml里面配置正常的目标类和切面类的bean，<br>然后不配置代理对象的bean了，而是做一个aop的配置.</p><h2 id="aspectj"><a href="#aspectj" class="headerlink" title="aspectj"></a>aspectj</h2><p>在现在的开发中使用这种方案比较多.在spring2.0以后它支持jdk1.5注解，而整合aspectj后可以使用aspectj语法，可以简化开发。<br>Aspect:切面 =切点+通知(多个切点与多个通知的组合)<br>AspectJ 它是一个第三方框架，spring从2.0后可以使用aspectJ框架的部分语法.<br>AspectJ框架它定义的通知类型有6种:</p><ol><li>前置通知<code>Before</code> 相当于<code>BeforeAdvice</code></li><li>后置通知<code>AfterReturning</code> 相当于<code>AfterReturningAdvice</code></li><li>环绕通知<code>Around</code> 相当于<code>MethodInterceptor</code></li><li>抛出通知<code>AfterThrowing</code> 相当于<code>ThrowAdvice</code></li><li>引介通知<code>DeclareParents</code>相当于<code>IntroductionInterceptor</code></li><li>最终通知After 不管是否异常，该通知都会执行<br>相比spring 的传统AOP Advice多了一个最终通知<br>环绕<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">     //前置：before</span><br><span class="line">    //手动执行目标方法</span><br><span class="line">    //后置：afterRetruning</span><br><span class="line">&#125; catch()&#123;</span><br><span class="line">    //抛出异常 afterThrowing</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">    //最终 after</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>除了execution之外，还有：</p><p>within:匹配包或子包中的方法(了解)，within(com.hello.aop..*)<br>this:匹配实现接口的代理对象中的方法(了解)，this(com.hello.aop.user.UserDAO)<br>target:匹配实现接口的目标对象中的方法(了解)，target(com.hello.aop.user.UserDAO)<br>args:匹配参数格式符合标准的方法(了解)，args(int,int)<br>bean(id) 对指定的bean所有的方法(了解)，bean(‘userServiceId’)</p><ol><li><p>定义目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- target --&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;cn.itheima.aspectj.UserServiceImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">package cn.itheima.aspectj;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add() &#123;</span><br><span class="line">       System.out.println(&quot;userService add...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void update() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;userService update...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void del() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(10 / 0); // 一定会抛出异常</span><br><span class="line">System.out.println(&quot;userService del...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">       @Override</span><br><span class="line">public void search() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;userService search...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义通知</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- advice--&gt;</span><br><span class="line">&lt;bean id=&quot;userServiceAdvice&quot; class=&quot;cn.itheima.aspectj.UserServiceHelper&quot;/&gt;</span><br><span class="line">public class UserServiceHelper &#123;</span><br><span class="line">// 前置通知</span><br><span class="line">public void before() &#123;</span><br><span class="line">     System.out.println(&quot;前置通知&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 前置通知</span><br><span class="line">public void before1() &#123;</span><br><span class="line">     System.out.println(&quot;前置通知1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用aop：aspect来配置切面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用aop:config来声明  使用aop:aspect来配置切面 --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;aop:aspect ref=&quot;userServiceAdvice&quot;&gt;</span><br><span class="line">&lt;aop:pointcut expression=&quot;execution(* *..UserService Impl.add(..))&quot; id=&quot;pointCut1&quot;/&gt;</span><br><span class="line"> &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointCut1&quot;/&gt;</span><br><span class="line">&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)</span><br><span class="line">public class AspectJTest &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private IUserService userService;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">userService.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong> 其他通知</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceHelper &#123;</span><br><span class="line">// 前置通知</span><br><span class="line">public void before() &#123;</span><br><span class="line"> System.out.println(&quot;前置通知&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 前置通知</span><br><span class="line">public void before1() &#123;</span><br><span class="line"> System.out.println(&quot;前置通知1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 后置通知</span><br><span class="line">public void afterReturning() &#123;</span><br><span class="line"> System.out.println(&quot;后置通知&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 环绕通知</span><br><span class="line">public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line"> System.out.println(&quot;环绕前....&quot;);</span><br><span class="line">Object value = pjp.proceed(); // 执行目标行为</span><br><span class="line">System.out.println(&quot;环绕后....&quot;);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">// 异常抛出通知</span><br><span class="line">public void afterThrowing() &#123;</span><br><span class="line"> System.out.println(&quot;发现了异常。。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 最终通知</span><br><span class="line">public void after() &#123;</span><br><span class="line"> System.out.println(&quot;最终通知&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>后置通知</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;aop:aspect ref=&quot;userServiceAdvice&quot;&gt;</span><br><span class="line">&lt;aop:pointcut expression=&quot;execution(* *..UserServiceImpl.add(..))&quot; id=&quot;pointCut1&quot;/&gt;</span><br><span class="line"> &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pointCut1&quot;/&gt;</span><br><span class="line">&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></p><p><em>环绕通知</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;aop:aspect ref=&quot;userServiceAdvice&quot;&gt;</span><br><span class="line">&lt;aop:pointcut expression=&quot;execution(* *..UserServiceImpl.add(..))&quot; id=&quot;pointCut1&quot;/&gt;</span><br><span class="line">  &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pointCut1&quot;/&gt;</span><br><span class="line">&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p> <em>测试结果</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我是around的前置</span><br><span class="line">addUser方法</span><br><span class="line">我是around的后置</span><br><span class="line">---------</span><br><span class="line">我是around的前置</span><br><span class="line">updateUser方法</span><br><span class="line">我是around的后置</span><br><span class="line">--------</span><br><span class="line">我是around的前置</span><br><span class="line">deleteUser方法</span><br><span class="line">我是around的后置</span><br></pre></td></tr></table></figure></p><p><em>异常通知</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;aop:aspect ref=&quot;userServiceAdvice&quot;&gt;</span><br><span class="line">&lt;aop:pointcut expression=&quot;execution(* *..UserServiceImpl.del(..))&quot; id=&quot;pointCut1&quot;/&gt;</span><br><span class="line"> &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pointCut1&quot;/&gt;</span><br><span class="line">&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">注意：目标行为只有抛出了异常后才会执行这个增强方法</span><br></pre></td></tr></table></figure></p><p><em>最终通知</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;aop:aspect ref=&quot;userServiceAdvice&quot;&gt;</span><br><span class="line">&lt;aop:pointcut expression=&quot;execution(* *..UserServiceImpl.del(..))&quot; id=&quot;pointCut1&quot;/&gt;</span><br><span class="line">&lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointCut1&quot;/&gt;</span><br><span class="line">&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">无论是否有异常，最终通知都会执行.</span><br></pre></td></tr></table></figure></p><p>测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">userService.del();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Spring整合aspectj框架实现Aop"><a href="#Spring整合aspectj框架实现Aop" class="headerlink" title="Spring整合aspectj框架实现Aop"></a>Spring整合aspectj框架实现Aop</h2><h1 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h1><p>第一步：把通知和目标纳入Spring的管理当中：<br>开启注解扫描<code>&lt;context:component-scan base-package=&quot;cn.itheima&quot;/&gt;</code><br>在通知和目标类上配置<code>@Component</code></p><p>第二步:定义目标</p><p>第三步：定义切面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class CustomerServiceHelper &#123;</span><br><span class="line"></span><br><span class="line">// 前置通知</span><br><span class="line">@Before(&quot;execution(* *.save(..))&quot;)</span><br><span class="line">public void before() &#123;</span><br><span class="line">   System.out.println(&quot;前置通知...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用@Aspect来声明切面</span><br><span class="line">使用@Before来声明前置通知</span><br></pre></td></tr></table></figure></p><p>第四步：开启aspectj注解的自动代理<code>&lt;aop:aspectj-autoproxy/&gt;</code><br>第五步：测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)</span><br><span class="line">public class AspectAnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private ICustomerService customerService;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">customerService.save();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="对于其它通知"><a href="#对于其它通知" class="headerlink" title="对于其它通知"></a>对于其它通知</h1><p>后置通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@AfterReturning(value = &quot;execution(* *.update(..))&quot;, returning = &quot;value&quot;)</span><br><span class="line">public void afterReturning(JoinPoint jp, Object value) &#123;</span><br><span class="line">System.out.println(&quot;后置通知,目标方法的返回是&quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>环绕通知</em>:<br>调用<code>pjp.proceed</code>才会调用代理对象的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Around(&quot;execution(* *.s*(..))&quot;)</span><br><span class="line">public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;环绕前...&quot;);</span><br><span class="line">Object value = pjp.proceed();</span><br><span class="line">System.out.println(&quot;环绕后&quot;);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异常通知:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@AfterThrowing(value=&quot;execution(* *.s*(..))&quot;, throwing=&quot;tx&quot;)</span><br><span class="line">public void afterThrowing(Throwable tx) &#123;</span><br><span class="line">System.out.println(&quot;异常抛出通知:&quot; + tx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通知:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@After(&quot;execution(* *.s*(..))&quot;)</span><br><span class="line">public void after() &#123;</span><br><span class="line">System.out.println(&quot;最终通知&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>声明了一个公共切入点，后面直接引用即可，不用每次都写一大串的表达式了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">在每一个通知中定义切点，工作量大，不方便维护，可以使用@Pointcut来声明切点</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class CustomerServiceHelper &#123;</span><br><span class="line"></span><br><span class="line">// 定义切点</span><br><span class="line">@Pointcut(&quot;execution(* *.s*(..))&quot;)</span><br><span class="line">private void mypointcut() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Pointcut(&quot;execution(* *.update(..))&quot;)</span><br><span class="line">private void mypointcut1() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用上面定义的切点</span><br><span class="line">@Before(&quot;mypointcut()||mypointcut1()&quot;)</span><br><span class="line">public void before() &#123;</span><br><span class="line">System.out.println(&quot;前置通知...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用上面定义的切点</span><br><span class="line">@After(&quot;mypointcut()&quot;)</span><br><span class="line">public void after() &#123;</span><br><span class="line">System.out.println(&quot;最终通知&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">切点允许逻辑运算例如mypointcut()||mypointcut1</span><br></pre></td></tr></table></figure></p><hr><p>始终使用cglib代理：<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程目标:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;能够说出Spring-AOP的应用场景
能够清晰的说出AOP术语（目标对象、连接点、切入点、通知、切面、织入、代理对象）
能够描述出AOP底层实现的原理（JDK动态代理）和CGLIb动态代理（字节码增强技术）
能够描述出基于切点的A
      
    
    </summary>
    
      <category term="springAOP" scheme="http://HackerFreedom.github.io/categories/springAOP/"/>
    
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/tags/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>java框架</title>
    <link href="http://HackerFreedom.github.io/2018/03/06/spring%E5%9F%BA%E7%A1%80/"/>
    <id>http://HackerFreedom.github.io/2018/03/06/spring基础/</id>
    <published>2018-03-06T13:32:00.000Z</published>
    <updated>2018-03-10T14:35:50.634Z</updated>
    
    <content type="html"><![CDATA[<p>课程目标:</p><pre><code>能够结合spring的体系结构图描述spring的体系结构能够清晰的描述出对IOC和DI的理解，并能描述出两者的联系和区别能够在spring中独立完成Bean的管理，获取和实例化能够分别使用xml配置和注解的方式完成Bean的管理和属性注入能够描述出Spring在Web中应用的原理能够使用Spring整合Junit完成单元测试</code></pre><h1 id="spring框架介绍"><a href="#spring框架介绍" class="headerlink" title="spring框架介绍"></a>spring框架介绍</h1><p>(一站式) 轻量级开源框架致力于 J2EE  .Net  安卓，应用的各层的解决方案</p><h1 id="spring框架体系结构和优点"><a href="#spring框架体系结构和优点" class="headerlink" title="spring框架体系结构和优点"></a>spring框架体系结构和优点</h1><ol><li>spring体系结构<br> 核心: beans,core,context,spEL<br> 数据访问:springDate  jdbcTemplate<pre><code>AOP：web:junit:</code></pre></li><li>spring的优点<br> 方便解耦，简化开发<br> AOP 编程的支持<br> 声明式事务的支持<br> 方便程序的测试<br> 方便集成各种优秀框架<br> 降低 JavaEE API 的使用难度</li></ol><h1 id="IOC（控制反转）和DI（依赖注入）"><a href="#IOC（控制反转）和DI（依赖注入）" class="headerlink" title="IOC（控制反转）和DI（依赖注入）"></a>IOC（控制反转）和DI（依赖注入）</h1><p>IOC原理= 配置文件统一管理bean + 工厂 ======&gt; dom解析 + 反射</p><p>代码实现：</p><pre><code>1. 导入相关jar包2. 定义类3. 在applicationContext.xml文件中配置bean4. 通过AppliCationContext对象获取userService5. test中通过getBean(配置文件中id名称)来获取指定的对象</code></pre><h1 id="springDI介绍"><a href="#springDI介绍" class="headerlink" title="springDI介绍"></a>springDI介绍</h1><p><code>DI:dependency injection</code>依赖注入<br>在spring框架负责创建Bean对象时，动态将依赖对象注入到Bean组件</p><p>面试题:IOC和DI区别?<br>1.IOC: Spring统一管理应用程序运行时所需要的资源</p><ol><li>DI ：应用程序运行时所需要的资源由Spring来提供    </li><li>站在Spring的角度就是IOC, 站在应用程序的角度就是DI, IOC是DI的前提</li><li>应用程序能够DI注入的前提是：所注入资源要在Spring的管理中; 自己也要在Spring管理中</li></ol><h1 id="Spring管理Bean"><a href="#Spring管理Bean" class="headerlink" title="Spring管理Bean"></a>Spring管理Bean</h1><h2 id="xml管理"><a href="#xml管理" class="headerlink" title="xml管理"></a>xml管理</h2><ol><li>ApplicationContext与BeanFactory区别<ol><li>ApplicationContext它是扩展BeanFactory接口,<br>ApplicationContext实例化bean采用的立即策略(默认)，<br>在加载applicationContext.xml文件的时候就实例化bean对象</li><li>BeanFactory实例化bean采用的延迟策略，只有getBean的时候才会实例化bean对象</li></ol></li><li>pringBean的获取与实例化-实例化三种方式<ol><li>无参数构造<code>&lt;bean id=&quot;userService&quot; class=&quot;cn.itheima.ioc.UserServiceImpl&quot;&gt;&lt;/bean&gt;</code></li><li>静态工厂方法</li><li>实例工厂方法</li></ol></li><li>pringBean的获取与实例化-作用域scope<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;cn.itheima.ioc.UserServiceImpl&quot; scope=&quot;singleton&quot;&gt;</span><br><span class="line">&lt;property name=&quot;info&quot; value=&quot;ITCAST&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在bean声明时它有一个scope属性，它是用于描述bean的作用域。<br>singleton:单例 代表在spring ioc容器中只有一个Bean实例 (默认的scope)<br>prototype多例 每一次从spring容器中获取时，都会返回一个新的实例<br>request 用在web开发中，将bean对象<code>request.setAttribute()</code>存储到request域中<br>session 用在web开发中，将bean对象<code>session.setAttribute()</code>存储到session域中<br>在开发中常用的值是singleton与prototype</p></blockquote><ol><li>Bean的生命周期<br><img src="/2018/03/06/spring基础/bean1.png" alt=""><br>总结:<br> 对于bean的生命周期，我们需要关注的主要有两个方法:</li></ol><p>1.增强bean的功能可以使用后处理Bean, <code>BeanPostProcessor</code><br>2.如果需要初始化或销毁操作我们可以使用<code>init-method</code> <code>destroy-method</code></p><p>注意:destroy-method只对scope=singleton有效果</p><h1 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用构造方法对car的属性进行注入 --&gt;</span><br><span class="line">&lt;bean id=&quot;car&quot; class=&quot;cn.itheima.di.Car&quot;&gt;</span><br><span class="line">&lt;constructor-arg index=&quot;0&quot; value=&quot;奔弛&quot;/&gt;</span><br><span class="line">&lt;constructor-arg index=&quot;1&quot; value=&quot;1000000&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">public void test1() &#123;</span><br><span class="line">ApplicationContext applicationContext = </span><br><span class="line">new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Car car = (Car) applicationContext.getBean(&quot;car&quot;);</span><br><span class="line">System.out.println(car.getName() + &quot;  &quot; + car.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性注入-setter方法"><a href="#属性注入-setter方法" class="headerlink" title="属性注入-setter方法"></a>属性注入-setter方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用setter方法对car的属性进行注入 --&gt;</span><br><span class="line">&lt;bean id=&quot;car1&quot; class=&quot;cn.itheima.di.Car&quot;&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;宝马&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;price&quot; value=&quot;500000&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;person&quot; class=&quot;cn.itheima.di.Person&quot;&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;car&quot; ref=&quot;car1&quot; /&gt;&lt;!-- ref引用其它bean的id或name值 --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">ApplicationContext applicationContext = </span><br><span class="line">new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person person = (Person) applicationContext.getBean(&quot;person&quot;);</span><br><span class="line">System.out.println(person.getName() + &quot;  &quot; + person.getCar().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="集合属性注入"><a href="#集合属性注入" class="headerlink" title="集合属性注入"></a>集合属性注入</h1><p>在spring中对于集合属性，可以使用专门的标签来完成注入例如:list   set  map properties等集合元素来完成集合属性注入.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 集合属性注入 --&gt;</span><br><span class="line">&lt;bean id=&quot;collectionDemo&quot; class=&quot;cn.itheima.di.CollectionDemo&quot;&gt;</span><br><span class="line">&lt;property name=&quot;list&quot;&gt;</span><br><span class="line"> &lt;list&gt;</span><br><span class="line">&lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">&lt;value&gt;10&lt;/value&gt;</span><br><span class="line">&lt;ref bean=&quot;car&quot; /&gt;</span><br><span class="line">  &lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;set&quot;&gt;</span><br><span class="line">  &lt;set&gt;</span><br><span class="line">&lt;value&gt;10&lt;/value&gt;</span><br><span class="line">&lt;value&gt;李四&lt;/value&gt;</span><br><span class="line">&lt;ref bean=&quot;person&quot; /&gt;</span><br><span class="line">  &lt;/set&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;map&quot;&gt;</span><br><span class="line">   &lt;map&gt;</span><br><span class="line">  &lt;entry key=&quot;username&quot; value=&quot;李四&quot;&gt;&lt;/entry&gt;</span><br><span class="line">  &lt;entry key-ref=&quot;person&quot; value-ref=&quot;car&quot;&gt;&lt;/entry&gt;</span><br><span class="line">   &lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;props&quot;&gt;</span><br><span class="line">   &lt;props&gt;</span><br><span class="line">  &lt;prop key=&quot;company&quot;&gt;ITCAST&lt;/prop&gt;</span><br><span class="line">  &lt;prop key=&quot;price&quot;&gt;10000&lt;/prop&gt;</span><br><span class="line">   &lt;/props&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p><strong>总结</strong><br>对于三种注入方式，只需要记住<code>constructor-arg</code> 描述构造器的，<code>property</code>是对类中属性的成员set方法的描述，但是集合中要提供name的集合名称。</p><h1 id="名称空间p和c的使用"><a href="#名称空间p和c的使用" class="headerlink" title="名称空间p和c的使用"></a>名称空间p和c的使用</h1><p>P名称空间; C名称空间<br>首先它们不是真正的名称空间，是虚拟的。它是嵌入到spring内核中的。<br>使用p名称空间可以解决我们setter注入时<property>简化<br>使用c名称空间可以解决我们构造器注入时<code>&lt;constructor-arg&gt;</code>简化</property></p><p><em>注意xml文件的配置</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">xsi:schemaLocation=&quot;</span><br><span class="line">http://www.springframework.org/schema/beans </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><h2 id="注解管理"><a href="#注解管理" class="headerlink" title="注解管理"></a>注解管理</h2><ol><li>spring注解开发-bean注册.avi(重点) —–&gt;ioc<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 导入aop的jar包</span><br><span class="line">- 在xml中引入context的名称空间</span><br><span class="line">- 开启注解扫描</span><br><span class="line">-  &lt;context:component-scan base-package=&quot;cn.itheima&quot; /&gt;  </span><br><span class="line">-  这个配置作用是指定spring扫描的包,它包含了context:annotation-config的功能(让spring中常用的一些注解生效)</span><br><span class="line">- 在需要被ioc（Spring管理）的类上配置@Component</span><br></pre></td></tr></table></figure></li></ol><p>在spring2.5后为<code>@Component</code>添加了三个衍生的注解<br><code>@Repository</code> 用于DAO层<br><code>@Service</code> 用于service层<br><code>@Controller</code>  用于表现层<br>对于我们的bean所处在的位置可以选择上述三个注解来应用，如果你的bean不明确位置，就可以使用<code>@Component</code> </p><h1 id="spring注解开发-属性依赖注入-avi-重点"><a href="#spring注解开发-属性依赖注入-avi-重点" class="headerlink" title="spring注解开发-属性依赖注入.avi(重点)"></a>spring注解开发-属性依赖注入.avi(重点)</h1><p>案例实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;userService&quot;)</span><br><span class="line">public class UserServiceImpl implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">@Value(&quot;张三&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add() &#123;</span><br><span class="line"> System.out.println(&quot;userService add..&quot; + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service(&quot;userService&quot;)</span><br><span class="line">public class UserServiceImpl implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">@Value(&quot;张三&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private IUserDAO userDao;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add() &#123;</span><br><span class="line">// System.out.println(&quot;userService add..&quot; + name);</span><br><span class="line">userDao.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>注意</em>：<code>@Value @Autowired</code>它们可以修饰属性，也可以修饰setter方法（在这里会在Spring中调用这个方法），如果写在属性上，就不需要提供setter方法（只是起到赋值的作用）。</p><h1 id="spring注解开发-属性依赖注入指定注入的名称-avi-重点"><a href="#spring注解开发-属性依赖注入指定注入的名称-avi-重点" class="headerlink" title="spring注解开发-属性依赖注入指定注入的名称.avi(重点)"></a>spring注解开发-属性依赖注入指定注入的名称.avi(重点)</h1><p>案例实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;userService&quot;)</span><br><span class="line">public class UserServiceImpl implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;userDao&quot;)</span><br><span class="line">private IUserDAO userDao;  //</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add() &#123;</span><br><span class="line">userDao.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">package cn.itheima.annotation;</span><br><span class="line"></span><br><span class="line">@Service(&quot;userService&quot;)</span><br><span class="line">public class UserServiceImpl implements IUserService &#123;</span><br><span class="line">@Resource(name=&quot;userDao&quot;)</span><br><span class="line">private IUserDAO userDao;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add() &#123;</span><br><span class="line"> userDao.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>spring注解开发-其它注解.avi(掌握)    </li></ol><p><code>@Scope(&quot;prototype&quot;)</code>@Scope它以描述bean的作用域<br><code>@PostConstruct</code>相当于<code>init-method=”mInit”</code><br><code>@PreDestroy</code> 相当于是<code>destroy-method=”mDestroy”</code><br>注意：对于销毁的方法它只对bean的<code>scope=singleton</code>有效</p><p>依赖注入的前提，控制反转</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程目标:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;能够结合spring的体系结构图描述spring的体系结构
能够清晰的描述出对IOC和DI的理解，并能描述出两者的联系和区别
能够在spring中独立完成Bean的管理，获取和实例化
能够分别使用xml配置和注解的方式完成Bean的
      
    
    </summary>
    
      <category term="spring基础" scheme="http://HackerFreedom.github.io/categories/spring%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/tags/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JSP和MVC模式</title>
    <link href="http://HackerFreedom.github.io/2018/03/01/jsp%E4%BB%8B%E7%BB%8D%E5%9F%BA%E7%A1%80/"/>
    <id>http://HackerFreedom.github.io/2018/03/01/jsp介绍基础/</id>
    <published>2018-03-01T07:11:00.000Z</published>
    <updated>2018-03-13T09:12:46.105Z</updated>
    
    <content type="html"><![CDATA[<p>目标:</p><blockquote><p>阐述什么是JSP及其运行原理<br>阐述JSP中如何嵌入脚本元素以及软件开发模式的发展历程<br>解决开发中的路径问题：相对路径与绝对路径<br><code>阐述请求转发和重定向的区别(面试重点)</code><br>完成登录成功统计在线人数的案例(重点)</p></blockquote><hr><h1 id="JSP-的概述"><a href="#JSP-的概述" class="headerlink" title="JSP 的概述"></a>JSP 的概述</h1><p>JSP：<code>Java Server Page</code>s (Java服务器端页面)，其实就在HTML中嵌入Java代码。</p><p>Servlet:擅长处理业务逻辑<br>JSP:擅长输出HTML标签</p><h2 id="jsp的运行原理"><a href="#jsp的运行原理" class="headerlink" title="jsp的运行原理"></a>jsp的运行原理</h2><p><img src="/2018/03/01/jsp介绍基础/jsp01.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：jsp本身是一个Servlet，所以要访问jsp文件必须部署到服务器上</span><br></pre></td></tr></table></figure></p><h2 id="jsp的脚本元素"><a href="#jsp的脚本元素" class="headerlink" title="jsp的脚本元素"></a>jsp的脚本元素</h2><p>1、使用<code>&lt;%!int i=100; %&gt;</code>声明的变量是成员变量<br>声明方法：</p><p>2、书写java程序代码：（在<code>&lt;% %&gt;</code>里面声明的变量是局部变量）</p><p>3、向页面输出java表达式结果：<code>&lt;%=i %&gt;</code></p><p>注意: <code>&lt;%  Java代码 %&gt;</code> 和 <code>&lt;%=i%&gt;</code> 经常用,  &lt;%! 这个不太用  %&gt;</p><p>总结:<br>JSP = HTML + Java代码 + JSP标签</p><p>//这段代码在类的成员位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">int age = 19;</span><br><span class="line">public void show() &#123;...&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">//这段代码在一个方法里</span><br><span class="line">&lt;%</span><br><span class="line">int i = 10;</span><br><span class="line">System.out.println(i); </span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">//这段代码在方法里, 用out.print()向页面输出</span><br><span class="line">&lt;%= i%&gt;</span><br></pre></td></tr></table></figure></p><h2 id="jsp的开发模式之MVC模式"><a href="#jsp的开发模式之MVC模式" class="headerlink" title="jsp的开发模式之MVC模式"></a>jsp的开发模式之MVC模式</h2><ol><li><p>Servlet优缺点：获取请求数据和处理数据非常方便；但是向页面输出并显示数据（html标签）非常麻烦，毫无格式！<br>jsp优缺点：jsp显示数据非常方便，像html格式一样；但是封装数据和处理数据比较麻烦。</p></li><li><p>MVC模式：<br>M：<code>model层</code>（模型层），一般用来封装和处理数据<br>V：<code>View层</code>（视图层），一般只用了展示数据，显示信息。<br>C： <code>Controller</code>层（控制层），一般调用Model层方法获取数据，发送给View层显示，起到一个连接Model层和View层的作用。</p></li></ol><p>在我们的jsp开发之中，javaBean属于<code>model</code>层，Servlet属于<code>Controller</code>层，jsp属于<code>View</code>层</p><p><img src="/2018/03/01/jsp介绍基础/jsp02.png" alt=""></p><p>jsp + javaBean</p><p>请求——-&gt;JSP—–&gt;JavaBean</p><p>请求——–&gt;Servlet-(Controller)——-&gt;JavaBean(Model)——-&gt;JSP(View)</p><blockquote><p>jsp和Servlet各有什么优缺点？<br>jsp是一个html页面，用于显示数据，但是封装数据比较繁琐<br>而servlet在处理数据很容易，相反显示数据就很繁琐了</p><p>MVC模式 是什么？</p></blockquote><p>m：表示model层，一般是用来处理数据的<br>v：表示view层，展示视图，显示信息</p><h2 id="c-controller层，控制model层，发送给view层显示。"><a href="#c-controller层，控制model层，发送给view层显示。" class="headerlink" title="c:controller层，控制model层，发送给view层显示。"></a>c:controller层，控制model层，发送给view层显示。</h2><h1 id="开发中路径的问题"><a href="#开发中路径的问题" class="headerlink" title="开发中路径的问题"></a>开发中路径的问题</h1><ol><li><p>相对路径是相对于当前的jsp或者html文件的。不以/ 开始,我们跳转之前要看这两个路径（当前文件路径和目标文件路径），很不方便。</p></li><li><p>绝对路径都是用/开头的，可以直接从项目名开始写，<br>例如：<code>&lt;a href=&quot;/javaweb_day11/AServlet&quot;&gt;</code>跳转<code>到AServlet2&lt;/a&gt;</code></p></li></ol><p>注意: 强烈建议使用绝对路径,以/ 开始  </p><h2 id="如-lt-a-href-”-web02-ServletDemo1”-gt-hello-lt-a-gt"><a href="#如-lt-a-href-”-web02-ServletDemo1”-gt-hello-lt-a-gt" class="headerlink" title="如:&lt;a href=”/web02/ServletDemo1” &gt;hello&lt;/a&gt;"></a>如:<code>&lt;a href=”/web02/ServletDemo1” &gt;hello&lt;/a&gt;</code></h2><h1 id="请求转发和重定向的区别"><a href="#请求转发和重定向的区别" class="headerlink" title="请求转发和重定向的区别"></a>请求转发和重定向的区别</h1><ul><li>请求转发是一次请求一次响应，而重定向是两次请求两次响应。</li><li>请求转发地址栏不会变化的，重定向地址栏发生变化。</li><li>请求转发路径不带工程名，重定向需要带工程名路径。</li><li>请求转发只能在本网站内部，重定向可以定向到任何网站。</li></ul><p><img src="/2018/03/01/jsp介绍基础/jsp03.png" alt="">;<br><strong>注意：</strong><br>如果需要使用request进行值传递，需要通过请求转发完成。如果页面需要跳转到其他网站上必须使用重定向。<br>   其他情况用哪个都行</p><h2 id="转发和重定向如何选择"><a href="#转发和重定向如何选择" class="headerlink" title="转发和重定向如何选择?"></a>转发和重定向如何选择?</h2><p>1.如果要使用request共享数据,使用转发<br>i.<code>(reques.getRequestDispatcher(“/demo.jsp”).forward(request,response))</code><br>2.如果要跳转到其他网站,必须使用重定向    <code>(response.sendRedirect(“http://www.baidu.com”))</code></p><h2 id="3-其他情况-2个都可以"><a href="#3-其他情况-2个都可以" class="headerlink" title="3.其他情况,2个都可以"></a>3.其他情况,2个都可以</h2><h1 id="request"><a href="#request" class="headerlink" title="request"></a>request</h1><p>获取请求参数<br>解决post中文乱码<br>解决get中文乱码</p><hr><h1 id="登录成功后的人数显示"><a href="#登录成功后的人数显示" class="headerlink" title="登录成功后的人数显示"></a>登录成功后的人数显示</h1><ul><li>在服务器启动的时候初始化一个值为零，将这个值存入到ServletContext域中<br><img src="/2018/03/01/jsp介绍基础/jsp04.png" alt="">;</li><li>将这个Servlet配置成启动时加载</li></ul><p><img src="/2018/03/01/jsp介绍基础/jsp05.png" alt="">;</p><ul><li><p>记录登录的人数<br><img src="/2018/03/01/jsp介绍基础/jsp06.png" alt="">;</p></li><li><p>在登录成功页面上显示总人数<br><img src="/2018/03/01/jsp介绍基础/jsp07.png" alt="">;</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目标:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阐述什么是JSP及其运行原理&lt;br&gt;阐述JSP中如何嵌入脚本元素以及软件开发模式的发展历程&lt;br&gt;解决开发中的路径问题：相对路径与绝对路径&lt;br&gt;&lt;code&gt;阐述请求转发和重定向的区别(面试重点)&lt;/code&gt;&lt;br&gt;完成登录
      
    
    </summary>
    
      <category term="jsp介绍" scheme="http://HackerFreedom.github.io/categories/jsp%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="jsp介绍基础" scheme="http://HackerFreedom.github.io/tags/jsp%E4%BB%8B%E7%BB%8D%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java框架</title>
    <link href="http://HackerFreedom.github.io/2018/02/27/hibernate%E7%BC%93%E5%AD%98/"/>
    <id>http://HackerFreedom.github.io/2018/02/27/hibernate缓存/</id>
    <published>2018-02-27T02:42:00.000Z</published>
    <updated>2018-03-04T01:22:46.508Z</updated>
    
    <content type="html"><![CDATA[<p>学习目标:</p><pre><code>记忆持久化类的编写规则能够使用主键生成策略生成主键   能够描述对一级缓存的理解能够描述出持久化对象能够修改数据的原因能够分析多表之间的三种关联关系，并且能设计三种关联关系的数据库表能够独立完成一对多关系的配置，并能完成级联保存能够清晰的描述出cascade和inverse的作用  </code></pre><h1 id="持久类和主键生成策略"><a href="#持久类和主键生成策略" class="headerlink" title="持久类和主键生成策略"></a>持久类和主键生成策略</h1><p> Hibernate中定义的主键类型包括：自然主键和代理主键<br>自然主键：具有业务含义 字段 作为主键，比如：学号、身份证号<br>代理主键：不具有业务含义 字段作为主键（例如 自增id），比如：mysql自增主键，oracle序列生成的主键、uuid()方法生成的唯一序列串</p><p> 手动生成主键: assigned （自然主键）<br>           hibernate生成主键：increment,uuid<br>           数据库生成主键：identity(mysql) sequence(orcale),  native(本地策略)</p><ul><li>increment <ul><li>优点:可以方便跨平台</li><li>缺点:不适合高并发访问</li></ul></li><li>identity<ul><li>优点:由底层数据库维护，和hibernate无关</li><li>缺点:只能对支持自动增长的数据库有效</li></ul></li><li><p>sequence </p><ul><li>优点:由底层数据库维护，和hibernate无关</li><li>缺点:数据库必须支持sequence方案例如oracle</li></ul></li><li><p>native </p><ul><li>优点:在项目中如果存在多个数据库时使用</li><li>缺点:效率比较低<h1 id="持久对象的三种状态"><a href="#持久对象的三种状态" class="headerlink" title="持久对象的三种状态"></a>持久对象的三种状态</h1></li></ul></li></ul><ol><li>瞬时态<ol><li>临时态或者自由态：无OID 与数据库中的信息无关联，不在session管理范围内。 </li></ol></li><li>持久态<ol><li>有OID 由session管理，在数据库中有可能有，也有可有没有。</li></ol></li><li>托管态<ol><li>游离态或者离线态  持久态对象失去了与session的关联，托管态对象它存在OID,在数据库中有可能存在，也有可能不存在</li></ol></li></ol><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>在session中定义了一系列的集合来存储数据，它们构成session缓存,只要session没有关闭，它就会一直存在。</p><p>当我们通过hibernate中的session提供的一些API例如 save  get  update等进行操作时，就会将持久化对象保存到session中，当下一次在去查询缓存中具有的对象(OID值来判断)，就不会去从数据库查询，而是直接从缓存中获取。</p><blockquote><p>Hibernate的一级缓存存在的目的就是为了减少对数据库访问。<br>    在hibernate中还有一个二级缓存，它是SessionFactory级别缓存。</p></blockquote><p><strong>注意的要点</strong></p><ol><li>当commit的时候比对一级缓存和快照数据是否一致，如果不一致就发送更新的sql语句到数据库更新数据</li><li>Hibernate对session的crud操作都会将数据缓存到一级缓存;只有oid查询（get/load）查询才会从一级缓存拿数据，其他查询就算一级缓存有数据任然会发  送sql语句查询，</li><li>session一级缓存不允许不同的对象有相同的oid<br> 异常：A different object with the same identifier value was already associated with the session</li><li>delete,update操作的托管对象如果oid在数据库没有该记录会报错<br> 异常： Batch update returned unexpected row count from update [0]; actual row count: 0;</li><li>持久化对象关联了一个瞬时对象<br> 异常： org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing:</li></ol><h1 id="数据对象的三种关系"><a href="#数据对象的三种关系" class="headerlink" title="数据对象的三种关系"></a>数据对象的三种关系</h1><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><ol><li>实体类 （注意提供一方和多方 的构造方法，）</li><li><p>配置（映射文件的配置）</p><ol><li>多方      <pre><code>&lt;many-to-one name=&quot;&quot; class=&quot;&quot; column=&quot;&quot;/ &gt; 实现多对一   name属性它描述的是Order类中的一的一方的属性名称 Customer c;   class 代表一的一方的全类名   column 描述的是一对多，在多的一方产生的外键的名称 c_customer_id</code></pre></li><li>一方<pre><code>&lt;set &gt;    &lt;key column=&quot;&quot;/&gt;        &lt;one-to-many class=&quot;&quot;&gt;    &lt;/set&gt;</code></pre>name属性就是set集合的属性名称<br>key:它主要描述关联的多的一方产生的外键名称，注意要与多的一方定义的外键名称相同<br>one-to-many的class描述集合中类的全类名</li></ol></li><li><p>级联 </p><pre><code>1. 级联发起方 需要关联被级联的一方    一方的Customer级联保存多方的Order条件：1.set上配置cascade=&quot;save-update&quot;2.一方关联被级联的多方Order（这时session保存的是客户）    c.getOrders().add(o1);    c.getOrders().add(o2);    多方的Order级联保存一方的Customer条件：    1.many-to-one配置cascade=&quot;save-update&quot;2.多方Order关联一方Customer  （这时session保存的订单）      o1.setC(c);        o2.setC(c);</code></pre><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习目标:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;记忆持久化类的编写规则
能够使用主键生成策略生成主键   
能够描述对一级缓存的理解
能够描述出持久化对象能够修改数据的原因
能够分析多表之间的三种关联关系，并且能设计三种关联关系的数据库表
能够独立完成一对多关系的配置，并能完成级
      
    
    </summary>
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/categories/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="hibernate缓存" scheme="http://HackerFreedom.github.io/tags/hibernate%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Java框架</title>
    <link href="http://HackerFreedom.github.io/2018/02/27/hibernate%E4%BC%98%E5%8C%96/"/>
    <id>http://HackerFreedom.github.io/2018/02/27/hibernate优化/</id>
    <published>2018-02-27T02:42:00.000Z</published>
    <updated>2018-03-04T02:25:13.842Z</updated>
    
    <content type="html"><![CDATA[<p>学习目标:</p><pre><code>能够使用HQL语句完成多表操作能够从概念、特点、隔离级别几个方面描述出对事务的理解记忆HQL优化的方法并能对一级缓存进行优化能够说出对hibernate中的抓取策略的理解，并能够配置各种抓取策略</code></pre><p>在这里我们首先要复习一下 sql语句的知识</p><h1 id="HQL多表操作"><a href="#HQL多表操作" class="headerlink" title="HQL多表操作"></a>HQL多表操作</h1><pre><code>1.交叉连接2.内连接    a)显示内连接    b)隐式内连接    *c)迫切内连接*3.外连接    左外连接    *迫切左外连接*    右外连接</code></pre><p><em>注意：在hibernate中有迫切连接的概念，而sql中没有。</em><br>掌握：           </p><pre><code>1. from Customer c join c.orders;    from Order o join o.c;2. 迫切和非迫切的区别：    1.非迫切返回对象数组，迫切直接返回对象    2.在一对多里面，这一条迫切的sql语句就完成了一方关联的多方数据的封装</code></pre><p>代码案例：<br>        @Test<br>        public void test3() {<br>        Query query = session<br>            .createQuery(“select distinct c from Customer c join fetch c.orders”);<br>            List<customer> list = query.list();<br>            for (Customer c : list) {</customer></p><pre><code>        System.out.println(c + &quot; &quot; + c.getOrders());}}</code></pre><p>非迫切对象：<br>        Test<br>        public void test1() {<br>        Query query = session.createQuery(“from Customer c left join c.orders”);<br>        List<object[]> list = query.list();<br>        for (Object[] objects : list) {<br>             System.out.println(objects[0] + “ “ + objects[1]);<br>        }<br>        }</object[]></p><h1 id="Hibernate的事务管理"><a href="#Hibernate的事务管理" class="headerlink" title="Hibernate的事务管理"></a>Hibernate的事务管理</h1><p><em>复习mysql的事务</em><br>1、事务：指的是一组逻辑操作，要么同时成功要么同时失败。<br>3、事务的四大特性：<br>原子性：组成事务的最小单元是不可分割的，要么同时成功要么同时失败。<br>一致性：执行事务前后，数据的完整性是一致的；（也就是案例中总钱数是一样的）<br>隔离性：在数据库中，各个事务之间是独立的，不受其他事务的影响。<br>持久性：事务一旦结束，数据就会持久保存到数据库中。</p><ol><li><p>事务的隔离级别</p><ol><li><p>脏读：一个事务读到了另一个事务未提交的数据<br>  不可重复读：一个事务读到了另一个事务已经提交的update数据<br>  虚读/幻读：一个事务读到了另一个事务已经提交的insert数据</p><ol><li>隔离级别<br>read uncommitted(未提交读)    ：脏读，不可重复读，虚读都有可能发生</li></ol><p>read committed(已提交读)    ：避免脏读。但是不可重复读和虚读是有可能发生</p><p>repeatable-read(可重复读)    ：避免脏读和不可重复读，但是虚读有可能发生。</p><p>serializable(串行化)        ：避免脏读，不可重复读，虚读。(mysql默认隔离级别) </p><h2 id="对于hibernate的事务隔离级别设置"><a href="#对于hibernate的事务隔离级别设置" class="headerlink" title="对于hibernate的事务隔离级别设置"></a>对于hibernate的事务隔离级别设置</h2><p>它可取的值有 1 2 4 8<br>1代表的事务隔离级别为READ UNCOMMITTED<br>2代表的事务隔离级别为READ COMMITTED<br>4.代表的事务隔离级别为 REPEATABLE READ<br>8代表的事务隔离级别为 SERIALIZABLE<br>在hibernate.cfg.xml文件中配置<br><property name="hibernate.connection.isolation ">4</property></p><h1 id="hibernate优化"><a href="#hibernate优化" class="headerlink" title="hibernate优化"></a>hibernate优化</h1></li></ol></li></ol><blockquote><p>1.使用参数绑定<br>使用绑定参数的原因是让数据库一次解析SQL,对后续的重复请求可以使用用生成好的执行计划，这样做节省CPU时间和内存；避免SQL注入<br>2.尽量少使用NOT<br>如果where子句中包含not关键字，那么执行时该字段的索引失效。<br>3.尽量使用where来替换having<br>Having在检索出所有记录后才对结果集进行过滤，这个处理需要一定的开销，而where子句限制记录的数目，能减少这方面的开销<br>4.减少对表的查询<br>在含有子查询的HQL中,尽量减少对表的查询，降低开销<br>5.使用表的别名<br>当在HQL语句中连接多个表时，使用别名，提高程序阅读性，并把别名前缀与每个列上，这样一来，可以减少解析时间并减少列歧义引起的语法错误。<br>6.实体的更新与删除<br>    @Test<br>    public void test11() {<br>        Query query = session.createQuery(“update Order set money=100”);<br>        query.executeUpdate();<br>    }</p></blockquote><h2 id="一级缓存优化"><a href="#一级缓存优化" class="headerlink" title="一级缓存优化"></a>一级缓存优化</h2><p>一级缓存也叫做session缓存，在一个hibernate session有效，这级缓存的可干预性不强，大多于hibernate自动管理，但它提供清除缓存的方法，这在大批量增加(更新)操作是有效果的，例如，同时增加十万条记录，按常规进行，很可能会出现异常，这时可能需要手动清除一级缓存，session.evict以及session.clear.</p><h3 id="检索策略"><a href="#检索策略" class="headerlink" title="检索策略"></a>检索策略</h3><p>延迟加载 是hibernate为提高程序执行的效率而提供的一种机制，lazy延迟加载：什么时候使用什么时候再去查询</p><h1 id="类级别延迟"><a href="#类级别延迟" class="headerlink" title="类级别延迟"></a>类级别延迟</h1><p>使用延迟加载的方法查询某个类的时候是否采用的延迟称为是类级别的延迟。默认值是true。<br>Customer customer = session.load(Customer.class,1l);// 默认就会采用延迟加载，这种称为是类级别的延迟。</p><p>#关联级别的延迟 #<br>查询到某个对象以后，获得其关联的对象。查询其关联对象的时候是否采用的延迟。称为是关联级别的延迟。<br>Customer c = session.get(Customer.class,1l);<br>c.getOrders(); // 查询关联对象的时候，是否采用延迟加载</p><p><em>关联级别的延迟往往会与抓取策略一起使用，优化程序。</em><br><em>（关联级别的延迟在<set>或者是<many-to-one>标签上的配置是否延迟加载）</many-to-one></set></em></p><h4 id="抓取策略"><a href="#抓取策略" class="headerlink" title="抓取策略"></a>抓取策略</h4><p>抓取策略指的是查找到某个对象后，抓取其关联的对象的时候采用的策略。<br>抓取策略就是在关联对象的配置上（<set>和<many-to-one>）配置<strong>fetch</strong>属性。</many-to-one></set></p><p>在set上的fetch和lazy</p><p>fetch:抓取策略，控制SQL语句的发送的格式。</p><ul><li>select    :默认值。发送一条select语句查询关联对象。</li><li>join    :发送一条迫切左外连接查询关联对象。</li><li>subselect    :发送一条子查询查询关联对象。</li></ul><p>lazy:延迟加载，控制SQL语句的发送的时候。</p><ul><li>true    :默认值。采用延迟加载。</li><li>false    :不采用延迟加载。</li><li>extra    :及其懒惰。</li></ul><p>在many-to-one上的fetch和lazy<br>fetch:抓取策略，控制SQL语句的发送的格式。</p><pre><code>* select    ：默认值.发送一条select语句查询关联对象。* join    ：发送一条迫切左外连接查询关联对象。</code></pre><p>lazy：延迟加载，控制SQL的发送的时机。</p><pre><code>* proxy    ：默认值。是否采用延迟，需要由另一方类上的延迟加载来决定。* false    ：不采用延迟加载。* no-proxy：不用研究</code></pre><h1 id="抓取策略的注解配置"><a href="#抓取策略的注解配置" class="headerlink" title="抓取策略的注解配置"></a>抓取策略的注解配置</h1><p>一方对应的多方订单<br><em>private Set<order> orders = new HashSet<order>();上的fetch和lazy</order></order></em><br>fetch:抓取策略，控制SQL语句的发送的格式。</p><ul><li>@Fetch(FetchMode.SELECT):默认值,发送一条select语句查询关联对象。</li><li>@Fetch(FetchMode.JOIN):发送一条迫切左外连接查询关联对象。</li><li>@Fetch(FetchMode.SUBSELECT):发送一条子查询查询关联对象。</li></ul><p><em>lazy:延迟加载，控制SQL语句的发送的时候。</em></p><ul><li>@LazyCollection(LazyCollectionOption.TRUE):默认值。采用延迟加载。</li><li>@LazyCollection(LazyCollectionOption.FALSE):不采用延迟加载。</li><li>@LazyCollection(LazyCollectionOption.EXTRA)    :及其懒惰。</li></ul><p>多方对应的唯一客户<br>private  Customer c; 上的fetch和lazy</p><p>fetch:抓取策略，控制SQL语句的发送的格式。</p><pre><code>* @Fetch(FetchMode.SELECT):默认值,发送一条select语句查询关联对象* @Fetch(FetchMode.JOIN):发送一条迫切左外连接查询关联对象。（这时如果配置了lazy会失效，且方案是立即查询）</code></pre><p>lazy：延迟加载，控制SQL的发送的时机。</p><pre><code>* @LazyToOne(LazyToOneOption.FALSE)：默认值,不采用延迟加载* @LazyToOne(LazyToOneOption.PROXY)：</code></pre><p>是否采用延迟，需要由另一方类上的延迟加载来决定    </p><ul><li>@LazyToOne(LazyToOneOption.NO_PROXY)：不用研究</li></ul><h2 id="多于批量抓取出现n-1的问题"><a href="#多于批量抓取出现n-1的问题" class="headerlink" title="多于批量抓取出现n+1的问题"></a>多于批量抓取出现n+1的问题</h2><p>例子：对于这个查询如果@Fetch(FetchMode.SELECT)会发送1+n条sql语句，1查询Customer自己，n查询每个Customer对应Order</p><p>查询多个对象的关联对象时，可以采用批量抓取方式来对程序进行优化.<br>要想实现批量抓取：<br>可以在配置文件中 batch-size属性来设置<br>可以使用注解 @BatchSize(size=4)—–为了减少select语句数目，可以设置<set>元素的batch-size属性<br>可以采用批量抓取来解决N+1问题.</set></p><p><strong>注意</strong>：<br>无论是根据哪一方来查询别一方，在进行批量抓取时，都是在父方来设置<br>如果是要查询子信息，那么我们是在<set>上来设置 batch-size,如果是从子方来查询父方，也是在父方设置在<class>设置 batch-size；</class></set></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习目标:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;能够使用HQL语句完成多表操作
能够从概念、特点、隔离级别几个方面描述出对事务的理解
记忆HQL优化的方法并能对一级缓存进行优化
能够说出对hibernate中的抓取策略的理解，并能够配置各种抓取策略
&lt;/code&gt;&lt;/pre&gt;&lt;p
      
    
    </summary>
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/categories/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="hibernate优化" scheme="http://HackerFreedom.github.io/tags/hibernate%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java框架</title>
    <link href="http://HackerFreedom.github.io/2018/02/25/hibernate%E6%9F%A5%E8%AF%A2/"/>
    <id>http://HackerFreedom.github.io/2018/02/25/hibernate查询/</id>
    <published>2018-02-25T01:23:00.000Z</published>
    <updated>2018-02-25T14:16:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hibernate-框架"><a href="#hibernate-框架" class="headerlink" title="hibernate 框架"></a>hibernate 框架</h1><ul><li>session</li><li>hql查询</li><li>对象关系</li></ul><p>在hibernate核心配置文件中<br>create 创建表  会删除存在的表，有可能会丢失数据</p><blockquote><p> C:\ProgramData\Microsoft\Windows Defender</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>！<a href="/2018/02/25/hibernate查询/hibernate.png"></a>;</p><p><strong>查询语句的汇总</strong></p><pre><code>1.oid查询：（oid是对象标识符）Customer  c = session.get(Customer.class, 1);Customer  c = session.load(Customer.class, 1);2.hql查询Query query = session.createQuery(“from Customer”);from后面跟的是类名（domain中的类）List&lt;Customer&gt; list = query.list(); 分页：query.setFirstResult(0);query.setMaxResults(10);投影：Query query = session.createQuery(“select name,address from Customer”);List&lt;Object[]&gt; list = Query.list();投影封装：Query query = session.createQuery(“select  new Customer(name,address) from Customer”);//这里我们得到的是customer对象但是我们要，提供customer（含参） 构造方法</code></pre><p>   <em>list封装数据</em><br>     Query query = session<br>      .createQuery(“select new List(name,address) from Customer”);<br>   <em>map封装数据</em><br>     Query query = session<br>    .createQuery(“select new Map(name,address) from Customer”);</p><pre><code>条件:</code></pre><p><em>无名称的查询，？表示占位符</em><br>    Query query = session.createQuery(“from Customer where name=?”);<br>    query.setParameter(“0”, “波多”);<br><em>含名称的查询</em><br>    Query query = session.createQuery(“from Customer where name=:abc”);<br>    query.setParameter(“abc”, “波多”);<br>    3.sql查询 SQLQuery是Query的子.<br>    SQLQuery  sqlQuery = session.createSQLQuery(“select * from t_customer”);<br>    List<object[]> list = sqlQuery.list();<br>    //封装到Customer对象<br>    sqlQuery.addEntity(Customer.class);<br>    List<customer> list = Query.list();</customer></object[]></p><h1 id="criteria"><a href="#criteria" class="headerlink" title="criteria"></a>criteria</h1><p>Criteria接口与Query接口非常类似，允许创建并执行面向对象的标准化查询。值得注意的是Criteria接口也是轻量级的，它不能在Session之外使用。<br> 4.qbc<br>    Criteria qbc = session.createCriteria(Customer.class); //实体类.class得到的是一个这个类的对象<br>    List<customer> list  = qbc.list();<br>    qbc条件查询<br>    qbc.add(Restrictions.eq(“name”, “波多”));<br>    List<customer> list  = qbc.list();<br>    criteria.add(Restrictions.or(Restricitons.eq(),Restrictions.list()…..))<br>    我们使用Criteria可以更加面向对象去操作，它非常适合进行多条件组合查询。</customer></customer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hibernate-框架&quot;&gt;&lt;a href=&quot;#hibernate-框架&quot; class=&quot;headerlink&quot; title=&quot;hibernate 框架&quot;&gt;&lt;/a&gt;hibernate 框架&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;session&lt;/li&gt;
&lt;li&gt;hql查询&lt;/
      
    
    </summary>
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/categories/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="hibernate查询" scheme="http://HackerFreedom.github.io/tags/hibernate%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/02/24/%E5%A4%A9%E6%B0%94api/"/>
    <id>http://HackerFreedom.github.io/2018/02/24/天气api/</id>
    <published>2018-02-24T02:51:30.102Z</published>
    <updated>2018-02-24T02:51:30.113Z</updated>
    
    <content type="html"><![CDATA[<pre><code>//通过中国天气api调用    private String getWeatherInfo2(){            StringBuilder info = new StringBuilder();            try {                    DefaultHttpClient httpclient = new DefaultHttpClient();                    HttpGet httget = new HttpGet(&quot;http://m.weather.com.cn/data/101050101.html&quot;);                    ResponseHandler&lt;String&gt; responseHandler = new BasicResponseHandler();                    String responseBody = httpclient.execute(httget, responseHandler);                    System.out.println(responseBody);                    JsonParser jp = new JsonParser();                    JsonElement jse = jp.parse(responseBody);                    JsonObject jso = jse.getAsJsonObject().get(&quot;weatherinfo&quot;).getAsJsonObject();//                        String updTime = jso.get(&quot;fchh&quot;).getAsString();//                        if(updTime != null){//                                //温度//                                String j = jso.get(&quot;temp1&quot;).getAsString();//今天//                                String m = jso.get(&quot;temp2&quot;).getAsString();//明天//                                //天气情况//                                String j_weather = jso.get(&quot;weather1&quot;).getAsString();//今天//                                String m_weather = jso.get(&quot;weather2&quot;).getAsString();//明天//                                //风向风力//                                String j_wind = jso.get(&quot;wind1&quot;).getAsString();//今天//                                String m_wind = jso.get(&quot;wind2&quot;).getAsString();//明天//                                info.append(&quot;今天：&quot;).append(j).append(&quot; &quot;).append(j_weather).append(&quot; &quot;).append(j_wind).append(&quot;\n&quot;);//                                info.append(&quot;明天：&quot;).append(m).append(&quot; &quot;).append(m_weather).append(&quot; &quot;).append(m_wind).append(&quot;\n&quot;);//                        }                    String updTime = jso.get(&quot;fchh&quot;).getAsString();                    if(updTime != null){                            if(!updTime.trim().equals(&quot;18&quot;)){                                    //温度                                    String j = jso.get(&quot;temp1&quot;).getAsString();//今天                                    String m = jso.get(&quot;temp2&quot;).getAsString();//明天                                    //天气情况                                    String j_weather = jso.get(&quot;weather1&quot;).getAsString();//今天                                    String m_weather = jso.get(&quot;weather2&quot;).getAsString();//明天                                    //风向风力                                    String j_wind = jso.get(&quot;wind1&quot;).getAsString();//今天                                    String m_wind = jso.get(&quot;wind2&quot;).getAsString();//明天                                    info.append(&quot;今天：&quot;).append(j).append(&quot; &quot;).append(j_weather).append(&quot; &quot;).append(j_wind).append(&quot;\n&quot;);                                    info.append(&quot;明天：&quot;).append(m).append(&quot; &quot;).append(m_weather).append(&quot; &quot;).append(m_wind).append(&quot;\n&quot;);                            }else{                                    //18                                    //温度                                    String temp1 = jso.get(&quot;temp1&quot;).getAsString();//今天                                    String temp2 = jso.get(&quot;temp2&quot;).getAsString();//今天                                    String temp3 = jso.get(&quot;temp3&quot;).getAsString();//今天                                    String j = temp1.split(&quot;~&quot;)[1] + &quot;~&quot; +  temp2.split(&quot;~&quot;)[0];                                    String m = temp2.split(&quot;~&quot;)[1] + &quot;~&quot; + temp3.split(&quot;~&quot;)[0];//明天                                    //天气情况                                    String weather1 = jso.get(&quot;weather1&quot;).getAsString();                                    String weather2 = jso.get(&quot;weather2&quot;).getAsString();                                    String weather3 = jso.get(&quot;weather3&quot;).getAsString();                                    String j_weather = &quot;&quot;;                                    String j_weather_part1 = &quot;&quot;;                                    String j_weather_part2 = &quot;&quot;;                                    //判断是否有转                                    if(weather1.indexOf(&quot;转&quot;) &gt; 0){                                            //有                                            j_weather_part1 = weather1.split(&quot;转&quot;)[1];                                    }else{                                            j_weather_part1 = weather1;                                    }                                    if(weather2.indexOf(&quot;转&quot;) &gt; 0){                                            //有                                            j_weather_part2 = weather2.split(&quot;转&quot;)[0];                                    }else{                                            j_weather_part2 = weather2;                                    }                                    if(j_weather_part1.equalsIgnoreCase(j_weather_part2)){                                            j_weather = j_weather_part1;//今天                                    }else{                                            j_weather = j_weather_part1 + &quot;转&quot; + j_weather_part2;//今天                                    }                                    String m_weather = &quot;&quot;;                                    String m_weather_part1 = &quot;&quot;;                                    String m_weather_part2 = &quot;&quot;;                                    //判断是否有转                                    if(weather2.indexOf(&quot;转&quot;) &gt; 0){                                            //有                                            m_weather_part1 = weather2.split(&quot;转&quot;)[1];                                    }else{                                            m_weather_part1 = weather2;                                    }                                    if(weather3.indexOf(&quot;转&quot;) &gt; 0){                                            //有                                            m_weather_part2 = weather3.split(&quot;转&quot;)[0];                                    }else{                                            m_weather_part2 = weather3;                                    }                                    if(m_weather_part1.equalsIgnoreCase(m_weather_part2)){                                            m_weather = m_weather_part1;//今天                                    }else{                                            m_weather = m_weather_part1 + &quot;转&quot; + m_weather_part2;//明天                                    }                     //风向风力                                    String j_wind = jso.get(&quot;wind2&quot;).getAsString();//今天                                    String m_wind = jso.get(&quot;wind3&quot;).getAsString();//明天                                    info.append(&quot;今天：&quot;).append(j).append(&quot; &quot;).append(j_weather).append(&quot; &quot;).append(j_wind).append(&quot;\n&quot;);                                    info.append(&quot;明天：&quot;).append(m).append(&quot; &quot;).append(m_weather).append(&quot; &quot;).append(m_wind).append(&quot;\n&quot;);                            }                    }            } catch (Exception e) {            }            return info.toString();    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;//通过中国天气api调用
    private String getWeatherInfo2(){
            StringBuilder info = new StringBuilder();
            try {
     
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="http://HackerFreedom.github.io/2018/02/18/IO%E6%B5%81%E6%80%BB%E7%BB%93/"/>
    <id>http://HackerFreedom.github.io/2018/02/18/IO流总结/</id>
    <published>2018-02-18T06:28:00.000Z</published>
    <updated>2018-02-18T06:43:30.361Z</updated>
    
    <content type="html"><![CDATA[<p>**</p><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="InputStream字节输入流"><a href="#InputStream字节输入流" class="headerlink" title="InputStream字节输入流"></a>InputStream字节输入流</h2><p>FileInputStream标准的字节输入流<br><em>一次读取一个字节数组</em><br>     BufferedInputStream: 该类实现缓冲的输入流</p><h3 id="OutputStream对象输入流"><a href="#OutputStream对象输入流" class="headerlink" title="OutputStream对象输入流"></a>OutputStream对象输入流</h3><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;**&lt;/p&gt;
&lt;h1 id=&quot;字节流&quot;&gt;&lt;a href=&quot;#字节流&quot; class=&quot;headerlink&quot; title=&quot;字节流&quot;&gt;&lt;/a&gt;字节流&lt;/h1&gt;&lt;h2 id=&quot;InputStream字节输入流&quot;&gt;&lt;a href=&quot;#InputStream字节输入流&quot; class
      
    
    </summary>
    
      <category term="I/O流" scheme="http://HackerFreedom.github.io/categories/I-O%E6%B5%81/"/>
    
    
      <category term="I/O流总结" scheme="http://HackerFreedom.github.io/tags/I-O%E6%B5%81%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Struts2 用法</title>
    <link href="http://HackerFreedom.github.io/2018/02/08/struts2/"/>
    <id>http://HackerFreedom.github.io/2018/02/08/struts2/</id>
    <published>2018-02-08T14:13:00.000Z</published>
    <updated>2018-02-27T00:50:55.129Z</updated>
    
    <content type="html"><![CDATA[<p>不会用，直接用<br>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。它使用一系列的合法元素来定义文档结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用</p><ul><li>框架的内容</li></ul><h1 id="java开发中常用的框架"><a href="#java开发中常用的框架" class="headerlink" title="java开发中常用的框架"></a>java开发中常用的框架</h1><p>ssh<br>ssm</p><h1 id="struts2框架的介绍"><a href="#struts2框架的介绍" class="headerlink" title="struts2框架的介绍"></a>struts2框架的介绍</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不会用，直接用&lt;br&gt;DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。它使用一系列的合法元素来定义文档结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;框架的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;java开
      
    
    </summary>
    
      <category term="Struts2框架" scheme="http://HackerFreedom.github.io/categories/Struts2%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Struts2" scheme="http://HackerFreedom.github.io/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2的OGNL</title>
    <link href="http://HackerFreedom.github.io/2018/02/08/Struts2%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <id>http://HackerFreedom.github.io/2018/02/08/Struts2第二天/</id>
    <published>2018-02-08T14:13:00.000Z</published>
    <updated>2018-03-12T14:28:01.406Z</updated>
    
    <content type="html"><![CDATA[<p>课程目标：</p><pre><code>能够在action中熟练使用servlet api中的对象能够清楚的说出ognl的作用能够清晰的描述出valueStack的内部结构能够完成向valueStack中存放数据的操作能够完成从valueStack中获取数据的操作能够说出el表达式能够获取valuestack中的值原因能够说出interceptor的执行原理能够自定义完成登陆拦截器</code></pre><h1 id="Struts2中获取Servlet-API"><a href="#Struts2中获取Servlet-API" class="headerlink" title="Struts2中获取Servlet API"></a>Struts2中获取Servlet API</h1><p>简单的说，可以在action类中获取requent，response，session 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest request = ServletActionContext.getRequest();</span><br><span class="line">HttpServletResponse response = ServletActionContext.getResponse();</span><br><span class="line">ServletContext servletContext = ServletActionContext.getServletContext();</span><br></pre></td></tr></table></figure></p><h1 id="OGNL-表达式"><a href="#OGNL-表达式" class="headerlink" title="OGNL 表达式"></a>OGNL 表达式</h1><p><code>OGNL</code> 是<code>Object-Graph Navigation Language</code> (对象图导航语言） 的缩写，他是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类</p><ul><li>OGNL作用：<ol><li>支持对象的操作，调用对象的方法</li><li>支持静态成员访问</li><li>支持赋值操作与表达串联</li><li>访问OGNL上下文，访问ActionContext</li><li>操作集合对象。</li></ol></li></ul><p><strong> OGNL三要素： </strong></p><ul><li><strong>表达式  </strong> </li><li><strong>OgnlContext上下文</strong>  </li><li><strong>Root根</strong></li></ul><h2 id="ognal表达式介绍"><a href="#ognal表达式介绍" class="headerlink" title="ognal表达式介绍"></a>ognal表达式介绍</h2><p>在struts2框架中我们使用ognl表达式的作用是从valueStack中获取数据。</p><p>valueStack—-&gt;存放数据；ognl—-&gt;取数据，(类似于之前的request域存数据，el表达式取数据)</p><p>要想在jsp页面上使用ognl表达式，就需要结合struts2框架的标签<br><s:property value="”表达式”">来使用<br><img src="/2018/02/08/Struts2第二天/struts201.png" alt="">;<br>    <code>*引入struts2标签*</code><br>    <code>&lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot;%&gt;</code></s:property></p><p>   <code>使用ognl表达式获取数据: &lt;s:property value=&quot;username&quot;/&gt;</code></p><h1 id="valueStack值栈"><a href="#valueStack值栈" class="headerlink" title="valueStack值栈"></a>valueStack值栈</h1><p>valueStack的主要目的是为我将我们action中产生的数据携带到页面上，也就是说valueStack它就是一个存储数据的容器。</p><ol><li>valueStack基于ognl,作用是在struts2框架中来存储数据</li><li>浏览器发出请求<code>request</code>——&gt;创建<code>ValueStack对象-</code>——&gt;创建当前访问的<code>Action</code>对象</li></ol><h2 id="valuesStack内部结构的介绍"><a href="#valuesStack内部结构的介绍" class="headerlink" title="valuesStack内部结构的介绍"></a>valuesStack内部结构的介绍</h2><ol><li>valueStack主要有两部分组成:<br><code>CompoundRoot  root</code>:       就是一个<code>ArrayList</code><br><code>Map&lt;String,Object&gt; context</code>:  就是一个<code>Map</code></li><li>struts2框架向root存放的数据<br>浏览器发出请求request—–&gt;创建当前访问的Action对象—–&gt;将Action对象push到root</li><li>struts2框架向context存放的数据<br>浏览器发出请求request——&gt;创建ValueStack对象之后，向context存放存储了一些引用，这个引用主要是关于web开发中相关信息，如<br><code>parameters</code> :请求参数<br><code>request</code>:请求对象中所有属性<br><code>session</code>:会话对象中所有属性<br><code>application:ServletContex</code>t对象中的所有属性</li></ol><blockquote><p>在struts2框架中我们通过ognl表达式来获取valueStack中数据，<code>没有使用#就会从CompoundRoot中获取数据</code>，如果使用<code>#来获取，这时就会从context中来获取</code>.</p></blockquote><h2 id="valueStack获取"><a href="#valueStack获取" class="headerlink" title="valueStack获取"></a>valueStack获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ValueStack valueStack = ActionContext.getContext().getValueStack();</span><br></pre></td></tr></table></figure><h2 id="valueStack-存储数据-重点）"><a href="#valueStack-存储数据-重点）" class="headerlink" title="valueStack 存储数据 (重点）"></a>valueStack 存储数据 (重点）</h2><p><strong>注意： 我们使用valueStack来存储数据时，主要向root存储</strong></p><ol><li><code>手动</code>向valueStack存储数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String execute （）｛</span><br><span class="line">ValueStack stack = ActionContext.getContext().getValueStack();</span><br><span class="line">stack.set(&quot;name&quot;, &quot;itheima&quot;);</span><br><span class="line">stack.push(&quot;itcast&quot;);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></li></ol><p><strong> <code>valueStackpush</code>方法,  直接将对象压入到root </strong></p><p><strong> <code>valueStackset(“key”, “value”</code>)方法,  创建一个<code>Map压入到root</code>，再把数据以健值对<k,v>的形式存放到这个map中</k,v></strong> </p><hr><ol><li><p>struts2框架<code>自动</code>向valueStack中存储数据</p><ol><li><p>在框架源码的<code>DefaultActionInvocation</code>类的init方法内:</p><p>首先创建了当前访问的Action对象，然后通过stack.push(action)将当前访问的Action对象存放到valueStack的root中，也就是每次请求访问action的时候，都会构造出<br>action对象并将这个action对象存储到valueStack的root(ArrayList)中。</p></li><li><p>在浏览器访问action的时候<code>ModelDrivernInterceptor</code>这个拦截器会执行如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(action instanceof ModelDrivern) &#123;</span><br><span class="line">    modelDriven model= (ModelDriven)  action;</span><br><span class="line">Object model = modelDriven.getModel();</span><br><span class="line">if(model !=null) &#123;</span><br><span class="line">stack.push(model);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><em>以上代码会判断当前访问的Action对象有没有实现ModelDriven这个接口，如果实现了这个接口就通过action对象已经实现的通过getModel方法获取模型对象存放到root(ArrayList)中</em></p><hr><h2 id="valueStack中数据获取-重点"><a href="#valueStack中数据获取-重点" class="headerlink" title="valueStack中数据获取(重点)"></a>valueStack中数据获取(重点)</h2><ol><li><p>获取手动存放的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String execute()  &#123;</span><br><span class="line">ValueStack stack = ActionContext.getContext().getValueStack();</span><br><span class="line">stack.set(&quot;name&quot;, &quot;itheima&quot;);</span><br><span class="line">stack.push(&quot;itcast&quot;);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在jsp页面中获取以上代码手动存放的数据</span><br><span class="line">&lt;s:property value=&quot;name&quot;/&gt;</span><br><span class="line">&lt;s:property value=&quot;[0]&quot;/&gt;可以查看整个root结构数据</span><br><span class="line">&lt;s:property value=&quot;[0].top&quot;/&gt;&lt;br/&gt;获取root顶部的对象</span><br><span class="line">&lt;s: debug/&gt; 视图中可以 查看action的属性</span><br></pre></td></tr></table></figure></li><li><p>获取自动存放的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ValueStackAction1 &#123;</span><br><span class="line">private String username = &quot;fox&quot;;</span><br><span class="line">public String getUsername() &#123;</span><br><span class="line">return username;</span><br><span class="line">&#125;</span><br><span class="line">public String getPwd() &#123;</span><br><span class="line">return &quot;123&quot;;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">在页面中获取以上自动存放的数据，为什么?</span><br><span class="line">&lt;s:property value=&quot;username&quot; /&gt;</span><br><span class="line">&lt;s:property value=&quot;pwd&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程目标：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;能够在action中熟练使用servlet api中的对象
能够清楚的说出ognl的作用
能够清晰的描述出valueStack的内部结构
能够完成向valueStack中存放数据的操作
能够完成从valueStack中获取数据的操作
      
    
    </summary>
    
      <category term="Struts2框架" scheme="http://HackerFreedom.github.io/categories/Struts2%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Struts2" scheme="http://HackerFreedom.github.io/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2 JSON</title>
    <link href="http://HackerFreedom.github.io/2018/02/08/Struts2%E7%9A%84JSON%E6%95%B0%E6%8D%AE/"/>
    <id>http://HackerFreedom.github.io/2018/02/08/Struts2的JSON数据/</id>
    <published>2018-02-08T14:13:00.000Z</published>
    <updated>2018-03-13T02:08:06.415Z</updated>
    
    <content type="html"><![CDATA[<p>课程目标<br>    能够使用struts2完成文件的上传操作<br>    能够熟练说出json数据格式的两种结构<br>    能够使用fastjson完成对象转json的操作<br>    能够使用jackson完成对象转json的操作<br>    能够使用response完成json数据响应<br>    能够使用struts2提供的json插件完成ajax开发<br>    记忆struts2框架注解开发中使用的注解，并编码完成登陆、商品展示和登陆拦截</p><ol><li>不要相信任何承诺 （邮件发给我，要有证据）</li><li>尽量争取时间</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程目标&lt;br&gt;    能够使用struts2完成文件的上传操作&lt;br&gt;    能够熟练说出json数据格式的两种结构&lt;br&gt;    能够使用fastjson完成对象转json的操作&lt;br&gt;    能够使用jackson完成对象转json的操作&lt;br&gt;    能够使用res
      
    
    </summary>
    
      <category term="Struts2的JSON数据" scheme="http://HackerFreedom.github.io/categories/Struts2%E7%9A%84JSON%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Struts2" scheme="http://HackerFreedom.github.io/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="http://HackerFreedom.github.io/2018/02/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://HackerFreedom.github.io/2018/02/06/面向对象的总结/</id>
    <published>2018-02-06T14:07:00.000Z</published>
    <updated>2018-02-07T10:20:30.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象的思想-（面试重点）"><a href="#面向对象的思想-（面试重点）" class="headerlink" title="面向对象的思想 （面试重点）"></a>面向对象的思想 （面试重点）</h1><ol><li>更符合我们的思维习惯</li><li>把复杂的问题简单化</li><li>把我们从执行者变为指挥者</li></ol><p><strong>面向对象的三大特性</strong></p><h1 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h1><pre><code>1. 是用private修饰方法封装起来的类    1. 作用：提高代码的复用性，和安全性</code></pre><ul><li><p><em>this关键字</em><br>代表对象，就是所在函数所指的对象引用</p><blockquote><p>一般用于构造函数的引用<br>调用格式 ： this. ()<br>this对象后面跟上 .调用是成员属性或者是方法<br>this（） 调用的是本类中对应参数的构造函数<br>注意：用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。否则编译失败。</p></blockquote></li><li><p><em>static关键词</em></p><ul><li>作用：<ol><li>想要实现对象中的共性数据的共享，可以将数据进行静态修饰</li><li>被static的成员方法，可以直接被类名直接调用，（类名. 静态方法）</li><li>静态随着类的加载而加载，且优先于对象的存在</li></ol></li><li>劣势：<ol><li>静态方法只能访问静态成员，不可以访问非静态成员</li><li>静态方法中不能使用this，super关键字（this代表是对象，而在静态时，有可能就没有对象）<br><strong>成员变量和静态变量区别</strong></li></ol></li></ul><ol><li>位置不同<ol><li>成员变量存在堆内存中，而静态变量存在于方法区中</li></ol></li><li>生命周期不同<ol><li>静态变量随着类的加载而存在，随着类的消失而消失</li><li>成员变量随着对象的创建而存在，随着对象被销毁而销毁</li></ol></li></ol></li></ul><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h1><pre><code>1. 子类可以访问父类的非私有成员变量和方法- 作用：        1.提高代码的复用性，    2. 使类和类之间产生了关系，是产生多态的一个前提</code></pre><ul><li><strong>继承特点</strong></li></ul><ol><li>单继承： 一个类只能有一个父类</li><li>多重继承： 一个父类可以被多个子类继承 A继承B  B继承C  C继承D。</li></ol><p><em>super关键词</em><br> 用来调用父类中的属性值</p><ul><li>为什么在子类的构造函数的第一行总是会加入super（）？<br>  在子类继承父类，会继承到父类的数据，所以必须要父类先要有数据的初始化，<br>  所以子类在进行对象初始化的时候，要先调用父类的构造函数，这就是子类的实例化过程</li><li><p><strong>注意</strong><br>super在每一个子类的构造方法中是默认在第一行的。<br>且和this关键字，两者只能出现一个。<em>一山容不下二虎的!!</em></p><h1 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h1><ol><li>函数就有多态性， 就是某一事物不同的具体表现</li></ol><ul><li>作用<ol><li>提高了程序的扩展性</li></ol></li><li>前提<ol><li>必须要有实现关系或者继承关系</li><li>必须要有方法的重写</li></ol></li></ul></li><li><p>方法的重写<br>  1、方法名、参数、返回值相同。</p></li></ul><p>　　 2、子类方法不能缩小父类方法的访问权限。(public&gt;protected&gt;default&gt;private）</p><p>　　 3、子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</p><p>　　 4、存在于父类和子类之间。</p><p>　　 5、方法被定义为final不能被重写。</p><p><em>final 特点</em></p><ol><li>这个关键词是一个修饰符，可以修饰类，方法，变量</li><li>被final修饰的类是一个最終类，不可以被继承</li><li>被final修饰的方法是一个最终的方法，不可以被重写</li><li><p>被final修饰的变量是一个常量，只能赋值一次<br><strong> 命名的规范：常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。</strong></p><ul><li>方法的重载<br>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。<br>重载Overloading是一个类中多态性的一种表现。<br> 1、参数类型、个数、顺序至少有一个不相同。 </li></ul><p>　　2、不能重载只有返回值不同的方法名。</p><p>　　3、存在于父类和子类、同类中。</p><ul><li>规则:</li></ul><ol><li>必须具有不同的参数列表；</li></ol></li></ol><ol><li><p>可以有不同的返回类型，只要参数列表不同就可以了；</p></li><li><p>可以有不同的访问修饰符；</p></li><li><p>可以抛出不同的异常；</p></li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol><li>定义： <ol><li>被abstract所修饰的类，</li></ol></li><li>特点： <ol><li>抽象方法只能定义在抽象类中， 抽象类也可以有非抽象的方法</li><li>抽象类不可以被创建对象（实例化）</li><li>只能通过子类继承或者实现的方法，才能使子类实例化</li></ol></li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol><li>定义：<br> 比抽象类还抽象的类，用关键词interface修饰</li><li>接口的特点：<ol><li>提高代码的可扩展性</li><li>规范并且约束了子类的行为（功能） </li></ol></li><li>接口中的成员的特点：<ol><li>成员变量：<br>接口中没有成员变量,只能由自定义常量; –&gt;因为接口中的方法没有方法体,所以没有地方给变量赋值;<pre><code>自定义常量的定义格式:</code></pre>public static final 数据类型 常量名 = 初始化值;</li><li>成员方法：<br>默认被 public abstract 所修饰;<pre><code>接口中的成员方法全部都是抽象方法;</code></pre></li><li>构造方法：<br>接口中没有构造方法,所以接口不能创建对象;</li></ol></li><li><p>接口和抽象类的区别:</p><pre><code>1.区别1:定义不同    接口:比抽象类还抽象的类;    抽象类:被abstract所修饰的类;2.区别2:构造方法        接口:没有构造方法,不能创建对象    抽象类:有构造方法,不能创建对象,但是可以给成员变量初始化;3.区别3:成员变量        接口:接口中没有成员变量只有自定义常量;    抽象类:可以有成员变量也可以有自定义常量;4.区别4:成员方法        接口:接口中的成员方法全部都是抽象方法;默认被 public 和 abstract  所修饰;    抽象类:可以有抽象方法也可以有非抽象方法;5.区别5:和类之间的关系:    接口:接口和类之间的关系是实现关系: implements    抽象类:抽象类和类之间的关系是继承关系: extends</code></pre><p><strong>总结各个类于接口的关系</strong><br>接口和类之间的关系:</p><pre><code>实现关系: implements格式:  public class 类名 implements 接口名1,接口名2....{            //实现接口中的抽象方法        }特点: 多实现,多层实现</code></pre><p> 接口和接口之间的关系:</p><pre><code>继承关系: extends格式:public interface 接口名 extends 接口名1,接口名2...{        }特点:多继承,多层继承</code></pre><p> 类和类之间的关系:</p><pre><code>继承关系: extends格式:    public class 类名 extends 类名1{    }特点:单一继承,多层继承;</code></pre></li></ol><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ol><li><p>局部代码块</p><ol><li>位置：<ol><li>方法内，for循环的大括号内，方法声明上</li></ol></li><li>作用： <ol><li>用于限定变量和对象的生命周期和作用域</li></ol></li></ol></li><li><p>构造代码块</p><ol><li>位置：<ol><li>成员位置-类中方法外</li><li>{<pre><code>//在类中方法外的代码块是构造代码块;</code></pre> }</li></ol></li><li>作用：<ol><li>抽取构造方法的共性，在每次创建对象前执行一次</li><li>执行次数:每创建一次对象就执行一次构造代码块;<br> 执行顺序:因为是对象产生的预加载;<pre><code>先执行构造代码块再执行构造方法;</code></pre></li></ol></li></ol></li><li><p>静态代码块</p><ol><li>位置：<ol><li>成员位置，类中方法外 且被static所修饰的</li></ol></li><li>作用：<ol><li>类的预加载，随着类的加载而加载，且执行一次<br>static{<pre><code>//在类中方法外并且被static修饰的代码块是静态代码块</code></pre> }<br>执行顺序:<br> 静态代码块 –&gt; 构造代码块 –&gt; 构造方法</li></ol></li></ol></li><li><p>同步代码块（多线程）<br> 同步代码块的格式：<br> synchronized(同步对象){<br> 需要同步的代码；<br> }s</p></li></ol><p>作用:<br>        维持多个线程在执行任务时的秩序,当一个线程没有完成任务的时候,另一个线程不能进入同步代码块;<br>    线程锁:<br>        这个锁对象可以是任意类型的对象,但是这个锁对象必须被所有的线程对象所共享;–&gt;必须在成员位置;<br>        一般情况下我们会在锁对象的位置上写一个this;</p><p>同步方法:被synchronized所修饰的方法是同步方法;<br>    同步方法也是有锁对象的;<br>    非静态的同步方法的锁对象就是this;<br>    静态的同步方法的锁对象是当前类的字节码对象;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象的思想-（面试重点）&quot;&gt;&lt;a href=&quot;#面向对象的思想-（面试重点）&quot; class=&quot;headerlink&quot; title=&quot;面向对象的思想 （面试重点）&quot;&gt;&lt;/a&gt;面向对象的思想 （面试重点）&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;更符合我们的思维习惯&lt;/li&gt;

      
    
    </summary>
    
      <category term="面向对象" scheme="http://HackerFreedom.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="面向对象的总结" scheme="http://HackerFreedom.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>oracle第四天</title>
    <link href="http://HackerFreedom.github.io/2018/02/06/oracle%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <id>http://HackerFreedom.github.io/2018/02/06/oracle第四天/</id>
    <published>2018-02-06T06:37:00.000Z</published>
    <updated>2018-02-06T13:03:08.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PL-SQL"><a href="#PL-SQL" class="headerlink" title="PL/SQL"></a>PL/SQL</h1><ul><li>什么是PL/sql<ul><li>pl/sql是oracle对sql语言的过程化扩展，指在sql命令语言中增加了过程处理语句。</li></ul></li></ul><ol><li><p>基本语法结构<br>  [declare<br> –声明变量<br> ]<br> begin<br> –代码逻辑<br> [exception<br> –异常处理<br> ]<br> end;</p><ol><li>变量<ol><li>声明变量的语法： 变量名 类型 （长度）；</li><li>变量赋值的语法： 变量名： =变量值；</li></ol><ul><li>案例需求：<br>声明变量水费单价、水费字数、吨数、金额。<br>对水费单价、字数、进行赋值 。吨数根据水费字数换算，规则为水费字数除以<br>1000，并且四舍五入，保留两位小数。计算金额，金额=单价*吨数。<br>输出单价 、数量和金额。</li></ul></li></ol><ul><li>变量的用法–<br>declare<br>  v_price number(10,2);–水费单价<br>  v_usenum number; –水费字数<br>  v_usenum2 number(10,2);–吨数<br>  v_money number(10,2);–金额<br>begin<br>  v_price:=2.45;–水费单价<br>  v_usenum:=8012;–字数<br>–字数换算为吨数<br>v_usenum2:= round( v_usenum/1000,2);<br>–计算金额<br>v_money:=round(v_price*v_usenum2,2);<br>dbms_output.put_line(‘单价：’||v_price||’吨<br>数:’||v_usenum2||’金额：’||v_money);<br>end;</li></ul></li><li>属性类型<ol><li>%TYPE引用型<br>作用引用某 表某列的字段类型。</li><li>%ROWTYPE 记录型<br> 作用 ：标识某个表的行记录类型</li></ol></li><li>异常<br>在运行程序时出现的错误叫做异常<br>发生异常后，语句将停止执行，控制权转移到 PL/SQL 块的异常处理部分<br>异常有两中类型：<br> 预定义异常 - 当 PL/SQL 程序违反 Oracle 规则或超越系统限制时隐式引发<br> 用户定义异常 - 用户可以在 PL/SQL 块的声明部分定义异常，自定义的<br> 异常通过 RAISE 语句显式引发</li><li>条件判断<ol><li>基础语法<br> if 条件 then<br> 业务逻辑<br> end if;</li></ol></li><li><p>循环</p><ol><li>无条件循环<br> 语法结构：<pre><code>loop    --循环语句end loop；</code></pre></li></ol><ul><li><p>eg 输出从1开始的100个数<br>  declare</p><p>  v_num number:=1;<br>  begin<br>  loop<br>  dbms_output.put_line(v_num);<br>  v_num:=v_num+1;<br>  exit when v_num&gt;100;<br>  end loop;<br>  end ;</p></li></ul><ol><li><p>条件循环<br> 语法结构：</p><pre><code>while 条件    loop    end loop；</code></pre><ul><li>eg 输出从1开始的100个数<br>declare<br>v_num number:=1;<br>begin<br>while v_num&lt;=100<br>loop<br>dbms_output.put_line(v_num);<br>v_num:=v_num+1;<br>end loop;<br>end ;</li></ul></li><li><p>for循环<br> 语法结构：</p><pre><code>for 变量 in 起始值。。终止值loopend loop；</code></pre><ul><li>eg 输出从1开始的100个数<br>declare<br>v_num number:=1;<br>begin<br>for v_num in 1..100<br>loop<br>dbms_output.put_line(v_num);<br>end loop;<br>end;</li></ul></li></ol></li><li><p>游标<br>游标是系统为用户开设的一个数据缓冲区,存放 SQL 语句的执行结果。 我们<br>可以把游标理解为 PL/SQL 中的结果集。</p><ol><li><p>语法构造：<br>cursor 游标名称 is sql语句</p><p>open 游标名称<br>loop<br>fetch 游标名称 into 变量<br>exit when 游标名称%notfound<br>end loop;<br>close 游标名称</p><ul><li>eg 需求：打印业主类型为 1 的价格表<br>declare<pre><code>v_pricetable T_PRICETABLE%rowtype;--价格行对象cursor cur_pricetable is select * from T_PRICETABLE whereownertypeid=1;--定义游标</code></pre>begin<pre><code>    open cur_pricetable;--打开游标loop    fetch cur_pricetable into v_pricetable;--提取游标到变量    exit when cur_pricetable%notfound;--当游标到最后一行下面退    出循环    dbms_output.put_line( &apos;价格:&apos;    ||v_pricetable.price ||&apos;吨位：    &apos;||v_pricetable.minnum||&apos;-&apos;||v_pricetable.maxnum );end loop;    close cur_pricetable;--关闭游标end ;        </code></pre></li></ul><ol><li>带参数的游标<br>我们的查询语句的条件值有可能是在运行时才能决定的，比如性业主类型，<br>declare<br>   v_pricetable T_PRICETABLE%rowtype;–价格行对象<br>   cursor cur_pricetable is select * from T_PRICETABLE where<br>   ownertypeid=1;–定义游标<br>begin<pre><code>open cur_pricetable（2）;--打开游标</code></pre>   loop<pre><code>fetch cur_pricetable into v_pricetable;--提取游标到变量exit when cur_pricetable%notfound;--当游标到最后一行下面退出循环dbms_output.put_line( &apos;价格:&apos;||v_pricetable.price ||&apos;吨位：&apos;||v_pricetable.minnum||&apos;-&apos;||v_pricetable.maxnum );</code></pre>   end loop;<pre><code>close cur_pricetable;--关闭游标</code></pre>   end ;</li><li>for循环提取游标值<br>我们每次提前游标，需要打开游标，关闭游标 循环游标 提取游标 控制循环，等等，很麻烦。所以用简便的做法<br>declare<br>cursor cur_pricetable(v_ownertypeid number) is select *<br>from T_PRICETABLE where ownertypeid=v_ownertypeid;–定义游<br>标<br>begin<br>for v_pricetable in cur_pricetable(3)<br>loop<br>dbms_output.put_line(‘价格:’||v_pricetable.price ||’吨<br>位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum );<br>end loop;<br>end ;<h2 id="存储函数-（oracle和mysql都有）"><a href="#存储函数-（oracle和mysql都有）" class="headerlink" title="存储函数 ##（oracle和mysql都有）"></a>存储函数 ##（oracle和mysql都有）</h2>存储函数又成为自定位函数，可以接受一个或者多个参数，返回一个结果。</li></ol></li></ol></li><li><p>存储函数语法结构</p><ol><li>创建或修改存储过程的语法：<br> CREATE [ OR REPLACE ] FUNCTION 函数名称<br> （参数名称 参数类型, 参数名称 参数类型, …）<pre><code>RETURN 结果变量数据类型</code></pre> IS<pre><code>变量声明部分;</code></pre> BEGIN<pre><code>逻辑部分;</code></pre> RETURN 结果变量;<pre><code>[EXCEPTION异常处理部分]</code></pre> END;<ul><li>eg 需求： 创建存储函数，根据地址 ID 查询地址名称<br>  create function fn_getaddress(v_id number)<pre><code>return varchar2</code></pre>  is<pre><code>v_name varchar2(30);</code></pre>  begin<pre><code>select name into v_name from t_address where id=v_id;return v_name;</code></pre>  end;<br>select fn_getaddress(3) from dual</li></ul></li></ol></li><li><p>存储过程<br>存储过程是被命名的pl/sql块，存储于数据库中，是数据库对象的一种。<br>存储过程与存储函数都可以封装一定的业务逻辑并返回结果，存在区别如<br>下：<br>1、 存储函数中有返回值，且必须返回；而存储过程没有返回值，可以通过<br>传出参数返回多个值。<br>2、 存储函数可以在 select 语句中直接使用，而存储过程不能。过程多数是<br>被应用程序所调用。<br>3、 存储函数一般都是封装一个查询结果，而存储过程一般都封装一段事务<br>代码。<br>-存储过程语法结构</p><ol><li><p>创建和修改存储过程的语法<br> CREATE [ OR REPLACE ] PROCEDURE 存储过程名称</p><pre><code>（参数名 类型, 参数名 类型, 参数名 类型）</code></pre><p> IS|AS</p><pre><code>变量声明部分;</code></pre><p> BEGIN</p><pre><code>逻辑部分[EXCEPTION异常处理部分]</code></pre><p> END;<br>参数只指定类型，不指定长度<br>过程参数的三种模式：<br> IN 传入参数（默认）<br> OUT 传出参数 ，主要用于返回程序运行结果<br> IN OUT 传入传出参数</p></li></ol></li></ol><ul><li><p>案例</p><ol><li>需求： 创建存储函数，根据地址 ID 查询地址名称。</li><li>创建不带传出参数的存储过程：添加业主信息</li></ol><ul><li>增加业主信息序列<br> create sequence seq_owners start with 11;</li><li>增加业主信息存储过程<br>create or replace procedure pro_owners_add<pre><code>(v_name varchar2,v_addressid number,v_housenumber varchar2,v_watermeter varchar2,v_type number)</code></pre>is<br>begin<br>insert into T_OWNERS<pre><code>values( seq_owners.nextval,v_name,v_addressid,v_housenumber,v_watermeter,sysdate,v_type );</code></pre>commit;<br>end;</li></ul></li></ul><p>pl/sql中调用存储过程<br>    call pro_owners_add(‘赵伟’,1,’999-3’,’132-7’,1);</p><p>JDBC调用存储过程</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><ol><li>什么是触发器<br>数据库触发器是一个于表相关联的，存储的pl/sql程序。每当一个特定的数据操作语句<br>（insert ，update，delete ）在指定的表发出时，Oracle自动的执行触发器中定义<br>的语句序列。</li><li><p>触发器</p><ol><li>数据确认</li><li>数据的备份</li><li>实施复杂的安全性检查</li></ol></li><li><p>触发器分类</p><ol><li>前置触发器</li><li>后置触发器</li></ol></li><li>创建触发器的语法<br> CREATE [or REPLACE] TRIGGER 触发器名<pre><code>BEFORE | AFTER[DELETE ][[or] INSERT] [[or]UPDATE [OF 列名]]</code></pre> ON 表名begin<pre><code>PLSQL [FOR EACH ROW ][WHEN(条件) ]</code></pre> declare<br> ……<pre><code>块</code></pre> End ；    </li></ol><p>**<br>    create function fn_getaddress(v_id number)<br>    return varchar2<br>    is<br>    v_name varchar2(30);<br>    begin<br>    select name into v_name from t_address where id=v_id;<br>    return v_name;<br>    end;</p><pre><code>2. 需求：查询业主 ID，业主名称，业主地址，业主地址使用刚才我们创建的函数来实现select id 编号,name 业主名称,fn_getaddress(addressid) 地址from t_owners</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PL-SQL&quot;&gt;&lt;a href=&quot;#PL-SQL&quot; class=&quot;headerlink&quot; title=&quot;PL/SQL&quot;&gt;&lt;/a&gt;PL/SQL&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是PL/sql&lt;ul&gt;
&lt;li&gt;pl/sql是oracle对sql语言的过程化扩展，指在sq
      
    
    </summary>
    
      <category term="Oracle的基础知识" scheme="http://HackerFreedom.github.io/categories/Oracle%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="oracle基础知识" scheme="http://HackerFreedom.github.io/tags/oracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>oracle第三天</title>
    <link href="http://HackerFreedom.github.io/2018/02/02/oracle%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <id>http://HackerFreedom.github.io/2018/02/02/oracle第三天/</id>
    <published>2018-02-02T07:34:00.000Z</published>
    <updated>2018-02-05T13:27:07.560Z</updated>
    
    <content type="html"><![CDATA[<p>记录的结果是单行的，就是单行查询</p><p>#什么是视图  #<br> 视图是一种数据库对象，是从一个或者多个表达式或视图中导出的虚表，视图对应的数据并不真正地存储视图中。</p><ul><li><p>使用视图的优点：</p><ol><li>简化数据操作: 视图可以简化用户处理数据的方式。</li><li>着重于特定数据： 不必要的数据或敏感数据可以不出现在视图中</li><li>可以对于不同的用户进行限定访问。</li></ol></li><li><p>创建或修改视图语法<br>  create 【OR REPLACE】 [FORCE] VIEW view_name<br>  as subquery<br>  [wtth check option]<br>  [wtth reao only]</p><p>  OR REPLACE ：若所创建的试图已经存在，ORACLE 自动重建该视图；<br>  FORCE ：不管基表是否存在 ORACLE 都会自动创建该视图；<br>  subquery ：一条完整的 SELECT 语句，可以在该语句中定义别名；<br>  WITH CHECK OPTION ：插入或修改的数据行必须满足视图定义的约束；<br>  WITH READ ONLY ：该视图上不能进行任何 DML 操作。</p></li><li><p>删除视图语法<br>  DROP VIEW view_name</p></li><li><p>简单视图的创建和使用<br>只是单纯的单表查询，并没有聚合函数</p></li><li><p>带约束的视图<br>要注意我们只能修改带有除主键相关的数，因为修改不了。<br>会报错： ！<a href="/2018/02/02/oracle第三天/oracle01.png"></a>;</p></li><li><p>只读视图的创建于使用<br>创建语句时指定wtth read only 选项，如果如果要修改其中的语句，就会报错<br>！<a href="/2018/02/02/oracle第三天/oracle02.png"></a>;</p></li><li><p>创建带错误的视图<br>就是在不存在的表中给出提示</p></li></ul><ul><li>复杂的视图的创建和使用<br>所有复杂的视图，有聚合函数或者多表关联查询<br>！<a href="/2018/02/02/oracle第三天/oracle03.png"></a>;<br> <em>这里会遇到一个键保留列 的概念</em><br>  意思是说我们在视图中，该表中的主键会显示出来，而且是唯一非空的，也就是表的键值在一个连接着视图中也是键值，<br>  那么就称这个表为键保留表。<br>  所以非键保留表是不能更新的；</li></ul><p><em>主键的介绍</em><br>  关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键。<br>    主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。</p><pre><code>外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</code></pre><h2 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h2><ul><li>什么是物化视图<br>视图就是一个虚拟的表，基于它创建时指定的查询语句返回的结果集。（就是把一个每次访问都执行这个查询，封装起来，也叫实体化视图）</li></ul><ul><li><p><strong>创建物化视图 语法</strong></p><p>  CREATE meterialized VIEW view_name</p><p>  [BUILD IMMEDIATE | BUILD DEFERRED ]<br>  REFRESH [FAST|COMPLETE|FORCE]<br>  [<br>  ON [COMMIT |DEMAND ] | START WITH (start_time) NEXT<br>  (next_time)<br>  ]<br>  AS<br>  subquery</p><p>  BUILD IMMEDIATE 是在创建物化视图的时候就生成数据<br>  BUILD DEFERRED 则在创建时不生成数据，以后根据需要再生成数据。<br>  默认为 build immediate。<br>  刷新（refresh）：指当基表发生了 DML 操作后，物化视图何时采用哪种<br>  方式和基表进行同步。<br>  REFRESH 后跟着指定的刷新方法有三种： FAST、 COMPLETE、 FORCE。 FAST<br>  刷新采用增量刷新，只刷新自上次刷新以后进行的修改。<br>   COMPLETE 刷新对整个物化视图进行完全的刷新。<br>  如果选择 FORCE 方式，则 Oracle 在刷新时会去判断是否可以进行快速刷新，<br>  如果可以则采用 FAST 方式，否则采用 COMPLETE的方式。 FORCE 是默认的方式。</p><p>  刷新的模式有两种：ON DEMAND 和 ON COMMIT。<br>   ON DEMAND 指需要    手动刷新物化视图（默认）</p><pre><code>ON COMMIT 指在基表发生 COMMIT 操作时自动刷新。</code></pre></li></ul><ul><li><p>案例</p><ol><li><ol><li>创建手动刷新的物化视图<br>create materialized view mv_address<br>as<br>select ad.id ,ad.name adname,ar.name ar_name<br>form t_address ad  , t_area ar<br>where ad.areaid=ar.id</li></ol></li><li><ol><li>插入数据<br>insert into t_address values(8,’’,1,1);</li></ol></li><li><ol><li>要手动刷新物化视图，才能提交到数据<br>begin<br>  dbms_mview.refresh(‘mv_address’,’C’);<br>end;</li></ol></li></ol></li></ul><pre><code>    或者在命名行cmd中刷新物化视图    exec dbms_mview.refresh(&apos;mv_address&apos;,&apos;C&apos;)2. 1. 创建自动刷新的物化视图create materialized view mv_address refreshon commitas select ad.id ,ad.name adname,ar.name ar_nameform t_address ad  , t_area arwhere ad.areaid=ar.id创建此物化视图后，当 T_ADDRESS 表(基表）发生变化时，MV_ADDRESS2 自动跟着改变。 3. 1. 创建不生成数据的物化的视图create materialized view mv_address2 build deferredrefreshon commitas select ad.id ,ad.name adname,ar.name ar_nameform t_address ad  , t_area arwhere ad.areaid=ar.id3. 2. 查询结果为空3. 3. 执行下列语句后就生成了语句，由于创建是自动提交的刷新    begin         dbms_mview.refresh(&apos;mv_address2&apos;,&apos;C&apos;);    end 4. 1. 创建增量刷新的物化视图 4. 2. 如果要创建增量刷新的物化视图，必须首先要创建物化视图的日志     create materialized view log on t_address with rowid；    create materialized view log on t_area with rowid创建的物化视图日志名称为MLOG$_表名称    4. 3. 创建物化视图</code></pre><p><strong>注意创建增量的刷新的物化视图</strong></p><pre><code>1. 创建物化视图前提是要先创建物化视图的日志2. 在查询语句中，必须包含所有表的rowid（以towid方式建立物理化视图日志）3. 在物理化视图中，     SNAPTIME$$：用于表示刷新时间。    DMLTYPE$$：用于表示 DML 操作类型，I 表示 INSERT，D 表示 DELETE，U表示 UPDATE。OLD_NEW$$：用于表示这个值是新值还是旧值。 N（EW）表示新值，O（LD）表示旧值，U 表示 UPDATE 操作。CHANGE_VECTOR$$：表示修改矢量，用来表示被修改的是哪个或哪几个字段。此列是 RAW 类型，其实 Oracle 采用的方式就是用每个 BIT 位去映射一个列。插入操作显示为：FE, 删除显示为：OO 更新操作则根据更新字段的位置而显示不同的值键保留表的可以修改</code></pre><p><em>如果是自动刷新的话，在提交数据的时候会跳过日志，直接提交给视图中，</em></p><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><h3 id="什么是序列"><a href="#什么是序列" class="headerlink" title="什么是序列"></a>什么是序列</h3><p>序列是oracle中提供能产生唯一数字的数据库对象</p><h3 id="创建与使用"><a href="#创建与使用" class="headerlink" title="创建与使用"></a>创建与使用</h3><ul><li>创建序列语法：<ul><li>create sequence 序列名称</li><li>通过序列的伪列来访问序列的值<ul><li>nextval返回序列的下一值</li><li>currval 返回序列的当前值<br><em>注意：我们在刚建立序列后，无法提取当前值，只有先提取下一个值时才能再次提取当前值</em><br>提取下一个值<br>select 序列名.nextval from dual<br>提取当前值<br>select 序列名称.currval from dual</li></ul></li></ul></li><li>创建复杂序列<pre><code>CREATE SEQUENCE sequence //创建序列名称[INCREMENT BY n] //递增的序列值是 n 如果 n 是正数就递增,如果是负数就递减 默认是 1[START WITH n] //开始的值,递增默认是 minvalue 递减是 maxvalue[{MAXVALUE n | NOMAXVALUE}] //最大值[{MINVALUE n | NOMINVALUE}] //最小值[{CYCLE | NOCYCLE}] //循环/不循环[{CACHE n | NOCACHE}];//分配并存入到内存中</code></pre></li><li>案例<ol><li>有最大值的非循环序列<ol><li>创建序列语句：<br>create sequence seq_test1<br>increment by 10<br>start with 10<br>maxvalue 300<br>minvalue 20<br>以上的错误，是由于我们的开始值小于最小值 。开始值不能小于最小值，修改<br>create sequence seq_test1<br>increment by 10<br>start with 10<br>maxvalue 300<br>minvalue 5</li><li>有最大值的循环序列<br>create sequence seq_test2<br>increment by 10<br>start with 10<br>maxvalue 300<br>minvalue 5<br>cycle；</li></ol></li></ol></li></ul><p><em>循环的序列，第一次循环是从开始值开始循环，而第二次循环是从最小值开始循环。</em></p><ol><li><p>带缓存的序列：<br> create sequence seq_test3<br>   increment by 10<br>   start with 10<br>   maxvalue 300<br>   minvalue 5<br>   cycle<br>   cache 50;<br>我们缓存设定的值是 50，而最大值是 300，那么为什么还会提示这样的信息呢（CACHE must be less than one cycle）？<br>其实我们的 cache 虽然是 50，但是我们每次增长值是 10。这样 50 次缓存提取出<br>的数是 500 （50*10）</p><p>create sequence seq_test5<br>increment by 10<br>start with 10<br>maxvalue 501<br>minvalue 5<br>cycle<br>   cache 50;</p></li></ol><p><em>把最小值减 1，或把最大值加 1，都可以通过。</em></p><pre><code>4. 修改和删除序列    1. 修改序列：使用 ALTER SEQUENCE 语句修改序列，不能更改序列的 STARTWITH 参数    2. 删除序列： DROP SEQUENCE 序列名称;</code></pre><h4 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a>同义词</h4><p>同义词实质上就是指定方案对象的一个别名，，你可以创建公共同义词和私有同义词。其中，公共同义词属于 PUBLIC 特殊<br>用户组，数据库的所有用户都能访问；而私有同义词包含在特定用户的方案中，<br>只允许特定用户或者有基对象访问权限的用户进行访问<br>同义词本身不涉及安全，当你赋予一个同义词对象权限时，你实质上是在给<br>同义词的基对象赋予权限，同义词只是基对象的一个别名。</p><h4 id="创建使用同义词"><a href="#创建使用同义词" class="headerlink" title="创建使用同义词"></a>创建使用同义词</h4><ul><li><p>创建同义词的语法</p><p>  create 【public】 synonym for Object；<br>  其中 synonym 表示要创建的同义词的名称，object 表示表，视图，序列等我们要<br>  创建同义词的对象的名称。</p></li><li><p>案例</p><pre><code>`create synonym OWNERS for T_OWNERS;  使用同义词：select *from owners;`</code></pre></li><li>公有同义词 （所有用户都可以访问）</li><li>私有同义词 （只能被使用的用户调用访问）</li></ul><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul><li><p>什么是索引<br><em>索引是用于加速数据存取的数据对象。合理的使用索引可以大大降低 i/o 次数,从而提高数据访问性能</em><br>索引是有存储空间的，所以存储的每条记录都是有物理地址的，也就是我们rowid伪列</p></li><li><p>普通索引</p></li></ul><p>`create index 索引名称 on 表名(列名）``</p><p>索引性能的测试：<br><em>发现通过物理地址查询数据的效率高于通过普通索引</em>    </p><ul><li>唯一索引<ul><li>语法： `create unique index 索引名称 on 表名(列名）``</li></ul></li><li><p>复合索引</p><ul><li>语法： create index 索引名称 on 表名(列名。列名。。）``</li></ul><ul><li>反向键的索引<br>当某个字段的值为连续增长的值，如果构建标准索引，会形成歪脖子<br>树。这样会增加查询的层数，性能会下降。建立反向键索引，可以使索引的值变<br>得不规则，从而使索引树能够均匀分布。</li></ul></li></ul><ul><li><p>位图索引</p><p>位图索引适合创建在低基数列上<br><strong>优点</strong><br>减少响应时间，节省空间占用<br>create bitmap index 索引名称 on 表名（ 列名）</p></li></ul><p>物化视图，是不能upate</p><p>一次缓存的数量必须要小于一次</p><p>所以</p><p>序列：<br>    循环<br>        默认缓存想啊想和·cache 20<br>        缓存的数量小于一次循环的数量<br>索引：<br>只对 有特点的数据进行创建索引<br>    有特点的数据 （自增长的数据创建反向键索引比较合适）<br>    低基数创建位图索引标胶·比较合适</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录的结果是单行的，就是单行查询&lt;/p&gt;
&lt;p&gt;#什么是视图  #&lt;br&gt; 视图是一种数据库对象，是从一个或者多个表达式或视图中导出的虚表，视图对应的数据并不真正地存储视图中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用视图的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简化数据操作: 视图
      
    
    </summary>
    
      <category term="Oracle的基础知识" scheme="http://HackerFreedom.github.io/categories/Oracle%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="oracle基础知识" scheme="http://HackerFreedom.github.io/tags/oracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
