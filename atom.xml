<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TO BE BTTER ME</title>
  
  <subtitle>Hacker</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://HackerFreedom.github.io/"/>
  <updated>2018-05-29T03:01:47.047Z</updated>
  <id>http://HackerFreedom.github.io/</id>
  
  <author>
    <name>Sam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程的理解</title>
    <link href="http://HackerFreedom.github.io/2018/05/29/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://HackerFreedom.github.io/2018/05/29/线程的理解/</id>
    <published>2018-05-29T02:02:00.000Z</published>
    <updated>2018-05-29T03:01:47.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程Thread"><a href="#线程Thread" class="headerlink" title="线程Thread"></a>线程Thread</h1><ul><li>进程内部的一个执行单元，它是程序中一个单一的顺序控制流程</li><li>线程又被称为轻量级进程(lightweight process)</li><li>如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为 多线程</li></ul><h1 id="线程特点"><a href="#线程特点" class="headerlink" title="线程特点"></a>线程特点</h1><ul><li>轻量级进程</li><li>独立调度的基本单位</li><li>可并发执行</li><li>共享进程资源</li></ul><h1 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h1><ol><li>线程的创建</li></ol><ul><li>方式1：继承Java.lang.Thread类，并覆盖run() 方法</li><li>方式2：实现Java.lang.Runnable接口，并实现run() 方法</li><li>方式3: 实现Callable接口 </li></ul><ol><li>线程的启动</li></ol><ul><li>新建的线程不会自动开始运行，必须通过start( )方法启动</li><li>不能直接调用run()来启动线程，这样run()将作为一个普通方法立即执行，执行完毕前其他线<br>程无法执行</li><li>Java程序启动时，会立刻创建主线程，main就是在这个线程上运行。当不再产生新线程时，<br>程序是单线程的</li></ul><ol><li>线程的生命周期</li></ol><ul><li>新生状态：<br>• 用new关键字建立一个线程对象后，该线程对象就处于新生状态。<br>• 处于新生状态的线程有自己的内存空间，通过调用start进入就绪状态</li><li>就绪状态：<br>• 处于就绪状态线程具备了运行条件，但还没分配到CPU，处于线程就绪队列，等待系统为其分配CPU<br>• 当系统选定一个等待执行的线程后，它就会从就绪状态进入执行状态，该动作称之为“cpu调度”。</li><li>运行状态：<br>• 在运行状态的线程执行自己的run方法中代码，直到等待某资源而阻塞或完成任务而死亡。<br>• 如果在给定的时间片内没有执行结束，就会被系统给换下来回到等待执行状态。</li><li>阻塞状态：<br>• 处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进<br>入阻塞状态。<br>• 在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入<br>就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。</li><li>死亡状态：<br>• 死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有三个。一个是正常运行的线程完成了它的全部工作；另一个是线<br>程被强制性地终止，如通过执行stop方法来终止一个线程[不推荐使用】，三是线程抛出未捕获的异常</li></ul><ol><li>线程的控制方法</li></ol><ul><li>join ()<br>• 阻塞指定线程等到另一个线程完成以后再继续执行</li><li>sleep ()<br>• 使线程停止运行一段时间，将处于阻塞状态<br>• 如果调用了sleep方法之后，没有其他等待执行的线程，这个时候当前线程不会马上恢复执行！</li><li>yield ()<br>• 让当前正在执行线程暂停，不是阻塞线程，而是将线程转入就绪状态<br>• 如果调用了yield方法之后，没有其他等待执行的线程，这个时候当前线程就会马上恢复执行！</li><li>setDaemon ()<br>• 可以将指定的线程设置成后台线程<br>• 创建后台线程的线程结束时，后台线程也随之消亡<br>• 只能在线程启动之前把它设为后台线程</li><li>interrupt()<br>• 并没有直接中断线程，而是需要被中断线程自己处理</li><li>stop()<br>• 结束线程，不推荐使用</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li>当多个线程访问同一个数据时，容易出现线程安全问题。需要让线程同步，保证数据安全</li><li><p>线程同步的实现方案</p><ul><li>同步代码块<ul><li>synchronized(obj){}</li></ul></li><li>同步方法<ul><li>private synchronized void makeWithdrawal(int amt) {}</li></ul></li></ul></li><li><p>lock 锁</p><ul><li>JDK1.5后新增功能，与采用synchronized相比，lock可提供多种锁方案，更灵活</li><li>java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为 Java 类，而不是作为语<br>言的特性来实现。这就为 Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁<br>定语义。<ul><li>ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义， 但是添加了类似锁投票、<br>定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。</li><li>注意：如果同步代码有异常，要将unlock()写入finally语句块<h2 id="Lock和synchronized的区别"><a href="#Lock和synchronized的区别" class="headerlink" title="Lock和synchronized的区别"></a>Lock和synchronized的区别</h2></li></ul></li></ul></li><li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li><li><p>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</p></li><li><p>使用的顺序</p><ul><li>Lock—-同步代码块（已经进入了方法体，分配了相应资源）—-同步方法（在方法体之外）</li></ul></li></ul><h2 id="线程同步的优缺点"><a href="#线程同步的优缺点" class="headerlink" title="线程同步的优缺点"></a>线程同步的优缺点</h2><ul><li>优点:解决了线程安全的问题</li><li>缺点 :性能下降,带来了死锁的可能性</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li>当两个线程相互等待对方释放“锁”时就会发生死锁</li><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li><li>多线程编程时应该注意避免死锁的发生</li></ul><p><strong>解决方案</strong><br>排除的方法:</p><ol><li>撤销陷入死锁的全部进程</li><li>逐个撤消陷于死锁的进程，直到死锁不存在</li></ol><p>对于n个线程的访问:<br>提供线程的的执行顺序,同时释放和加上锁,就可以解决了.可以举同时进门的道理..</p><hr><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>创建和销毁对象是非常耗费时间的,对于经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</p><ul><li>思路:创建好多个线程，放入线程池中，使用时直接获取引用，不使用时放回池中。可以避<br>免频繁创建销毁、实现重复利用</li></ul><h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>提高线程的可管理性：避免线程无限制创建、从而销耗系统资源，降低系统稳定性，甚至内<br>存溢出或者CPU耗尽</li></ul><h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><ul><li>Executor：线程池顶级接口，只有一个方法</li><li><p>ExecutorService：真正的线程池接口<br>• void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行Runnable<br>• <t> Future<t> submit(Callable<t> task)：执行任务，有返回值，一般又来执行Callable<br>• void shutdown() ：关闭连接池</t></t></t></p></li><li><p>AbstractExecutorService：基本实现了ExecutorService的所有方法</p></li><li>ThreadPoolExecutor：默认的线程池实现类</li><li>ScheduledThreadPoolExecutor：实现周期性任务调度的线程池</li><li>Executors:工具类、线程池的工厂类，用于创建并返回不同类型的线程池<br>• Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池<br>• Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池<br>• Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池<br>• Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程Thread&quot;&gt;&lt;a href=&quot;#线程Thread&quot; class=&quot;headerlink&quot; title=&quot;线程Thread&quot;&gt;&lt;/a&gt;线程Thread&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进程内部的一个执行单元，它是程序中一个单一的顺序控制流程&lt;/li&gt;
&lt;li&gt;线程
      
    
    </summary>
    
      <category term="线程" scheme="http://HackerFreedom.github.io/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>ideal遇到的坑</title>
    <link href="http://HackerFreedom.github.io/2018/05/17/ideal%E4%BE%9D%E8%B5%96%E5%BC%82%E5%B8%B8/"/>
    <id>http://HackerFreedom.github.io/2018/05/17/ideal依赖异常/</id>
    <published>2018-05-17T07:51:00.000Z</published>
    <updated>2018-05-17T07:56:23.685Z</updated>
    
    <content type="html"><![CDATA[<p>ideal依赖异常</p><p>解决方案</p><p>方案一：可以在项目结构图中右键报红的jar包，选择排除掉冲突（会在pom.xml中自动写上排除的标签）。</p><p>方案二：将波浪线的dependency，将其从pom中删除，保存后，再撤销回来，然后reimport。网上很多方案都是这样。</p><p>其实这个红线是不影响项目运行的，也可以选择不理睬。</p><hr><p>ideal部署war时没有配置文件的原因<br>需要在pom文件添加配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src/resources&lt;/directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">                &lt;/includes&gt;</span><br><span class="line">                &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line"> &lt;/resources&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ideal依赖异常&lt;/p&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;p&gt;方案一：可以在项目结构图中右键报红的jar包，选择排除掉冲突（会在pom.xml中自动写上排除的标签）。&lt;/p&gt;
&lt;p&gt;方案二：将波浪线的dependency，将其从pom中删除，保存后，再撤销回来，然后reimpo
      
    
    </summary>
    
      <category term="ideal进阶" scheme="http://HackerFreedom.github.io/categories/ideal%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-AOP理解</title>
    <link href="http://HackerFreedom.github.io/2018/05/17/SpringAop%E8%BF%9B%E9%98%B6%E7%90%86%E8%A7%A3/"/>
    <id>http://HackerFreedom.github.io/2018/05/17/SpringAop进阶理解/</id>
    <published>2018-05-17T07:47:00.000Z</published>
    <updated>2018-05-17T07:47:56.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP简单介绍"><a href="#AOP简单介绍" class="headerlink" title="AOP简单介绍"></a>AOP简单介绍</h1><p>AOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。静态代理是编译期实现，动态代理是运行期实现，可想而知前者拥有更好的性能。本文主要介绍Spring AOP的两种代理实现机制，JDK动态代理和CGLIB动态代理。</p><p>静态代理是编译阶段生成AOP代理类，也就是说生成的字节码就织入了增强后的AOP对象；动态代理则不会修改字节码，而是在内存中临时生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。JDK于目标类是兄弟的关系，这里要注意一个问题？</p><p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的，诸如private的方法也是不可以作为切面的。</p><h2 id="Aop中的JDK动态代理"><a href="#Aop中的JDK动态代理" class="headerlink" title="Aop中的JDK动态代理"></a>Aop中的JDK动态代理</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AOP简单介绍&quot;&gt;&lt;a href=&quot;#AOP简单介绍&quot; class=&quot;headerlink&quot; title=&quot;AOP简单介绍&quot;&gt;&lt;/a&gt;AOP简单介绍&lt;/h1&gt;&lt;p&gt;AOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一
      
    
    </summary>
    
      <category term="SPring" scheme="http://HackerFreedom.github.io/categories/SPring/"/>
    
    
  </entry>
  
  <entry>
    <title>AJAX跨域的分析</title>
    <link href="http://HackerFreedom.github.io/2018/05/17/Ajax%E7%9A%84%E8%B7%A8%E5%9F%9F%E5%88%86%E6%9E%90/"/>
    <id>http://HackerFreedom.github.io/2018/05/17/Ajax的跨域分析/</id>
    <published>2018-05-17T07:46:00.000Z</published>
    <updated>2018-05-17T07:47:03.760Z</updated>
    
    <content type="html"><![CDATA[<p>课程介绍</p><p>什么是AJAX跨域问题<br>产生AJAX跨域问题的原因<br>解决AJAX跨域问题的思路和方法<br>什么是AJAX跨域问题</p><p>简单来说，就是前端调用后端服务接口时<br>如果服务接口不是同一个域，就会产生跨域问题<br>AJAX跨域场景</p><p>前后端分离、服务化的开发模式<br>前后端开发独立，前端需要大量调用后端接口的场景<br>只要后端接口不是同一个域，就会产生跨域问题<br>跨域问题很普遍，解决跨域问题也很重要<br>AJAX跨域原因</p><p>浏览器限制：浏览器安全校验限制<br>跨域（协议、域名、端口任何一个不一样都会认为是跨域）<br>XHR（XMLHttpRequest）请求<br>AJAX跨域问题解决思路</p><p>浏览器：浏览器取下跨域校验，实际价值不大<br>XHR：不使用XHR，使用JSONP，有很多弊端，无法满足现在的开发要求<br>跨域：被调用方修改支持跨域调用（指定参数）；调用方修改隐藏跨域（基于代理）</p><p>编写测试代码</p><p>被调用方后端代码编写：Spring Boot<br>调用方前端代码编写：Jquery<br>引入前端Jasmine测试框架</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;课程介绍&lt;/p&gt;
&lt;p&gt;什么是AJAX跨域问题&lt;br&gt;产生AJAX跨域问题的原因&lt;br&gt;解决AJAX跨域问题的思路和方法&lt;br&gt;什么是AJAX跨域问题&lt;/p&gt;
&lt;p&gt;简单来说，就是前端调用后端服务接口时&lt;br&gt;如果服务接口不是同一个域，就会产生跨域问题&lt;br&gt;AJAX跨域场
      
    
    </summary>
    
      <category term="AJAX跨域" scheme="http://HackerFreedom.github.io/categories/AJAX%E8%B7%A8%E5%9F%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>source folder</title>
    <link href="http://HackerFreedom.github.io/2018/05/17/source%E5%92%8Cforder%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://HackerFreedom.github.io/2018/05/17/source和forder的区别/</id>
    <published>2018-05-17T07:46:00.000Z</published>
    <updated>2018-05-17T07:50:01.385Z</updated>
    
    <content type="html"><![CDATA[<p>它们的区别如下:<br>package:当你在建立一个package时,它自动建立到source folder下,也只能建立在这个目录之下.  </p><p>source folder:存放java源代码的文件夹,当然也包括一些package文件夹,还可以包含其他文件.<br>项目构建后,source folder里面的java自动编译成class文件到相应的/web-inf/classes文件夹中,其他文件也会移到/web-inf/classes相应的目录下.  </p><p>package和sourceFolder比较<br>相同之外：package下除了java文件也可以包含其他文件，而且编译、打包后的文件路径与source folder下的文件路径有一样规则<br>不同之外：1.sourceFolder靠”/“来进行上下级划分，package靠“.”来进行上下级划分。<br>  2.source folder下能建package,而package下不能建source folder<br>  3.java文件中的package属性是按package路径来进行赋值的，source folder路径不参与java文件的package属性赋值，再由第二条不同得到结论，所有source folder下的java文件package属性都为空。</p><p>folder:里面可以放入任何文件.包括java源文件,jar文件,其他文件(例如,图片,声音等).在此我说明一下,如果里面含有java源文件,不管程序是否正确,eclipse都不会报错,把它们当做普通文件处理.但是项目如果要使用这里面的文件,情况就不同了. </p><p>package,source folder,folder 之间相互转换<br>package 转成 folder 显示：选中package, build path-&gt; Exclude<br>folder 转成 package 显示：选中folder, build path-&gt; Include </p><p>package 转成 source folder 显示：选中package, build path-&gt; Use as Source folder<br>source folder 转成 package 显示：选中folder, build path-&gt; Remove from BuildPath </p><p>pacage 与 source folder 的转换同上 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;它们的区别如下:&lt;br&gt;package:当你在建立一个package时,它自动建立到source folder下,也只能建立在这个目录之下.  &lt;/p&gt;
&lt;p&gt;source folder:存放java源代码的文件夹,当然也包括一些package文件夹,还可以包含其他文件.&lt;
      
    
    </summary>
    
      <category term="小知识大道理" scheme="http://HackerFreedom.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86%E5%A4%A7%E9%81%93%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>需要整理的知识</title>
    <link href="http://HackerFreedom.github.io/2018/05/17/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    <id>http://HackerFreedom.github.io/2018/05/17/零碎知识/</id>
    <published>2018-05-17T07:45:00.000Z</published>
    <updated>2018-05-17T07:45:37.499Z</updated>
    
    <content type="html"><![CDATA[<p>重构 </p><p>effective java</p><p>spring data jpa</p><p>jpa domain中的注解</p><p>接口 jpaRepository,jpaSpec</p><p>jax-ws方式<br>-发布服务 （服务端）<br>调用（客户端）</p><p>redis 和 session 存入数据的区别</p><p>1.与其他用户状态保存方案比较<br>一般开发中用户状态使用session或者cookie，两种方式各种利弊。</p><p>Session:在InProc模式下容易丢失，并且引起并发问题。如果使用SQLServer或者SQLServer模式又消耗了性能</p><p>Cookie则容易将一些用户信息暴露，加解密同样也消耗了性能。</p><p>Redis采用这样的方案解决了几个问题，</p><ol><li><p>Redis存取速度快。</p></li><li><p>用户数据不容易丢失。</p></li><li><p>用户多的情况下容易支持集群。</p></li><li><p>能够查看在线用户。</p></li><li><p>能够实现用户一处登录。（通过代码实现，后续介绍）</p></li><li><p>支持持久化。（当然可能没什么用）</p></li></ol><p><img src="" alt=""><br>一旦一个字符串在内存(堆)中被创建，它就不可以被修改。我们应该记住这一点，String的所有所有方法都不能够修改它本身的字符串，但是，可以返回一个方法操作之后的新字符串。</p><p>activemq中使用消费者监听<br>防止线程的退出<br> thread 。currenThread（）。join（）；Join是一种同步方法，阻止调用线程</p><p>属性驱动封装对象</p><p>文件上传要注意，是struts2拦截器在起作用。</p><p>模型驱动</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重构 &lt;/p&gt;
&lt;p&gt;effective java&lt;/p&gt;
&lt;p&gt;spring data jpa&lt;/p&gt;
&lt;p&gt;jpa domain中的注解&lt;/p&gt;
&lt;p&gt;接口 jpaRepository,jpaSpec&lt;/p&gt;
&lt;p&gt;jax-ws方式&lt;br&gt;-发布服务 （服务端）&lt;br&gt;
      
    
    </summary>
    
      <category term="闪光点" scheme="http://HackerFreedom.github.io/categories/%E9%97%AA%E5%85%89%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>java虚拟机中的栈分析</title>
    <link href="http://HackerFreedom.github.io/2018/05/17/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://HackerFreedom.github.io/2018/05/17/栈溢出/</id>
    <published>2018-05-17T07:42:00.000Z</published>
    <updated>2018-05-17T07:43:02.782Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>测试：栈溢出的情况（递归调用导致栈深度不断增加）</li><li>StackOverFlowError这个异常，有错误堆栈可以阅读，比较好定位。而且如果使用虚拟机默认参数，栈深度在大多数情况下，达到1000~2000完全没有问题，正常方法的调用这个深度应该是完全够了。但是如果建立过多线程导致的OutOfMemoryError，</li><li>在不能减少线程数或者更换64位虚拟机的情况下，</li><li>就只能通过减小最大堆容量和减小栈容量来换取更多的线程了。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverFloweTest &#123;</span><br><span class="line">    private int stackLength =1;</span><br><span class="line"></span><br><span class="line">    public void stackLeak()&#123;</span><br><span class="line">        stackLength ++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackOverFloweTest stackOverFloweTest=new StackOverFloweTest();</span><br><span class="line">        try &#123;</span><br><span class="line">            stackOverFloweTest.stackLeak();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;stack length:&quot;+stackOverFloweTest.stackLength);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">at StackOverFloweTest.stackLeak(StackOverFloweTest.java:9)</span><br><span class="line">`</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;测试：栈溢出的情况（递归调用导致栈深度不断增加）&lt;/li&gt;
&lt;li&gt;StackOverFlowError这个异常，有错误堆栈可以阅读，比较好定位。而且如果使用虚拟机默认参数，栈深度在大多数情况下，达到1000~2000完全没有问题，正常方法的调用这个深
      
    
    </summary>
    
      <category term="java虚拟机" scheme="http://HackerFreedom.github.io/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>String中ValueOf的分析</title>
    <link href="http://HackerFreedom.github.io/2018/05/17/String-toString-String-valueOf%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://HackerFreedom.github.io/2018/05/17/String-toString-String-valueOf的区别/</id>
    <published>2018-05-17T07:42:00.000Z</published>
    <updated>2018-05-17T07:44:29.087Z</updated>
    
    <content type="html"><![CDATA[<p>(string)</p><p>这是标准的类型转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。因此最好用instanceof做个类型检查，以判断是否可以转换。否则容易抛出CalssCastException异常。此外，需特别小心的是因定义为Object 类型的对象在转成String时语法检查并不会报错，这将可能导致潜在的错误存在。这时要格外小心。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Integer(100);</span><br><span class="line">String strVal = (String)obj;</span><br></pre></td></tr></table></figure></p><ul><li><p>toString<br>  在这种使用方法中，因为java.lang.Object类里已有public方法.toString()，所以对任何严格意义上的java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常。采用这种方法时，通常派生类会覆盖Object里的toString（）方法</p></li><li><p>String.valueOf<br>  这个方法是静态的，直接通过String调用。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String valueOf(Object obj)&#123;</span><br><span class="line">    return (obj==null) ? &quot;null&quot; : obj.toString()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内部就是做了为空的判断的，所以就不会报出空指针异常。　　</p><p>从上面的源码可以很清晰的看出null值不用担心的理由。但是，这也恰恰给了我们隐患。我们应当注意到，当<code>object为null 时，String.valueOf（object）的值是字符串”null”，而不是null！！！</code>在使用过程中切记要注意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(String.valueOf（object）== null)&#123;</span><br><span class="line">    System.out.println(“传入的值是null！”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的语句将可能会发生什么问题。再想一下，向控制台输出时，在视觉上如下语句在执行的结果上有什么不同：</p><p>Object obj = null;<br>System.out.println(String.valueOf(obj) + “-&gt;此处null的类型是” + String.valueOf(obj).getClass());<br>System.out.println(obj);<br>我们看到的输出将是一模一样的东西：null，但它们意义相同吗?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null此处null类型是class java.lang.String</span><br><span class="line">null</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(string)&lt;/p&gt;
&lt;p&gt;这是标准的类型转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。因此最好用instanceof做个类型检查，以判断是否可以转换。否则容易抛出CalssCastException异常。此外
      
    
    </summary>
    
      <category term="String分析" scheme="http://HackerFreedom.github.io/categories/String%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>java类的理解</title>
    <link href="http://HackerFreedom.github.io/2018/05/17/java%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://HackerFreedom.github.io/2018/05/17/java类的理解/</id>
    <published>2018-05-17T07:36:00.000Z</published>
    <updated>2018-05-17T07:38:58.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流 ( 即字节码 )”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><ol><li>类与类加载器<br>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗而言：比较两个类是否“相等”（这里所指的“相等”，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof() 关键字做对象所属关系判定等情况），只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。<h2 id="2-类加载器分类"><a href="#2-类加载器分类" class="headerlink" title="2. 类加载器分类"></a>2. 类加载器分类</h2>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</li></ol><p>启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分；</p><p>所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</p><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p><p><code>启动类加载器</code>（Bootstrap ClassLoader） 此类加载器负责将存放在 <java_home>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</java_home></p><p><code>扩展类加载器</code>（Extension ClassLoader） 这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <java_home>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</java_home></p><p><code>应用程序类加载器</code>（Application ClassLoader） 这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><h2 id="3-双亲委派模型"><a href="#3-双亲委派模型" class="headerlink" title="3. 双亲委派模型"></a>3. 双亲委派模型</h2><p>应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。</p><p>（一）工作过程</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载，而是把这个请求委派给父类加载器，每一个层次的加载器都是如此，依次递归。因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成此加载请求（它搜索范围中没有找到所需类）时，子加载器才会尝试自己加载。</p><p>（二）好处</p><p>使用双亲委派模型来组织类加载器之间的关系，使得 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型，由各个类加载器自行加载的话，如果用户编写了一个称为java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将变得一片混乱。如果开发者尝试编写一个与 rt.jar 类库中已有类重名的 Java 类，将会发现可以正常编译，但是永远无法被加载运行。</p><p>（三）实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123;</span><br><span class="line">    //check the class has been loaded or not</span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    if(c == null) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            if(parent != null) &#123;</span><br><span class="line">                c = parent.loadClass(name, false);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(ClassNotFoundException e) &#123;</span><br><span class="line">            //if throws the exception , the father can not complete the load</span><br><span class="line">        &#125;</span><br><span class="line">        if(c == null) &#123;</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四、JVM-参数"><a href="#四、JVM-参数" class="headerlink" title="四、JVM 参数"></a>四、JVM 参数</h1><p>GC 优化配置<br>配置    描述<br>-Xms    初始化堆内存大小<br>-Xmx    堆内存最大值<br>-Xmn    新生代大小<br>-XX:PermSize    初始化永久代大小<br>-XX:MaxPermSize    永久代最大容量<br>GC 类型设置<br>配置    描述<br>-XX:+UseSerialGC    串行垃圾回收器<br>-XX:+UseParallelGC    并行垃圾回收器<br>-XX:+UseConcMarkSweepGC    并发标记扫描垃圾回收器<br>-XX:ParallelCMSThreads=    并发标记扫描垃圾回收器 = 为使用的线程数量<br>-XX:+UseG1GC    G1 垃圾回收器<br>java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar java-application.jar</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类加载器&quot;&gt;&lt;a href=&quot;#类加载器&quot; class=&quot;headerlink&quot; title=&quot;类加载器&quot;&gt;&lt;/a&gt;类加载器&lt;/h1&gt;&lt;p&gt;虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流 ( 即字节码 )”这个动作放到 Java 
      
    
    </summary>
    
      <category term="java" scheme="http://HackerFreedom.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/04/23/%E5%B1%80%E9%83%A8%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://HackerFreedom.github.io/2018/04/23/局部和成员的区别/</id>
    <published>2018-04-23T00:44:17.174Z</published>
    <updated>2018-04-23T06:03:23.955Z</updated>
    
    <content type="html"><![CDATA[<p>对于成员变量和局部变量简单的理解。</p><ol><li>类的位置不同。</li><li><p>内存位置不同，java内存的分析可以看出来，<br> 成员变量分布在中方法区，如果你事例化了这个对象，内存中将会写入一个hashcode值来指向这个值。new Stack—&gt;dui</p><p> 区部变量分布在栈内存中，所以必须要有初始化的值。</p></li><li><p>生命周期不同。</p></li><li>初始化值不同。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于成员变量和局部变量简单的理解。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类的位置不同。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存位置不同，java内存的分析可以看出来，&lt;br&gt; 成员变量分布在中方法区，如果你事例化了这个对象，内存中将会写入一个hashcode值来指向这个值。new Stack—
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/04/22/java%E4%B8%AD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dnull%E5%80%BC%E6%A3%80%E6%9F%A5/"/>
    <id>http://HackerFreedom.github.io/2018/04/22/java中如何避免null值检查/</id>
    <published>2018-04-22T13:38:44.323Z</published>
    <updated>2018-04-22T13:38:44.384Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 8 中提高 Null 的安全性<br>我已经在另一篇文章中说明了我们可以如何利用 Java 8 的 Optional 类型来预防 null 检查。下面是那篇文章中的示例代码。</p><p>假设我们有一个像这样的类层次结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    Nested nested;</span><br><span class="line">    Nested getNested() &#123;</span><br><span class="line">        return nested;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Nested &#123;</span><br><span class="line">    Inner inner;</span><br><span class="line">    Inner getInner() &#123;</span><br><span class="line">        return inner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Inner &#123;</span><br><span class="line">    String foo;</span><br><span class="line">    String getFoo() &#123;</span><br><span class="line">        return foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决这种结构的深层嵌套路径是有点麻烦的。我们必须编写一堆 null 检查来确保不会导致一个 NullPointerException：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = new Outer();</span><br><span class="line">if (outer != null &amp;&amp; outer.nested != null &amp;&amp; outer.nested.inner != null) &#123;</span><br><span class="line">    System.out.println(outer.nested.inner.foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过利用 Java 8 的 Optional 类型来摆脱所有这些 null 检查。map 方法接收一个 Function 类型的 lambda 表达式，并自动将每个 function 的结果包装成一个 Optional 对象。这使我们能够在一行中进行多个 map 操作。Null 检查是在底层自动处理的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(new Outer())</span><br><span class="line">    .map(Outer::getNested)</span><br><span class="line">    .map(Nested::getInner)</span><br><span class="line">    .map(Inner::getFoo)</span><br><span class="line">    .ifPresent(System.out::println);</span><br><span class="line">还有一种实现相同作用的方式就是通过利用一个 supplier 函数来解决嵌套路径的问题：</span><br></pre></td></tr></table></figure></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Outer obj = new Outer();</span><br><span class="line">resolve(() -&gt; obj.getNested().getInner().getFoo());</span><br><span class="line">    .ifPresent(System.out::println);</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>调用 obj.getNested().getInner().getFoo()) 可能会抛出一个 NullPointerException 异常。在这种情况下，该异常将会被捕获，而该方法会返回 Optional.empty()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Optional&lt;T&gt; resolve(Supplier&lt;T&gt; resolver) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        T result = resolver.get();</span><br><span class="line">        return Optional.ofNullable(result);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NullPointerException e) &#123;</span><br><span class="line">        return Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请记住，这两个解决方案可能没有传统 null 检查那么高的性能。不过在大多数情况下不会有太大问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Java 8 中提高 Null 的安全性&lt;br&gt;我已经在另一篇文章中说明了我们可以如何利用 Java 8 的 Optional 类型来预防 null 检查。下面是那篇文章中的示例代码。&lt;/p&gt;
&lt;p&gt;假设我们有一个像这样的类层次结构：&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ssh框架</title>
    <link href="http://HackerFreedom.github.io/2018/04/18/SSH%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://HackerFreedom.github.io/2018/04/18/SSH框架总结/</id>
    <published>2018-04-18T01:58:00.000Z</published>
    <updated>2018-04-18T02:47:28.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总括"><a href="#总括" class="headerlink" title="总括"></a>总括</h1><p>SSH是Struts2 +spring+hibernate集成的框架，</p><p>-整体的架构<br>三层架构 ： web层 -service层 -dao层<br>web层–就是所谓的view页面，一般是通过jsp，html页面实现交互。负责传送请求(Request)和接收响应(Response)，然后Struts<br>根据配置文件(struts-config.xml)将ActionServlet接收到的Request委派给相应的Action处理。</p><p>service层–主要是处理一些复杂的逻辑事务管理，完成事务的提交和关闭</p><p>dao层—主要和持久层进行交互，处理数据的结果。</p><hr><h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><p>spring的核心技术就是IOC（控制反转，DI依赖注入）和AOP（面向切面编程）。</p><ol><li><p>spring的设计模式</p><ul><li>工厂模式<ul><li>通过<bean>元素标签，用于创建和实例化对象的类名以及对象的属性。</bean></li></ul></li><li>适配器模式</li></ul></li><li><p>对于DI依赖注入和AOP的理解<br> AOP叫做面向切面编程，就是把相同功能的抽取，也就是说把业务功能统一管理在一个容器当中，使之降低了耦合性。</p><p> 而调用这一类的方法就引入的代理对象的说法，也就是Cglib和JDK的动态的代理。<br> 对于JDK来说必须要是实现了?????</p><p>  DI叫做依赖注入</p></li></ol><h1 id="AOP中术语"><a href="#AOP中术语" class="headerlink" title="AOP中术语"></a>AOP中术语</h1><p>其实可以把aop想象成一把刀，在切菜的时候，就可以分为前中后的说法了</p><ul><li>通知（Advice）</li></ul><ul><li><p>切入点 (PoinCut)</p></li><li><p>切面 （Aspect）</p></li><li><p>目标 (target)</p></li></ul><h1 id="hibernate中注意的问题"><a href="#hibernate中注意的问题" class="headerlink" title="hibernate中注意的问题"></a>hibernate中注意的问题</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总括&quot;&gt;&lt;a href=&quot;#总括&quot; class=&quot;headerlink&quot; title=&quot;总括&quot;&gt;&lt;/a&gt;总括&lt;/h1&gt;&lt;p&gt;SSH是Struts2 +spring+hibernate集成的框架，&lt;/p&gt;
&lt;p&gt;-整体的架构&lt;br&gt;三层架构 ： web层 -serv
      
    
    </summary>
    
      <category term="SSH总结" scheme="http://HackerFreedom.github.io/categories/SSH%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/tags/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/04/17/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E6%9E%84%E9%80%A0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://HackerFreedom.github.io/2018/04/17/Java静态代码块和构造执行顺序/</id>
    <published>2018-04-17T10:23:39.362Z</published>
    <updated>2018-04-17T10:34:00.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java静态代码块、构造代码块、构造方法的执行顺序"><a href="#Java静态代码块、构造代码块、构造方法的执行顺序" class="headerlink" title="Java静态代码块、构造代码块、构造方法的执行顺序"></a>Java静态代码块、构造代码块、构造方法的执行顺序</h1><p>静态代码优先于非静态的代码，因为被static修饰的成员都是类成员，会随着JVM加载类的时候加载而执行<br>而没有被static修饰的成员也被称为实例成员，需要创建对象才会随之加载到堆内存。所以静态的会优先非静态的。</p><p>，super语句，可能出现以下三种情况：<br>1）构造方法体的第一行是this语句，则不会执行隐式三步，<br>2）构造方法体的第一行是super语句，则调用相应的父类的构造方法，<br>3）构造方法体的第一行既不是this语句也不是super语句，则隐式调用super()，即其父类的默认构造方法，这也是为什么一个父类通常要提供默认构造方法的原因；<br>2，初始化非静态变量；<br>3，构造代码块。<br>由此可知，构造代码块优先于构造方法的方法体，但是this关键字跟super关键字不能同时出现，而且只能在代码的第一行。<br>如果出现了this关键字，隐式三步就不会执行。 </p><ol><li>局部代码块</li></ol><p>局部代码块，又叫普通代码块。它是作用在方法中的代码块。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void show()&#123;  </span><br><span class="line">        &#123;  </span><br><span class="line">  </span><br><span class="line"> System.out.println(&quot;局部代码块运行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line">作用：是控制变量的生命周期。</span><br><span class="line">在程序中当我们定义完成一个局部变量x之后，并且在接下来的代码中，不想再用到它时，那么就没必要让x在内存中继续占用空间。因此就有了局部代码块</span><br><span class="line"></span><br><span class="line">2. 构造代码块</span><br><span class="line"></span><br><span class="line">在类中:</span><br><span class="line"></span><br><span class="line">格式：&#123;构造代码块执行语句&#125;</span><br><span class="line"></span><br><span class="line">作用：就是给所有对象进行初始化。</span><br><span class="line"></span><br><span class="line">注意几点：1.每次创建对象他都会执行。</span><br><span class="line"></span><br><span class="line">2.构造代码快是优于构造函数执行。</span><br><span class="line"></span><br><span class="line">3.构造代码块与构造函数的区别是：构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。</span><br></pre></td></tr></table></figure></p><p>public class Apple{<br>    private String size;<br>    //构造代码块<br>        {<br>            System.out.println(“构造代码块运行！”);<br>             size=”大”;<br>        }<br>}<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java静态代码块、构造代码块、构造方法的执行顺序&quot;&gt;&lt;a href=&quot;#Java静态代码块、构造代码块、构造方法的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;Java静态代码块、构造代码块、构造方法的执行顺序&quot;&gt;&lt;/a&gt;Java静态代码块、构
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/04/16/ideal%E4%B8%AD%E5%88%9B%E5%BB%BAsource%E6%96%87%E4%BB%B6/"/>
    <id>http://HackerFreedom.github.io/2018/04/16/ideal中创建source文件/</id>
    <published>2018-04-16T12:46:42.416Z</published>
    <updated>2018-04-16T12:46:42.447Z</updated>
    
    <content type="html"><![CDATA[<p>Intellij IDEA 创建资源文件夹 source folder</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Intellij IDEA 创建资源文件夹 source folder&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4月bos项目总结</title>
    <link href="http://HackerFreedom.github.io/2018/04/15/bos%E9%A1%B9%E7%9B%AE%E4%B8%BB%E7%BA%BF%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://HackerFreedom.github.io/2018/04/15/bos项目主线技术总结/</id>
    <published>2018-04-15T10:44:00.000Z</published>
    <updated>2018-04-15T11:12:54.396Z</updated>
    
    <content type="html"><![CDATA[<ol><li>收派标准的CRUD<ul><li>需要前端知识，JQery Easyui （根据文档使用）</li><li>需要从表现层到业务层和持久层，技术点 Struts2+Spring+Spring Data JPA+Hibernate</li></ul></li></ol><ol><li><p>快递员的CRUD</p><ul><li>快递员关联收派标准</li><li>技术点有easyui中的combobox</li></ul></li><li><p>区域的CRUD</p><ul><li>需要导入提前整理好的Excel文档，</li><li>于是学了一键上传及POI，因为有城市编码、简码，于是用到了pinyin4j（根据名称翻译成pinyin还是存在问题，目前未解决）</li></ul></li><li><p>定区中的CRUD</p><ol><li><p>定区关联客户<br> 因为客户信息存在CRM系统上，涉及到多个系统之间数据通信，于是学习了WebService，CXF，jax-ws，jax-rs，Restful<br> 因为界面上要操作关联未关联，于是有两个下拉列表的左移，右移，因为下拉列表要显示数据，于是用CXF的jax-rs向CRM系统发起请求，获取数据再显示到下拉列表上（CXF重点）</p></li><li><p>定区关联快递员，定区关联收派时间，业务的需求</p></li></ol></li></ol><ol><li><p>因为BOS物流综合系统涉及到多个子系统，其中最核心的是<code>BOS</code>系统、<code>CRM</code>系统、前端系统，于是开始操作前端系统<br>1）    学习AngularJS，前端开发流行框架（会用）<br>从注册功能着手，涉及到发短信（就是发验证码），发邮件<br>发短信，调用第三方API（会用），发邮件，用javamail（会用）<br>2）    发邮件涉及到激活码的保存，于是学习了redis（会用）<br>3）    发短信比较耗时，不适合放在主体代码逻辑了，单独分拆出来，于是学习了ActiveMQ（重点,处理高并发的问题，排队的机制）<br>4）    发邮件的代码，也应该单独分拆出来<br>注意点：注册，用CXF的jax-rs把注册信息保存在CRM系统中<br>判断激活码是否有效时，用CXF的jax-rs去CRM系统中取数据<br>没有绑定的，用CXF的jax-rs去CRM系统中绑定</p></li><li><p>前端系统要展示促销活动，促销活动的真实数据是存在BOS系统，展示是在前端系统，编辑促销活动的信息，是在BOS后台<br>于是学习了kindeditor在线编辑工具（会用）<br>1）    bos系统促销活动的保存、分页显示（重点）<br>中间涉及到kindeditor在线编辑工具保存图片、图片空间（会用）<br>2）    前端系统促销活动的分页显示（重点）<br>促销活动详情的显示，学到了<code>Freemarker</code>模板引擎（会用）<br>3）    促销活动定时过期功能，学习quartz定时框架<br>促销活动的分页显示、详情显示，都用到了CXF调用BOS相关接口<br>前端系统的登录，用到了CXF调用CRM</p></li><li><p>取派业务（订单、工单、运单），物流涉及到路线显示，插入百度地图的学习）</p></li><li><p>客户下单，自动分单的流程：（<em>以后遇到逻辑性比较强的记住要运用到时序图</em>，或者逻辑图来梳理！！！！）<br>1）    在基础数据模块，实现定区关联客户，客户【地址】已经与定区【快递员】进行过关联，当下单地址与客户地址完全一致时，找到下单客户信息，找到匹配定区，找到快递员，自动分单成功<br>2）    如果下单地址没有与CRM客户地址完全一致，从下单信息中省、市、区匹配区域信息，分区属于区域，获取区域中所有分区信息，获取分区关键字、辅助关键字，下单地址匹配分区关键字\辅助关键字，找到分区，通过分区找到定区，找到匹配快递员，自动分单成功<br>3）    以上业务逻辑都没有实现，则进入人工调度。</p><pre><code>需要省市区三级联动，插入city-picker的学习，为了详细地址信息的输入方便，插入百度地图自动补全的学习。</code></pre></li><li><p>运单的快速录入，运单管理。<br>1）运单快速录入，用到datagrid的行编辑及插入空行<br>2）运单包含订单的很多信息，于是用到了订单信息的回显<br>3）因为有运单快速录入，相当于运单录入的简化版，于是在运单录入时有运单信息的回显<br>4）运单的查询，因为字符串的模糊查询涉及到性能问题，于是学习ElasticSearch搜索服务器及Spring Data ElasticSearch，专门提高搜索的效率</p></li></ol><p>10. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;收派标准的CRUD&lt;ul&gt;
&lt;li&gt;需要前端知识，JQery Easyui （根据文档使用）&lt;/li&gt;
&lt;li&gt;需要从表现层到业务层和持久层，技术点 Struts2+Spring+Spring Data JPA+Hibernate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li
      
    
    </summary>
    
      <category term="项目技术点" scheme="http://HackerFreedom.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E7%82%B9/"/>
    
    
      <category term="技术点" scheme="http://HackerFreedom.github.io/tags/%E6%8A%80%E6%9C%AF%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/04/13/%E5%8F%8D%E5%B0%84%E7%9A%84%E6%9A%B4%E5%8A%9B%E8%AE%BF%E9%97%AE/"/>
    <id>http://HackerFreedom.github.io/2018/04/13/反射的暴力访问/</id>
    <published>2018-04-13T10:54:01.938Z</published>
    <updated>2018-04-13T10:54:01.997Z</updated>
    
    <content type="html"><![CDATA[<p> java对类私有变量的暴力反射</p><p>方法，<br>可以获取x属性。再通过setAccessible使得可以访问这个属性。然后可以通过set方法赋值。<br>注意：getClass获得是ReflectPoint的字节码，与具体实例无关，<br>因此，Field也与具体实例无关。在设置和访问的时候，均需要指定具体哪个实例。</p><p>封装参数有问题</p><p>属性封装冲突model和模型冲突，，注意字段名重名<br>的区别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; java对类私有变量的暴力反射&lt;/p&gt;
&lt;p&gt;方法，&lt;br&gt;可以获取x属性。再通过setAccessible使得可以访问这个属性。然后可以通过set方法赋值。&lt;br&gt;注意：getClass获得是ReflectPoint的字节码，与具体实例无关，&lt;br&gt;因此，Field也与
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/04/10/json%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://HackerFreedom.github.io/2018/04/10/json的序列化和反序列化的理解/</id>
    <published>2018-04-10T11:23:01.599Z</published>
    <updated>2018-04-10T11:23:01.620Z</updated>
    
    <content type="html"><![CDATA[<p>Json的语法可以表示一下三种类型的值：</p><p> 简单值：可表示字符串、数值、布尔值和null。但不支持undefined。<br> 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对。<br> 数组：数组也是一种复杂数据类型，表示的是一组有序的值的列表</p><p>1.将Java的对象转换为JSON字符串（序列化）<br>先将的Java对象转换为JSON对象，在将JSON对象转换为JSON字符串</p><p>JSONObject json = JSONObject.fromObject（obj）; //将java对象转换为json对象</p><p>String str = json.toString（）; //将json对象转换为字符串</p><p>2.将JSON字符串转换为java的对象（反序列化）<br>同样先将JSON字符串转换为JSON对象，再将JSON对象转换为Java的对象，如下所示。<br>JSONObject obj = new JSONObject（）。fromObject（jsonStr）; //将JSON字符串转换为JSON对象，jsonStr为一个JSON字符串<br>将JSON对象转换为java的对象（人物为实例类）<br>Person jb =（Person）JSONObject.toBean（obj，Person.class）; //将建json对象转换为Person对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Json的语法可以表示一下三种类型的值：&lt;/p&gt;
&lt;p&gt; 简单值：可表示字符串、数值、布尔值和null。但不支持undefined。&lt;br&gt; 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对。&lt;br&gt; 数组：数组也是一种复杂数据类型，表示的是一组有序的值的列表&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/04/07/Stream%E8%AF%AD%E6%B3%95/"/>
    <id>http://HackerFreedom.github.io/2018/04/07/Stream语法/</id>
    <published>2018-04-07T11:51:06.787Z</published>
    <updated>2018-04-07T11:51:55.880Z</updated>
    
    <content type="html"><![CDATA[<p>Java8之Stream语法详解.</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>A sequence of elements supporting sequential and parallel aggregate operations.</p><p>我们来解读一下上面的那句话：</p><p>Stream是元素的集合，这点让Stream看起来用些类似Iterator；<br>可以支持顺序和并行的对原Stream进行汇聚的操作；<br>大家可以把Stream当成一个高级版本的Iterator。原始版本的Iterator，用户只能一个一个的遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如“过滤掉长度大于10的字符串”、“获取每个字符串的首字母”等，具体这些操作如何应用到每个元素上，就给Stream就好了！（这个秘籍，一般人我不告诉他））</p><p>//Lists是Guava中的一个工具类<br>List<integer> nums = Lists.newArrayList(1,null,3,4,null,6);<br>nums.stream().filter(num -&gt; num != null).count();</integer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java8之Stream语法详解.&lt;/p&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;A sequence of elements supporting sequential 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/04/07/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86/"/>
    <id>http://HackerFreedom.github.io/2018/04/07/区块链知识/</id>
    <published>2018-04-07T11:45:43.334Z</published>
    <updated>2018-04-07T11:45:43.340Z</updated>
    
    <content type="html"><![CDATA[<p>区块链的实操到底是怎么样的原理？<br>物联网的建立，是点位的分布，点构成线，线构成面，串联出网状结构！</p><p>区块链的建立，个人观点是：每录入一个数据，就会创建一个区块。区块分为两部分：区块头，记录当前区块的信息；区块体，记录实际数据。而下一个区块的信息，必须通过上一个区块的信息计算出来，区块链就这样，由一个个彼此嵌合的区块构成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;区块链的实操到底是怎么样的原理？&lt;br&gt;物联网的建立，是点位的分布，点构成线，线构成面，串联出网状结构！&lt;/p&gt;
&lt;p&gt;区块链的建立，个人观点是：每录入一个数据，就会创建一个区块。区块分为两部分：区块头，记录当前区块的信息；区块体，记录实际数据。而下一个区块的信息，必须通过
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/04/07/spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
    <id>http://HackerFreedom.github.io/2018/04/07/spring中的事务/</id>
    <published>2018-04-07T11:16:22.050Z</published>
    <updated>2018-04-07T11:35:40.608Z</updated>
    
    <content type="html"><![CDATA[<p>什么是事务、事务特性、事务隔离级别、spring事务传播特性？</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是程序中一系列的增删改的过程</p><h1 id="事务的特性ACID"><a href="#事务的特性ACID" class="headerlink" title="事务的特性ACID"></a>事务的特性ACID</h1><ul><li>原子性（Atomicity）：对一件事务的操作的结果只有0和1，成功要么失败</li><li><p>一致性（Consistency）：事务的操作结果只有一个状态变成另一个状态，对于中断的事务结果就是处于不一致的状态</p></li><li><p>隔离性（Isolation）：一个事务的操作不能影响另一个事务的操作。</p></li><li>持久性（Durability）： 事务执行的结果一旦提交后，对数据的修改是永久性的。</li></ul><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><ul><li>read uncommited（读未提交）</li><li>read commited（读提交）</li><li>read repeatable（读重复，可以防止脏读，不可重复读）</li><li>serializable（序列化）</li></ul><p><em>这四个级别可以逐个解决脏读、不可重复读</em></p><p>脏读：就是说一个事务还提交，就被另一个事务读取到。（简单记就是无限开挂，）</p><p>不可重复读： 就是在一个事务提交之前，被另一个事务已经修改了，读到两次不同的数据。</p><h1 id="spring事务的传播特性"><a href="#spring事务的传播特性" class="headerlink" title="spring事务的传播特性"></a>spring事务的传播特性</h1><p><code>propagation_requierd</code>：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。<br><code>propagation_supports</code>：支持当前事务，如果没有当前事务，就以非事务方法执行。<br>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。<br>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。<br>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。<br>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与<code>propagation_required</code>类似的操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是事务、事务特性、事务隔离级别、spring事务传播特性？&lt;/p&gt;
&lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;p&gt;事务是程序中一系列的增删改的过程&lt;/p&gt;
&lt;h1 id=&quot;事务
      
    
    </summary>
    
    
  </entry>
  
</feed>
