<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TO BE BTTER ME</title>
  
  <subtitle>Hacker</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://HackerFreedom.github.io/"/>
  <updated>2018-03-02T06:16:31.809Z</updated>
  <id>http://HackerFreedom.github.io/</id>
  
  <author>
    <name>Sam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JSP和MVC模式</title>
    <link href="http://HackerFreedom.github.io/2018/03/01/jsp%E4%BB%8B%E7%BB%8D%E5%9F%BA%E7%A1%80/"/>
    <id>http://HackerFreedom.github.io/2018/03/01/jsp介绍基础/</id>
    <published>2018-03-01T07:11:00.000Z</published>
    <updated>2018-03-02T06:16:31.809Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="jsp介绍" scheme="http://HackerFreedom.github.io/categories/jsp%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="jsp介绍基础" scheme="http://HackerFreedom.github.io/tags/jsp%E4%BB%8B%E7%BB%8D%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java框架</title>
    <link href="http://HackerFreedom.github.io/2018/02/27/hibernate%E4%BC%98%E5%8C%96/"/>
    <id>http://HackerFreedom.github.io/2018/02/27/hibernate优化/</id>
    <published>2018-02-27T02:42:00.000Z</published>
    <updated>2018-03-04T02:25:13.842Z</updated>
    
    <content type="html"><![CDATA[<p>学习目标:</p><pre><code>能够使用HQL语句完成多表操作能够从概念、特点、隔离级别几个方面描述出对事务的理解记忆HQL优化的方法并能对一级缓存进行优化能够说出对hibernate中的抓取策略的理解，并能够配置各种抓取策略</code></pre><p>在这里我们首先要复习一下 sql语句的知识</p><h1 id="HQL多表操作"><a href="#HQL多表操作" class="headerlink" title="HQL多表操作"></a>HQL多表操作</h1><pre><code>1.交叉连接2.内连接    a)显示内连接    b)隐式内连接    *c)迫切内连接*3.外连接    左外连接    *迫切左外连接*    右外连接</code></pre><p><em>注意：在hibernate中有迫切连接的概念，而sql中没有。</em><br>掌握：           </p><pre><code>1. from Customer c join c.orders;    from Order o join o.c;2. 迫切和非迫切的区别：    1.非迫切返回对象数组，迫切直接返回对象    2.在一对多里面，这一条迫切的sql语句就完成了一方关联的多方数据的封装</code></pre><p>代码案例：<br>        @Test<br>        public void test3() {<br>        Query query = session<br>            .createQuery(“select distinct c from Customer c join fetch c.orders”);<br>            List<customer> list = query.list();<br>            for (Customer c : list) {</customer></p><pre><code>        System.out.println(c + &quot; &quot; + c.getOrders());}}</code></pre><p>非迫切对象：<br>        Test<br>        public void test1() {<br>        Query query = session.createQuery(“from Customer c left join c.orders”);<br>        List<object[]> list = query.list();<br>        for (Object[] objects : list) {<br>             System.out.println(objects[0] + “ “ + objects[1]);<br>        }<br>        }</object[]></p><h1 id="Hibernate的事务管理"><a href="#Hibernate的事务管理" class="headerlink" title="Hibernate的事务管理"></a>Hibernate的事务管理</h1><p><em>复习mysql的事务</em><br>1、事务：指的是一组逻辑操作，要么同时成功要么同时失败。<br>3、事务的四大特性：<br>原子性：组成事务的最小单元是不可分割的，要么同时成功要么同时失败。<br>一致性：执行事务前后，数据的完整性是一致的；（也就是案例中总钱数是一样的）<br>隔离性：在数据库中，各个事务之间是独立的，不受其他事务的影响。<br>持久性：事务一旦结束，数据就会持久保存到数据库中。</p><ol><li><p>事务的隔离级别</p><ol><li><p>脏读：一个事务读到了另一个事务未提交的数据<br>  不可重复读：一个事务读到了另一个事务已经提交的update数据<br>  虚读/幻读：一个事务读到了另一个事务已经提交的insert数据</p><ol><li>隔离级别<br>read uncommitted(未提交读)    ：脏读，不可重复读，虚读都有可能发生</li></ol><p>read committed(已提交读)    ：避免脏读。但是不可重复读和虚读是有可能发生</p><p>repeatable-read(可重复读)    ：避免脏读和不可重复读，但是虚读有可能发生。</p><p>serializable(串行化)        ：避免脏读，不可重复读，虚读。(mysql默认隔离级别) </p><h2 id="对于hibernate的事务隔离级别设置"><a href="#对于hibernate的事务隔离级别设置" class="headerlink" title="对于hibernate的事务隔离级别设置"></a>对于hibernate的事务隔离级别设置</h2><p>它可取的值有 1 2 4 8<br>1代表的事务隔离级别为READ UNCOMMITTED<br>2代表的事务隔离级别为READ COMMITTED<br>4.代表的事务隔离级别为 REPEATABLE READ<br>8代表的事务隔离级别为 SERIALIZABLE<br>在hibernate.cfg.xml文件中配置<br><property name="hibernate.connection.isolation ">4</property></p><h1 id="hibernate优化"><a href="#hibernate优化" class="headerlink" title="hibernate优化"></a>hibernate优化</h1></li></ol></li></ol><blockquote><p>1.使用参数绑定<br>使用绑定参数的原因是让数据库一次解析SQL,对后续的重复请求可以使用用生成好的执行计划，这样做节省CPU时间和内存；避免SQL注入<br>2.尽量少使用NOT<br>如果where子句中包含not关键字，那么执行时该字段的索引失效。<br>3.尽量使用where来替换having<br>Having在检索出所有记录后才对结果集进行过滤，这个处理需要一定的开销，而where子句限制记录的数目，能减少这方面的开销<br>4.减少对表的查询<br>在含有子查询的HQL中,尽量减少对表的查询，降低开销<br>5.使用表的别名<br>当在HQL语句中连接多个表时，使用别名，提高程序阅读性，并把别名前缀与每个列上，这样一来，可以减少解析时间并减少列歧义引起的语法错误。<br>6.实体的更新与删除<br>    @Test<br>    public void test11() {<br>        Query query = session.createQuery(“update Order set money=100”);<br>        query.executeUpdate();<br>    }</p></blockquote><h2 id="一级缓存优化"><a href="#一级缓存优化" class="headerlink" title="一级缓存优化"></a>一级缓存优化</h2><p>一级缓存也叫做session缓存，在一个hibernate session有效，这级缓存的可干预性不强，大多于hibernate自动管理，但它提供清除缓存的方法，这在大批量增加(更新)操作是有效果的，例如，同时增加十万条记录，按常规进行，很可能会出现异常，这时可能需要手动清除一级缓存，session.evict以及session.clear.</p><h3 id="检索策略"><a href="#检索策略" class="headerlink" title="检索策略"></a>检索策略</h3><p>延迟加载 是hibernate为提高程序执行的效率而提供的一种机制，lazy延迟加载：什么时候使用什么时候再去查询</p><h1 id="类级别延迟"><a href="#类级别延迟" class="headerlink" title="类级别延迟"></a>类级别延迟</h1><p>使用延迟加载的方法查询某个类的时候是否采用的延迟称为是类级别的延迟。默认值是true。<br>Customer customer = session.load(Customer.class,1l);// 默认就会采用延迟加载，这种称为是类级别的延迟。</p><p>#关联级别的延迟 #<br>查询到某个对象以后，获得其关联的对象。查询其关联对象的时候是否采用的延迟。称为是关联级别的延迟。<br>Customer c = session.get(Customer.class,1l);<br>c.getOrders(); // 查询关联对象的时候，是否采用延迟加载</p><p><em>关联级别的延迟往往会与抓取策略一起使用，优化程序。</em><br><em>（关联级别的延迟在<set>或者是<many-to-one>标签上的配置是否延迟加载）</many-to-one></set></em></p><h4 id="抓取策略"><a href="#抓取策略" class="headerlink" title="抓取策略"></a>抓取策略</h4><p>抓取策略指的是查找到某个对象后，抓取其关联的对象的时候采用的策略。<br>抓取策略就是在关联对象的配置上（<set>和<many-to-one>）配置<strong>fetch</strong>属性。</many-to-one></set></p><p>在set上的fetch和lazy</p><p>fetch:抓取策略，控制SQL语句的发送的格式。</p><ul><li>select    :默认值。发送一条select语句查询关联对象。</li><li>join    :发送一条迫切左外连接查询关联对象。</li><li>subselect    :发送一条子查询查询关联对象。</li></ul><p>lazy:延迟加载，控制SQL语句的发送的时候。</p><ul><li>true    :默认值。采用延迟加载。</li><li>false    :不采用延迟加载。</li><li>extra    :及其懒惰。</li></ul><p>在many-to-one上的fetch和lazy<br>fetch:抓取策略，控制SQL语句的发送的格式。</p><pre><code>* select    ：默认值.发送一条select语句查询关联对象。* join    ：发送一条迫切左外连接查询关联对象。</code></pre><p>lazy：延迟加载，控制SQL的发送的时机。</p><pre><code>* proxy    ：默认值。是否采用延迟，需要由另一方类上的延迟加载来决定。* false    ：不采用延迟加载。* no-proxy：不用研究</code></pre><h1 id="抓取策略的注解配置"><a href="#抓取策略的注解配置" class="headerlink" title="抓取策略的注解配置"></a>抓取策略的注解配置</h1><p>一方对应的多方订单<br><em>private Set<order> orders = new HashSet<order>();上的fetch和lazy</order></order></em><br>fetch:抓取策略，控制SQL语句的发送的格式。</p><ul><li>@Fetch(FetchMode.SELECT):默认值,发送一条select语句查询关联对象。</li><li>@Fetch(FetchMode.JOIN):发送一条迫切左外连接查询关联对象。</li><li>@Fetch(FetchMode.SUBSELECT):发送一条子查询查询关联对象。</li></ul><p><em>lazy:延迟加载，控制SQL语句的发送的时候。</em></p><ul><li>@LazyCollection(LazyCollectionOption.TRUE):默认值。采用延迟加载。</li><li>@LazyCollection(LazyCollectionOption.FALSE):不采用延迟加载。</li><li>@LazyCollection(LazyCollectionOption.EXTRA)    :及其懒惰。</li></ul><p>多方对应的唯一客户<br>private  Customer c; 上的fetch和lazy</p><p>fetch:抓取策略，控制SQL语句的发送的格式。</p><pre><code>* @Fetch(FetchMode.SELECT):默认值,发送一条select语句查询关联对象* @Fetch(FetchMode.JOIN):发送一条迫切左外连接查询关联对象。（这时如果配置了lazy会失效，且方案是立即查询）</code></pre><p>lazy：延迟加载，控制SQL的发送的时机。</p><pre><code>* @LazyToOne(LazyToOneOption.FALSE)：默认值,不采用延迟加载* @LazyToOne(LazyToOneOption.PROXY)：</code></pre><p>是否采用延迟，需要由另一方类上的延迟加载来决定    </p><ul><li>@LazyToOne(LazyToOneOption.NO_PROXY)：不用研究</li></ul><h2 id="多于批量抓取出现n-1的问题"><a href="#多于批量抓取出现n-1的问题" class="headerlink" title="多于批量抓取出现n+1的问题"></a>多于批量抓取出现n+1的问题</h2><p>例子：对于这个查询如果@Fetch(FetchMode.SELECT)会发送1+n条sql语句，1查询Customer自己，n查询每个Customer对应Order</p><p>查询多个对象的关联对象时，可以采用批量抓取方式来对程序进行优化.<br>要想实现批量抓取：<br>可以在配置文件中 batch-size属性来设置<br>可以使用注解 @BatchSize(size=4)—–为了减少select语句数目，可以设置<set>元素的batch-size属性<br>可以采用批量抓取来解决N+1问题.</set></p><p><strong>注意</strong>：<br>无论是根据哪一方来查询别一方，在进行批量抓取时，都是在父方来设置<br>如果是要查询子信息，那么我们是在<set>上来设置 batch-size,如果是从子方来查询父方，也是在父方设置在<class>设置 batch-size；</class></set></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习目标:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;能够使用HQL语句完成多表操作
能够从概念、特点、隔离级别几个方面描述出对事务的理解
记忆HQL优化的方法并能对一级缓存进行优化
能够说出对hibernate中的抓取策略的理解，并能够配置各种抓取策略
&lt;/code&gt;&lt;/pre&gt;&lt;p
      
    
    </summary>
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/categories/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="hibernate优化" scheme="http://HackerFreedom.github.io/tags/hibernate%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java框架</title>
    <link href="http://HackerFreedom.github.io/2018/02/27/hibernate%E7%BC%93%E5%AD%98/"/>
    <id>http://HackerFreedom.github.io/2018/02/27/hibernate缓存/</id>
    <published>2018-02-27T02:42:00.000Z</published>
    <updated>2018-03-04T01:22:46.508Z</updated>
    
    <content type="html"><![CDATA[<p>学习目标:</p><pre><code>记忆持久化类的编写规则能够使用主键生成策略生成主键   能够描述对一级缓存的理解能够描述出持久化对象能够修改数据的原因能够分析多表之间的三种关联关系，并且能设计三种关联关系的数据库表能够独立完成一对多关系的配置，并能完成级联保存能够清晰的描述出cascade和inverse的作用  </code></pre><h1 id="持久类和主键生成策略"><a href="#持久类和主键生成策略" class="headerlink" title="持久类和主键生成策略"></a>持久类和主键生成策略</h1><p> Hibernate中定义的主键类型包括：自然主键和代理主键<br>自然主键：具有业务含义 字段 作为主键，比如：学号、身份证号<br>代理主键：不具有业务含义 字段作为主键（例如 自增id），比如：mysql自增主键，oracle序列生成的主键、uuid()方法生成的唯一序列串</p><p> 手动生成主键: assigned （自然主键）<br>           hibernate生成主键：increment,uuid<br>           数据库生成主键：identity(mysql) sequence(orcale),  native(本地策略)</p><ul><li>increment <ul><li>优点:可以方便跨平台</li><li>缺点:不适合高并发访问</li></ul></li><li>identity<ul><li>优点:由底层数据库维护，和hibernate无关</li><li>缺点:只能对支持自动增长的数据库有效</li></ul></li><li><p>sequence </p><ul><li>优点:由底层数据库维护，和hibernate无关</li><li>缺点:数据库必须支持sequence方案例如oracle</li></ul></li><li><p>native </p><ul><li>优点:在项目中如果存在多个数据库时使用</li><li>缺点:效率比较低<h1 id="持久对象的三种状态"><a href="#持久对象的三种状态" class="headerlink" title="持久对象的三种状态"></a>持久对象的三种状态</h1></li></ul></li></ul><ol><li>瞬时态<ol><li>临时态或者自由态：无OID 与数据库中的信息无关联，不在session管理范围内。 </li></ol></li><li>持久态<ol><li>有OID 由session管理，在数据库中有可能有，也有可有没有。</li></ol></li><li>托管态<ol><li>游离态或者离线态  持久态对象失去了与session的关联，托管态对象它存在OID,在数据库中有可能存在，也有可能不存在</li></ol></li></ol><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>在session中定义了一系列的集合来存储数据，它们构成session缓存,只要session没有关闭，它就会一直存在。</p><p>当我们通过hibernate中的session提供的一些API例如 save  get  update等进行操作时，就会将持久化对象保存到session中，当下一次在去查询缓存中具有的对象(OID值来判断)，就不会去从数据库查询，而是直接从缓存中获取。</p><blockquote><p>Hibernate的一级缓存存在的目的就是为了减少对数据库访问。<br>    在hibernate中还有一个二级缓存，它是SessionFactory级别缓存。</p></blockquote><p><strong>注意的要点</strong></p><ol><li>当commit的时候比对一级缓存和快照数据是否一致，如果不一致就发送更新的sql语句到数据库更新数据</li><li>Hibernate对session的crud操作都会将数据缓存到一级缓存;只有oid查询（get/load）查询才会从一级缓存拿数据，其他查询就算一级缓存有数据任然会发  送sql语句查询，</li><li>session一级缓存不允许不同的对象有相同的oid<br> 异常：A different object with the same identifier value was already associated with the session</li><li>delete,update操作的托管对象如果oid在数据库没有该记录会报错<br> 异常： Batch update returned unexpected row count from update [0]; actual row count: 0;</li><li>持久化对象关联了一个瞬时对象<br> 异常： org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing:</li></ol><h1 id="数据对象的三种关系"><a href="#数据对象的三种关系" class="headerlink" title="数据对象的三种关系"></a>数据对象的三种关系</h1><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><ol><li>实体类 （注意提供一方和多方 的构造方法，）</li><li><p>配置（映射文件的配置）</p><ol><li>多方      <pre><code>&lt;many-to-one name=&quot;&quot; class=&quot;&quot; column=&quot;&quot;/ &gt; 实现多对一   name属性它描述的是Order类中的一的一方的属性名称 Customer c;   class 代表一的一方的全类名   column 描述的是一对多，在多的一方产生的外键的名称 c_customer_id</code></pre></li><li>一方<pre><code>&lt;set &gt;    &lt;key column=&quot;&quot;/&gt;        &lt;one-to-many class=&quot;&quot;&gt;    &lt;/set&gt;</code></pre>name属性就是set集合的属性名称<br>key:它主要描述关联的多的一方产生的外键名称，注意要与多的一方定义的外键名称相同<br>one-to-many的class描述集合中类的全类名</li></ol></li><li><p>级联 </p><pre><code>1. 级联发起方 需要关联被级联的一方    一方的Customer级联保存多方的Order条件：1.set上配置cascade=&quot;save-update&quot;2.一方关联被级联的多方Order（这时session保存的是客户）    c.getOrders().add(o1);    c.getOrders().add(o2);    多方的Order级联保存一方的Customer条件：    1.many-to-one配置cascade=&quot;save-update&quot;2.多方Order关联一方Customer  （这时session保存的订单）      o1.setC(c);        o2.setC(c);</code></pre><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习目标:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;记忆持久化类的编写规则
能够使用主键生成策略生成主键   
能够描述对一级缓存的理解
能够描述出持久化对象能够修改数据的原因
能够分析多表之间的三种关联关系，并且能设计三种关联关系的数据库表
能够独立完成一对多关系的配置，并能完成级
      
    
    </summary>
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/categories/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="hibernate缓存" scheme="http://HackerFreedom.github.io/tags/hibernate%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Java框架</title>
    <link href="http://HackerFreedom.github.io/2018/02/25/hibernate%E6%9F%A5%E8%AF%A2/"/>
    <id>http://HackerFreedom.github.io/2018/02/25/hibernate查询/</id>
    <published>2018-02-25T01:23:00.000Z</published>
    <updated>2018-02-25T14:16:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hibernate-框架"><a href="#hibernate-框架" class="headerlink" title="hibernate 框架"></a>hibernate 框架</h1><ul><li>session</li><li>hql查询</li><li>对象关系</li></ul><p>在hibernate核心配置文件中<br>create 创建表  会删除存在的表，有可能会丢失数据</p><blockquote><p> C:\ProgramData\Microsoft\Windows Defender</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>！<a href="/2018/02/25/hibernate查询/hibernate.png"></a>;</p><p><strong>查询语句的汇总</strong></p><pre><code>1.oid查询：（oid是对象标识符）Customer  c = session.get(Customer.class, 1);Customer  c = session.load(Customer.class, 1);2.hql查询Query query = session.createQuery(“from Customer”);from后面跟的是类名（domain中的类）List&lt;Customer&gt; list = query.list(); 分页：query.setFirstResult(0);query.setMaxResults(10);投影：Query query = session.createQuery(“select name,address from Customer”);List&lt;Object[]&gt; list = Query.list();投影封装：Query query = session.createQuery(“select  new Customer(name,address) from Customer”);//这里我们得到的是customer对象但是我们要，提供customer（含参） 构造方法</code></pre><p>   <em>list封装数据</em><br>     Query query = session<br>      .createQuery(“select new List(name,address) from Customer”);<br>   <em>map封装数据</em><br>     Query query = session<br>    .createQuery(“select new Map(name,address) from Customer”);</p><pre><code>条件:</code></pre><p><em>无名称的查询，？表示占位符</em><br>    Query query = session.createQuery(“from Customer where name=?”);<br>    query.setParameter(“0”, “波多”);<br><em>含名称的查询</em><br>    Query query = session.createQuery(“from Customer where name=:abc”);<br>    query.setParameter(“abc”, “波多”);<br>    3.sql查询 SQLQuery是Query的子.<br>    SQLQuery  sqlQuery = session.createSQLQuery(“select * from t_customer”);<br>    List<object[]> list = sqlQuery.list();<br>    //封装到Customer对象<br>    sqlQuery.addEntity(Customer.class);<br>    List<customer> list = Query.list();</customer></object[]></p><h1 id="criteria"><a href="#criteria" class="headerlink" title="criteria"></a>criteria</h1><p>Criteria接口与Query接口非常类似，允许创建并执行面向对象的标准化查询。值得注意的是Criteria接口也是轻量级的，它不能在Session之外使用。<br> 4.qbc<br>    Criteria qbc = session.createCriteria(Customer.class); //实体类.class得到的是一个这个类的对象<br>    List<customer> list  = qbc.list();<br>    qbc条件查询<br>    qbc.add(Restrictions.eq(“name”, “波多”));<br>    List<customer> list  = qbc.list();<br>    criteria.add(Restrictions.or(Restricitons.eq(),Restrictions.list()…..))<br>    我们使用Criteria可以更加面向对象去操作，它非常适合进行多条件组合查询。</customer></customer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hibernate-框架&quot;&gt;&lt;a href=&quot;#hibernate-框架&quot; class=&quot;headerlink&quot; title=&quot;hibernate 框架&quot;&gt;&lt;/a&gt;hibernate 框架&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;session&lt;/li&gt;
&lt;li&gt;hql查询&lt;/
      
    
    </summary>
    
      <category term="三大框架" scheme="http://HackerFreedom.github.io/categories/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="hibernate查询" scheme="http://HackerFreedom.github.io/tags/hibernate%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://HackerFreedom.github.io/2018/02/24/%E5%A4%A9%E6%B0%94api/"/>
    <id>http://HackerFreedom.github.io/2018/02/24/天气api/</id>
    <published>2018-02-24T02:51:30.102Z</published>
    <updated>2018-02-24T02:51:30.113Z</updated>
    
    <content type="html"><![CDATA[<pre><code>//通过中国天气api调用    private String getWeatherInfo2(){            StringBuilder info = new StringBuilder();            try {                    DefaultHttpClient httpclient = new DefaultHttpClient();                    HttpGet httget = new HttpGet(&quot;http://m.weather.com.cn/data/101050101.html&quot;);                    ResponseHandler&lt;String&gt; responseHandler = new BasicResponseHandler();                    String responseBody = httpclient.execute(httget, responseHandler);                    System.out.println(responseBody);                    JsonParser jp = new JsonParser();                    JsonElement jse = jp.parse(responseBody);                    JsonObject jso = jse.getAsJsonObject().get(&quot;weatherinfo&quot;).getAsJsonObject();//                        String updTime = jso.get(&quot;fchh&quot;).getAsString();//                        if(updTime != null){//                                //温度//                                String j = jso.get(&quot;temp1&quot;).getAsString();//今天//                                String m = jso.get(&quot;temp2&quot;).getAsString();//明天//                                //天气情况//                                String j_weather = jso.get(&quot;weather1&quot;).getAsString();//今天//                                String m_weather = jso.get(&quot;weather2&quot;).getAsString();//明天//                                //风向风力//                                String j_wind = jso.get(&quot;wind1&quot;).getAsString();//今天//                                String m_wind = jso.get(&quot;wind2&quot;).getAsString();//明天//                                info.append(&quot;今天：&quot;).append(j).append(&quot; &quot;).append(j_weather).append(&quot; &quot;).append(j_wind).append(&quot;\n&quot;);//                                info.append(&quot;明天：&quot;).append(m).append(&quot; &quot;).append(m_weather).append(&quot; &quot;).append(m_wind).append(&quot;\n&quot;);//                        }                    String updTime = jso.get(&quot;fchh&quot;).getAsString();                    if(updTime != null){                            if(!updTime.trim().equals(&quot;18&quot;)){                                    //温度                                    String j = jso.get(&quot;temp1&quot;).getAsString();//今天                                    String m = jso.get(&quot;temp2&quot;).getAsString();//明天                                    //天气情况                                    String j_weather = jso.get(&quot;weather1&quot;).getAsString();//今天                                    String m_weather = jso.get(&quot;weather2&quot;).getAsString();//明天                                    //风向风力                                    String j_wind = jso.get(&quot;wind1&quot;).getAsString();//今天                                    String m_wind = jso.get(&quot;wind2&quot;).getAsString();//明天                                    info.append(&quot;今天：&quot;).append(j).append(&quot; &quot;).append(j_weather).append(&quot; &quot;).append(j_wind).append(&quot;\n&quot;);                                    info.append(&quot;明天：&quot;).append(m).append(&quot; &quot;).append(m_weather).append(&quot; &quot;).append(m_wind).append(&quot;\n&quot;);                            }else{                                    //18                                    //温度                                    String temp1 = jso.get(&quot;temp1&quot;).getAsString();//今天                                    String temp2 = jso.get(&quot;temp2&quot;).getAsString();//今天                                    String temp3 = jso.get(&quot;temp3&quot;).getAsString();//今天                                    String j = temp1.split(&quot;~&quot;)[1] + &quot;~&quot; +  temp2.split(&quot;~&quot;)[0];                                    String m = temp2.split(&quot;~&quot;)[1] + &quot;~&quot; + temp3.split(&quot;~&quot;)[0];//明天                                    //天气情况                                    String weather1 = jso.get(&quot;weather1&quot;).getAsString();                                    String weather2 = jso.get(&quot;weather2&quot;).getAsString();                                    String weather3 = jso.get(&quot;weather3&quot;).getAsString();                                    String j_weather = &quot;&quot;;                                    String j_weather_part1 = &quot;&quot;;                                    String j_weather_part2 = &quot;&quot;;                                    //判断是否有转                                    if(weather1.indexOf(&quot;转&quot;) &gt; 0){                                            //有                                            j_weather_part1 = weather1.split(&quot;转&quot;)[1];                                    }else{                                            j_weather_part1 = weather1;                                    }                                    if(weather2.indexOf(&quot;转&quot;) &gt; 0){                                            //有                                            j_weather_part2 = weather2.split(&quot;转&quot;)[0];                                    }else{                                            j_weather_part2 = weather2;                                    }                                    if(j_weather_part1.equalsIgnoreCase(j_weather_part2)){                                            j_weather = j_weather_part1;//今天                                    }else{                                            j_weather = j_weather_part1 + &quot;转&quot; + j_weather_part2;//今天                                    }                                    String m_weather = &quot;&quot;;                                    String m_weather_part1 = &quot;&quot;;                                    String m_weather_part2 = &quot;&quot;;                                    //判断是否有转                                    if(weather2.indexOf(&quot;转&quot;) &gt; 0){                                            //有                                            m_weather_part1 = weather2.split(&quot;转&quot;)[1];                                    }else{                                            m_weather_part1 = weather2;                                    }                                    if(weather3.indexOf(&quot;转&quot;) &gt; 0){                                            //有                                            m_weather_part2 = weather3.split(&quot;转&quot;)[0];                                    }else{                                            m_weather_part2 = weather3;                                    }                                    if(m_weather_part1.equalsIgnoreCase(m_weather_part2)){                                            m_weather = m_weather_part1;//今天                                    }else{                                            m_weather = m_weather_part1 + &quot;转&quot; + m_weather_part2;//明天                                    }                     //风向风力                                    String j_wind = jso.get(&quot;wind2&quot;).getAsString();//今天                                    String m_wind = jso.get(&quot;wind3&quot;).getAsString();//明天                                    info.append(&quot;今天：&quot;).append(j).append(&quot; &quot;).append(j_weather).append(&quot; &quot;).append(j_wind).append(&quot;\n&quot;);                                    info.append(&quot;明天：&quot;).append(m).append(&quot; &quot;).append(m_weather).append(&quot; &quot;).append(m_wind).append(&quot;\n&quot;);                            }                    }            } catch (Exception e) {            }            return info.toString();    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;//通过中国天气api调用
    private String getWeatherInfo2(){
            StringBuilder info = new StringBuilder();
            try {
     
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="http://HackerFreedom.github.io/2018/02/18/IO%E6%B5%81%E6%80%BB%E7%BB%93/"/>
    <id>http://HackerFreedom.github.io/2018/02/18/IO流总结/</id>
    <published>2018-02-18T06:28:00.000Z</published>
    <updated>2018-02-18T06:43:30.361Z</updated>
    
    <content type="html"><![CDATA[<p>**</p><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="InputStream字节输入流"><a href="#InputStream字节输入流" class="headerlink" title="InputStream字节输入流"></a>InputStream字节输入流</h2><p>FileInputStream标准的字节输入流<br><em>一次读取一个字节数组</em><br>     BufferedInputStream: 该类实现缓冲的输入流</p><h3 id="OutputStream对象输入流"><a href="#OutputStream对象输入流" class="headerlink" title="OutputStream对象输入流"></a>OutputStream对象输入流</h3><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;**&lt;/p&gt;
&lt;h1 id=&quot;字节流&quot;&gt;&lt;a href=&quot;#字节流&quot; class=&quot;headerlink&quot; title=&quot;字节流&quot;&gt;&lt;/a&gt;字节流&lt;/h1&gt;&lt;h2 id=&quot;InputStream字节输入流&quot;&gt;&lt;a href=&quot;#InputStream字节输入流&quot; class
      
    
    </summary>
    
      <category term="I/O流" scheme="http://HackerFreedom.github.io/categories/I-O%E6%B5%81/"/>
    
    
      <category term="I/O流总结" scheme="http://HackerFreedom.github.io/tags/I-O%E6%B5%81%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Struts2 用法</title>
    <link href="http://HackerFreedom.github.io/2018/02/08/struts2/"/>
    <id>http://HackerFreedom.github.io/2018/02/08/struts2/</id>
    <published>2018-02-08T14:13:00.000Z</published>
    <updated>2018-02-27T00:50:55.129Z</updated>
    
    <content type="html"><![CDATA[<p>不会用，直接用<br>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。它使用一系列的合法元素来定义文档结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用</p><ul><li>框架的内容</li></ul><h1 id="java开发中常用的框架"><a href="#java开发中常用的框架" class="headerlink" title="java开发中常用的框架"></a>java开发中常用的框架</h1><p>ssh<br>ssm</p><h1 id="struts2框架的介绍"><a href="#struts2框架的介绍" class="headerlink" title="struts2框架的介绍"></a>struts2框架的介绍</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不会用，直接用&lt;br&gt;DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。它使用一系列的合法元素来定义文档结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;框架的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;java开
      
    
    </summary>
    
      <category term="Struts2框架" scheme="http://HackerFreedom.github.io/categories/Struts2%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Struts2" scheme="http://HackerFreedom.github.io/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Struts2 用法</title>
    <link href="http://HackerFreedom.github.io/2018/02/08/Struts2%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <id>http://HackerFreedom.github.io/2018/02/08/Struts2第二天/</id>
    <published>2018-02-08T14:13:00.000Z</published>
    <updated>2018-02-27T00:49:25.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Struts2中获取Servlet-API"><a href="#Struts2中获取Servlet-API" class="headerlink" title="Struts2中获取Servlet API"></a>Struts2中获取Servlet API</h1><p>简单的说，可以在action类中获取requent，response，session   。。。对象<br>HttpServletRequest request = ServletActionContext.getRequest();<br>HttpServletResponse response = ServletActionContext.getResponse();<br>ServletContext servletContext = ServletActionContext.getServletContext();</p><h1 id="OGNL-表达式"><a href="#OGNL-表达式" class="headerlink" title="OGNL 表达式"></a>OGNL 表达式</h1><p>OGNL 是Object-Graph Navigation Language (对象图导航语言） 的缩写，他是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类</p><ul><li>OGNL作用：<ol><li>支持对象的操作，调用对象的方法</li><li>支持静态成员访问</li><li>支持赋值操作与表达串联</li><li>访问OGNL上下文，访问ActionContext</li><li>操作集合对象。</li></ol></li></ul><p><strong>OGNL三要素： 表达式   OgnlContext上下文  Root根</strong></p><h2 id="ognal表达式介绍"><a href="#ognal表达式介绍" class="headerlink" title="ognal表达式介绍"></a>ognal表达式介绍</h2><p>在struts2框架中我们使用ognl表达式的作用是从valueStack中获取数据。</p><p>valueStack—-&gt;存放数据；ognl—-&gt;取数据，(类似于之前的request域存数据，el表达式取数据)</p><p>要想在jsp页面上使用ognl表达式，就需要结合struts2框架的标签<br><s:property value="”表达式”">来使用<br><img src="/2018/02/08/Struts2第二天/struts201" alt="">;<br>    <em>引入struts2标签</em><br>    &lt;%@ taglib uri=”/struts-tags” prefix=”s”%&gt;</s:property></p><pre><code>使用ognl表达式获取数据: &lt;s:property value=&quot;username&quot;/&gt;</code></pre><h1 id="valueStack值栈"><a href="#valueStack值栈" class="headerlink" title="valueStack值栈"></a>valueStack值栈</h1><p>valueStack的主要目的是为我将我们action中产生的数据携带到页面上，也就是说valueStack它就是一个存储数据的容器。</p><ol><li>valueStack基于ognl,作用是在struts2框架中来存储数据</li><li>浏览器发出请求request——&gt;创建ValueStack对象——-&gt;创建当前访问的Action对象</li></ol><h2 id="valuesStack内部结构的介绍"><a href="#valuesStack内部结构的介绍" class="headerlink" title="valuesStack内部结构的介绍"></a>valuesStack内部结构的介绍</h2><ol><li>valueStack主要有两部分组成:<br>CompoundRoot  root:       就是一个ArrayList<br>Map<string,object> context:  就是一个Map</string,object></li><li>struts2框架向root存放的数据<br>浏览器发出请求request—–&gt;创建当前访问的Action对象—–&gt;将Action对象push到root</li><li>struts2框架向context存放的数据<br>浏览器发出请求request——&gt;创建ValueStack对象之后，向context存放存储了一些引用，这个引用主要是关于web开发中相关信息，如<br>parameters :请求参数<br>request:请求对象中所有属性<br>session:会话对象中所有属性<br>application:ServletContext对象中的所有属性</li></ol><blockquote><p>在struts2框架中我们通过ognl表达式来获取valueStack中数据，没有使用#就会从CompoundRoot中获取数据，如果使用#来获取，这时就会从context中来获取.</p></blockquote><h2 id="valueStack获取"><a href="#valueStack获取" class="headerlink" title="valueStack获取"></a>valueStack获取</h2><p>ValueStack valueStack = ActionContext.getContext().getValueStack();</p><h2 id="valueStack-存储数据-重点）"><a href="#valueStack-存储数据-重点）" class="headerlink" title="valueStack 存储数据 (重点）"></a>valueStack 存储数据 (重点）</h2><p><strong>注意： 我们使用valueStack来存储数据时，主要向root存储</strong></p><ol><li>手动向valueStack存储数据<br>``<br> public String execute （）｛<br> ValueStack stack = ActionContext.getContext().getValueStack();<br> stack.set(“name”, “itheima”);<br> stack.push(“itcast”);<br> return “success”;<br> ｝</li></ol><p>valueStackpush方法,  直接将对象压入到root<br>valueStackset(“key”, “value”)方法,  创建一个Map压入到root，再把数据以健值对<k,v>的形式存放到这个map中</k,v></p><p>``</p><ol><li>struts2框架自动向valueStack中存储数据<ol><li>在框架源码的DefaultActionInvocation类的init方法内:<br> 首先创建了当前访问的Action对象，然后通过stack.push(action)将当前访问的Action对象存放到valueStack的root中，也就是每次请求访问action的时候，都会构造出action对象并将这个action对象存储到valueStack的root(ArrayList)中。</li><li>在浏览器访问action的时候ModelDrivernInterceptor这个拦截器会执行如下代码:<br>``<br>if(action instanceof ModelDrivern) {<pre><code>modelDriven model= (ModelDriven)  action;</code></pre> Object model = modelDriven.getModel();<br> if(model !=null) {<pre><code>stack.push(model);</code></pre>}<br><em>以上代码会判断当前访问的Action对象有没有实现ModelDriven这个接口，如果实现了这个接口就通过action对象已经实现的通过getModel方法获取模型对象存放到root(ArrayList)中</em></li></ol></li></ol><p>``</p><p>##valueStack中数据获取(重点) ##</p><ol><li><p>获取手动存放的数据<br> public String execute()  {<br> ValueStack stack = ActionContext.getContext().getValueStack();<br> stack.set(“name”, “itheima”);<br> stack.push(“itcast”);<br> return “success”;<br> }</p><p> 在jsp页面中获取以上代码手动存放的数据<br> <s:property value="name"><br> <s:property value="[0]">可以查看整个root结构数据<br> <s:property value="[0].top"><br>获取root顶部的对象<br> <s: debug=""> 视图中可以 查看action的属性</s:></s:property></s:property></s:property></p></li><li><p>获取自动存放的数据<br> public class ValueStackAction1 {<br> private String username = “fox”;<br> public String getUsername() {</p><pre><code>return username;</code></pre><p> }<br> public String getPwd() {</p><pre><code>return &quot;123&quot;;</code></pre><p> }<br> }</p><p> 在页面中获取以上自动存放的数据，为什么?<br> <s:property value="username"><br> <s:property value="pwd"></s:property></s:property></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Struts2中获取Servlet-API&quot;&gt;&lt;a href=&quot;#Struts2中获取Servlet-API&quot; class=&quot;headerlink&quot; title=&quot;Struts2中获取Servlet API&quot;&gt;&lt;/a&gt;Struts2中获取Servlet API&lt;/
      
    
    </summary>
    
      <category term="Struts2框架" scheme="http://HackerFreedom.github.io/categories/Struts2%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Struts2" scheme="http://HackerFreedom.github.io/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="http://HackerFreedom.github.io/2018/02/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://HackerFreedom.github.io/2018/02/06/面向对象的总结/</id>
    <published>2018-02-06T14:07:00.000Z</published>
    <updated>2018-02-07T10:20:30.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象的思想-（面试重点）"><a href="#面向对象的思想-（面试重点）" class="headerlink" title="面向对象的思想 （面试重点）"></a>面向对象的思想 （面试重点）</h1><ol><li>更符合我们的思维习惯</li><li>把复杂的问题简单化</li><li>把我们从执行者变为指挥者</li></ol><p><strong>面向对象的三大特性</strong></p><h1 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h1><pre><code>1. 是用private修饰方法封装起来的类    1. 作用：提高代码的复用性，和安全性</code></pre><ul><li><p><em>this关键字</em><br>代表对象，就是所在函数所指的对象引用</p><blockquote><p>一般用于构造函数的引用<br>调用格式 ： this. ()<br>this对象后面跟上 .调用是成员属性或者是方法<br>this（） 调用的是本类中对应参数的构造函数<br>注意：用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。否则编译失败。</p></blockquote></li><li><p><em>static关键词</em></p><ul><li>作用：<ol><li>想要实现对象中的共性数据的共享，可以将数据进行静态修饰</li><li>被static的成员方法，可以直接被类名直接调用，（类名. 静态方法）</li><li>静态随着类的加载而加载，且优先于对象的存在</li></ol></li><li>劣势：<ol><li>静态方法只能访问静态成员，不可以访问非静态成员</li><li>静态方法中不能使用this，super关键字（this代表是对象，而在静态时，有可能就没有对象）<br><strong>成员变量和静态变量区别</strong></li></ol></li></ul><ol><li>位置不同<ol><li>成员变量存在堆内存中，而静态变量存在于方法区中</li></ol></li><li>生命周期不同<ol><li>静态变量随着类的加载而存在，随着类的消失而消失</li><li>成员变量随着对象的创建而存在，随着对象被销毁而销毁</li></ol></li></ol></li></ul><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h1><pre><code>1. 子类可以访问父类的非私有成员变量和方法- 作用：        1.提高代码的复用性，    2. 使类和类之间产生了关系，是产生多态的一个前提</code></pre><ul><li><strong>继承特点</strong></li></ul><ol><li>单继承： 一个类只能有一个父类</li><li>多重继承： 一个父类可以被多个子类继承 A继承B  B继承C  C继承D。</li></ol><p><em>super关键词</em><br> 用来调用父类中的属性值</p><ul><li>为什么在子类的构造函数的第一行总是会加入super（）？<br>  在子类继承父类，会继承到父类的数据，所以必须要父类先要有数据的初始化，<br>  所以子类在进行对象初始化的时候，要先调用父类的构造函数，这就是子类的实例化过程</li><li><p><strong>注意</strong><br>super在每一个子类的构造方法中是默认在第一行的。<br>且和this关键字，两者只能出现一个。<em>一山容不下二虎的!!</em></p><h1 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h1><ol><li>函数就有多态性， 就是某一事物不同的具体表现</li></ol><ul><li>作用<ol><li>提高了程序的扩展性</li></ol></li><li>前提<ol><li>必须要有实现关系或者继承关系</li><li>必须要有方法的重写</li></ol></li></ul></li><li><p>方法的重写<br>  1、方法名、参数、返回值相同。</p></li></ul><p>　　 2、子类方法不能缩小父类方法的访问权限。(public&gt;protected&gt;default&gt;private）</p><p>　　 3、子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</p><p>　　 4、存在于父类和子类之间。</p><p>　　 5、方法被定义为final不能被重写。</p><p><em>final 特点</em></p><ol><li>这个关键词是一个修饰符，可以修饰类，方法，变量</li><li>被final修饰的类是一个最終类，不可以被继承</li><li>被final修饰的方法是一个最终的方法，不可以被重写</li><li><p>被final修饰的变量是一个常量，只能赋值一次<br><strong> 命名的规范：常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。</strong></p><ul><li>方法的重载<br>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。<br>重载Overloading是一个类中多态性的一种表现。<br> 1、参数类型、个数、顺序至少有一个不相同。 </li></ul><p>　　2、不能重载只有返回值不同的方法名。</p><p>　　3、存在于父类和子类、同类中。</p><ul><li>规则:</li></ul><ol><li>必须具有不同的参数列表；</li></ol></li></ol><ol><li><p>可以有不同的返回类型，只要参数列表不同就可以了；</p></li><li><p>可以有不同的访问修饰符；</p></li><li><p>可以抛出不同的异常；</p></li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol><li>定义： <ol><li>被abstract所修饰的类，</li></ol></li><li>特点： <ol><li>抽象方法只能定义在抽象类中， 抽象类也可以有非抽象的方法</li><li>抽象类不可以被创建对象（实例化）</li><li>只能通过子类继承或者实现的方法，才能使子类实例化</li></ol></li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol><li>定义：<br> 比抽象类还抽象的类，用关键词interface修饰</li><li>接口的特点：<ol><li>提高代码的可扩展性</li><li>规范并且约束了子类的行为（功能） </li></ol></li><li>接口中的成员的特点：<ol><li>成员变量：<br>接口中没有成员变量,只能由自定义常量; –&gt;因为接口中的方法没有方法体,所以没有地方给变量赋值;<pre><code>自定义常量的定义格式:</code></pre>public static final 数据类型 常量名 = 初始化值;</li><li>成员方法：<br>默认被 public abstract 所修饰;<pre><code>接口中的成员方法全部都是抽象方法;</code></pre></li><li>构造方法：<br>接口中没有构造方法,所以接口不能创建对象;</li></ol></li><li><p>接口和抽象类的区别:</p><pre><code>1.区别1:定义不同    接口:比抽象类还抽象的类;    抽象类:被abstract所修饰的类;2.区别2:构造方法        接口:没有构造方法,不能创建对象    抽象类:有构造方法,不能创建对象,但是可以给成员变量初始化;3.区别3:成员变量        接口:接口中没有成员变量只有自定义常量;    抽象类:可以有成员变量也可以有自定义常量;4.区别4:成员方法        接口:接口中的成员方法全部都是抽象方法;默认被 public 和 abstract  所修饰;    抽象类:可以有抽象方法也可以有非抽象方法;5.区别5:和类之间的关系:    接口:接口和类之间的关系是实现关系: implements    抽象类:抽象类和类之间的关系是继承关系: extends</code></pre><p><strong>总结各个类于接口的关系</strong><br>接口和类之间的关系:</p><pre><code>实现关系: implements格式:  public class 类名 implements 接口名1,接口名2....{            //实现接口中的抽象方法        }特点: 多实现,多层实现</code></pre><p> 接口和接口之间的关系:</p><pre><code>继承关系: extends格式:public interface 接口名 extends 接口名1,接口名2...{        }特点:多继承,多层继承</code></pre><p> 类和类之间的关系:</p><pre><code>继承关系: extends格式:    public class 类名 extends 类名1{    }特点:单一继承,多层继承;</code></pre></li></ol><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ol><li><p>局部代码块</p><ol><li>位置：<ol><li>方法内，for循环的大括号内，方法声明上</li></ol></li><li>作用： <ol><li>用于限定变量和对象的生命周期和作用域</li></ol></li></ol></li><li><p>构造代码块</p><ol><li>位置：<ol><li>成员位置-类中方法外</li><li>{<pre><code>//在类中方法外的代码块是构造代码块;</code></pre> }</li></ol></li><li>作用：<ol><li>抽取构造方法的共性，在每次创建对象前执行一次</li><li>执行次数:每创建一次对象就执行一次构造代码块;<br> 执行顺序:因为是对象产生的预加载;<pre><code>先执行构造代码块再执行构造方法;</code></pre></li></ol></li></ol></li><li><p>静态代码块</p><ol><li>位置：<ol><li>成员位置，类中方法外 且被static所修饰的</li></ol></li><li>作用：<ol><li>类的预加载，随着类的加载而加载，且执行一次<br>static{<pre><code>//在类中方法外并且被static修饰的代码块是静态代码块</code></pre> }<br>执行顺序:<br> 静态代码块 –&gt; 构造代码块 –&gt; 构造方法</li></ol></li></ol></li><li><p>同步代码块（多线程）<br> 同步代码块的格式：<br> synchronized(同步对象){<br> 需要同步的代码；<br> }s</p></li></ol><p>作用:<br>        维持多个线程在执行任务时的秩序,当一个线程没有完成任务的时候,另一个线程不能进入同步代码块;<br>    线程锁:<br>        这个锁对象可以是任意类型的对象,但是这个锁对象必须被所有的线程对象所共享;–&gt;必须在成员位置;<br>        一般情况下我们会在锁对象的位置上写一个this;</p><p>同步方法:被synchronized所修饰的方法是同步方法;<br>    同步方法也是有锁对象的;<br>    非静态的同步方法的锁对象就是this;<br>    静态的同步方法的锁对象是当前类的字节码对象;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象的思想-（面试重点）&quot;&gt;&lt;a href=&quot;#面向对象的思想-（面试重点）&quot; class=&quot;headerlink&quot; title=&quot;面向对象的思想 （面试重点）&quot;&gt;&lt;/a&gt;面向对象的思想 （面试重点）&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;更符合我们的思维习惯&lt;/li&gt;

      
    
    </summary>
    
      <category term="面向对象" scheme="http://HackerFreedom.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="面向对象的总结" scheme="http://HackerFreedom.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>oracle第四天</title>
    <link href="http://HackerFreedom.github.io/2018/02/06/oracle%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <id>http://HackerFreedom.github.io/2018/02/06/oracle第四天/</id>
    <published>2018-02-06T06:37:00.000Z</published>
    <updated>2018-02-06T13:03:08.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PL-SQL"><a href="#PL-SQL" class="headerlink" title="PL/SQL"></a>PL/SQL</h1><ul><li>什么是PL/sql<ul><li>pl/sql是oracle对sql语言的过程化扩展，指在sql命令语言中增加了过程处理语句。</li></ul></li></ul><ol><li><p>基本语法结构<br>  [declare<br> –声明变量<br> ]<br> begin<br> –代码逻辑<br> [exception<br> –异常处理<br> ]<br> end;</p><ol><li>变量<ol><li>声明变量的语法： 变量名 类型 （长度）；</li><li>变量赋值的语法： 变量名： =变量值；</li></ol><ul><li>案例需求：<br>声明变量水费单价、水费字数、吨数、金额。<br>对水费单价、字数、进行赋值 。吨数根据水费字数换算，规则为水费字数除以<br>1000，并且四舍五入，保留两位小数。计算金额，金额=单价*吨数。<br>输出单价 、数量和金额。</li></ul></li></ol><ul><li>变量的用法–<br>declare<br>  v_price number(10,2);–水费单价<br>  v_usenum number; –水费字数<br>  v_usenum2 number(10,2);–吨数<br>  v_money number(10,2);–金额<br>begin<br>  v_price:=2.45;–水费单价<br>  v_usenum:=8012;–字数<br>–字数换算为吨数<br>v_usenum2:= round( v_usenum/1000,2);<br>–计算金额<br>v_money:=round(v_price*v_usenum2,2);<br>dbms_output.put_line(‘单价：’||v_price||’吨<br>数:’||v_usenum2||’金额：’||v_money);<br>end;</li></ul></li><li>属性类型<ol><li>%TYPE引用型<br>作用引用某 表某列的字段类型。</li><li>%ROWTYPE 记录型<br> 作用 ：标识某个表的行记录类型</li></ol></li><li>异常<br>在运行程序时出现的错误叫做异常<br>发生异常后，语句将停止执行，控制权转移到 PL/SQL 块的异常处理部分<br>异常有两中类型：<br> 预定义异常 - 当 PL/SQL 程序违反 Oracle 规则或超越系统限制时隐式引发<br> 用户定义异常 - 用户可以在 PL/SQL 块的声明部分定义异常，自定义的<br> 异常通过 RAISE 语句显式引发</li><li>条件判断<ol><li>基础语法<br> if 条件 then<br> 业务逻辑<br> end if;</li></ol></li><li><p>循环</p><ol><li>无条件循环<br> 语法结构：<pre><code>loop    --循环语句end loop；</code></pre></li></ol><ul><li><p>eg 输出从1开始的100个数<br>  declare</p><p>  v_num number:=1;<br>  begin<br>  loop<br>  dbms_output.put_line(v_num);<br>  v_num:=v_num+1;<br>  exit when v_num&gt;100;<br>  end loop;<br>  end ;</p></li></ul><ol><li><p>条件循环<br> 语法结构：</p><pre><code>while 条件    loop    end loop；</code></pre><ul><li>eg 输出从1开始的100个数<br>declare<br>v_num number:=1;<br>begin<br>while v_num&lt;=100<br>loop<br>dbms_output.put_line(v_num);<br>v_num:=v_num+1;<br>end loop;<br>end ;</li></ul></li><li><p>for循环<br> 语法结构：</p><pre><code>for 变量 in 起始值。。终止值loopend loop；</code></pre><ul><li>eg 输出从1开始的100个数<br>declare<br>v_num number:=1;<br>begin<br>for v_num in 1..100<br>loop<br>dbms_output.put_line(v_num);<br>end loop;<br>end;</li></ul></li></ol></li><li><p>游标<br>游标是系统为用户开设的一个数据缓冲区,存放 SQL 语句的执行结果。 我们<br>可以把游标理解为 PL/SQL 中的结果集。</p><ol><li><p>语法构造：<br>cursor 游标名称 is sql语句</p><p>open 游标名称<br>loop<br>fetch 游标名称 into 变量<br>exit when 游标名称%notfound<br>end loop;<br>close 游标名称</p><ul><li>eg 需求：打印业主类型为 1 的价格表<br>declare<pre><code>v_pricetable T_PRICETABLE%rowtype;--价格行对象cursor cur_pricetable is select * from T_PRICETABLE whereownertypeid=1;--定义游标</code></pre>begin<pre><code>    open cur_pricetable;--打开游标loop    fetch cur_pricetable into v_pricetable;--提取游标到变量    exit when cur_pricetable%notfound;--当游标到最后一行下面退    出循环    dbms_output.put_line( &apos;价格:&apos;    ||v_pricetable.price ||&apos;吨位：    &apos;||v_pricetable.minnum||&apos;-&apos;||v_pricetable.maxnum );end loop;    close cur_pricetable;--关闭游标end ;        </code></pre></li></ul><ol><li>带参数的游标<br>我们的查询语句的条件值有可能是在运行时才能决定的，比如性业主类型，<br>declare<br>   v_pricetable T_PRICETABLE%rowtype;–价格行对象<br>   cursor cur_pricetable is select * from T_PRICETABLE where<br>   ownertypeid=1;–定义游标<br>begin<pre><code>open cur_pricetable（2）;--打开游标</code></pre>   loop<pre><code>fetch cur_pricetable into v_pricetable;--提取游标到变量exit when cur_pricetable%notfound;--当游标到最后一行下面退出循环dbms_output.put_line( &apos;价格:&apos;||v_pricetable.price ||&apos;吨位：&apos;||v_pricetable.minnum||&apos;-&apos;||v_pricetable.maxnum );</code></pre>   end loop;<pre><code>close cur_pricetable;--关闭游标</code></pre>   end ;</li><li>for循环提取游标值<br>我们每次提前游标，需要打开游标，关闭游标 循环游标 提取游标 控制循环，等等，很麻烦。所以用简便的做法<br>declare<br>cursor cur_pricetable(v_ownertypeid number) is select *<br>from T_PRICETABLE where ownertypeid=v_ownertypeid;–定义游<br>标<br>begin<br>for v_pricetable in cur_pricetable(3)<br>loop<br>dbms_output.put_line(‘价格:’||v_pricetable.price ||’吨<br>位：’||v_pricetable.minnum||’-‘||v_pricetable.maxnum );<br>end loop;<br>end ;<h2 id="存储函数-（oracle和mysql都有）"><a href="#存储函数-（oracle和mysql都有）" class="headerlink" title="存储函数 ##（oracle和mysql都有）"></a>存储函数 ##（oracle和mysql都有）</h2>存储函数又成为自定位函数，可以接受一个或者多个参数，返回一个结果。</li></ol></li></ol></li><li><p>存储函数语法结构</p><ol><li>创建或修改存储过程的语法：<br> CREATE [ OR REPLACE ] FUNCTION 函数名称<br> （参数名称 参数类型, 参数名称 参数类型, …）<pre><code>RETURN 结果变量数据类型</code></pre> IS<pre><code>变量声明部分;</code></pre> BEGIN<pre><code>逻辑部分;</code></pre> RETURN 结果变量;<pre><code>[EXCEPTION异常处理部分]</code></pre> END;<ul><li>eg 需求： 创建存储函数，根据地址 ID 查询地址名称<br>  create function fn_getaddress(v_id number)<pre><code>return varchar2</code></pre>  is<pre><code>v_name varchar2(30);</code></pre>  begin<pre><code>select name into v_name from t_address where id=v_id;return v_name;</code></pre>  end;<br>select fn_getaddress(3) from dual</li></ul></li></ol></li><li><p>存储过程<br>存储过程是被命名的pl/sql块，存储于数据库中，是数据库对象的一种。<br>存储过程与存储函数都可以封装一定的业务逻辑并返回结果，存在区别如<br>下：<br>1、 存储函数中有返回值，且必须返回；而存储过程没有返回值，可以通过<br>传出参数返回多个值。<br>2、 存储函数可以在 select 语句中直接使用，而存储过程不能。过程多数是<br>被应用程序所调用。<br>3、 存储函数一般都是封装一个查询结果，而存储过程一般都封装一段事务<br>代码。<br>-存储过程语法结构</p><ol><li><p>创建和修改存储过程的语法<br> CREATE [ OR REPLACE ] PROCEDURE 存储过程名称</p><pre><code>（参数名 类型, 参数名 类型, 参数名 类型）</code></pre><p> IS|AS</p><pre><code>变量声明部分;</code></pre><p> BEGIN</p><pre><code>逻辑部分[EXCEPTION异常处理部分]</code></pre><p> END;<br>参数只指定类型，不指定长度<br>过程参数的三种模式：<br> IN 传入参数（默认）<br> OUT 传出参数 ，主要用于返回程序运行结果<br> IN OUT 传入传出参数</p></li></ol></li></ol><ul><li><p>案例</p><ol><li>需求： 创建存储函数，根据地址 ID 查询地址名称。</li><li>创建不带传出参数的存储过程：添加业主信息</li></ol><ul><li>增加业主信息序列<br> create sequence seq_owners start with 11;</li><li>增加业主信息存储过程<br>create or replace procedure pro_owners_add<pre><code>(v_name varchar2,v_addressid number,v_housenumber varchar2,v_watermeter varchar2,v_type number)</code></pre>is<br>begin<br>insert into T_OWNERS<pre><code>values( seq_owners.nextval,v_name,v_addressid,v_housenumber,v_watermeter,sysdate,v_type );</code></pre>commit;<br>end;</li></ul></li></ul><p>pl/sql中调用存储过程<br>    call pro_owners_add(‘赵伟’,1,’999-3’,’132-7’,1);</p><p>JDBC调用存储过程</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><ol><li>什么是触发器<br>数据库触发器是一个于表相关联的，存储的pl/sql程序。每当一个特定的数据操作语句<br>（insert ，update，delete ）在指定的表发出时，Oracle自动的执行触发器中定义<br>的语句序列。</li><li><p>触发器</p><ol><li>数据确认</li><li>数据的备份</li><li>实施复杂的安全性检查</li></ol></li><li><p>触发器分类</p><ol><li>前置触发器</li><li>后置触发器</li></ol></li><li>创建触发器的语法<br> CREATE [or REPLACE] TRIGGER 触发器名<pre><code>BEFORE | AFTER[DELETE ][[or] INSERT] [[or]UPDATE [OF 列名]]</code></pre> ON 表名begin<pre><code>PLSQL [FOR EACH ROW ][WHEN(条件) ]</code></pre> declare<br> ……<pre><code>块</code></pre> End ；    </li></ol><p>**<br>    create function fn_getaddress(v_id number)<br>    return varchar2<br>    is<br>    v_name varchar2(30);<br>    begin<br>    select name into v_name from t_address where id=v_id;<br>    return v_name;<br>    end;</p><pre><code>2. 需求：查询业主 ID，业主名称，业主地址，业主地址使用刚才我们创建的函数来实现select id 编号,name 业主名称,fn_getaddress(addressid) 地址from t_owners</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PL-SQL&quot;&gt;&lt;a href=&quot;#PL-SQL&quot; class=&quot;headerlink&quot; title=&quot;PL/SQL&quot;&gt;&lt;/a&gt;PL/SQL&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是PL/sql&lt;ul&gt;
&lt;li&gt;pl/sql是oracle对sql语言的过程化扩展，指在sq
      
    
    </summary>
    
      <category term="Oracle的基础知识" scheme="http://HackerFreedom.github.io/categories/Oracle%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="oracle基础知识" scheme="http://HackerFreedom.github.io/tags/oracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>oracle</title>
    <link href="http://HackerFreedom.github.io/2018/02/02/ORACLE/"/>
    <id>http://HackerFreedom.github.io/2018/02/02/ORACLE/</id>
    <published>2018-02-02T07:34:00.000Z</published>
    <updated>2018-02-03T16:36:27.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="oracle的简介"><a href="#oracle的简介" class="headerlink" title="oracle的简介"></a>oracle的简介</h1><p>tabs 查询所有的表</p><p>中文乱码解决<br>1.检查服务器编码: 执行SQL语法: select * from v$nls_parameters; 如果不是中文则执行2 2.设置本地客户端编码: 进入 我的电脑,属性,高级,环境变量,添加2项:LANG=zh_CN.GBK 和 NLS_LANG=”SIMPLIFIED CHINESE_CHINA.ZHS16GBK” 3. PL/SQL Developer设置并重新连接: 在pl/sql developer的菜单-&gt;tools-&gt;preferences-&gt;user interface-&gt;fonts 中修改为中文字体 OK了。</p><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><ul><li><p>精确查找</p><p>  select * from T_owners where 条件</p></li><li><p>模糊查询<br>  select * from t_owners where name like’% 刘%’</p></li><li><p>and 运算符</p><p>  select * from t_owners where name like’% 刘%’and 条件</p></li><li><p>or 运算符</p><p>  select * from t_owners where name like’% 刘%’ or 条件</p></li><li><p>and和or运算符混用使用</p><p>  select *from  t_owners where（ name like’% 刘%’or 条件） and 条件 –由于and的优先级高</p></li><li><p>范围查询</p><p>  select * from t_account where usenum &gt;= 12313 and usenum &lt;22313</p></li><li>空值查询<br>  可以查询为空的记录<br>  select * from t_pricetable t where maxnum is not null</li><li><p>去掉重复记录</p><p>  select distinct addressid from t_owners<br><strong>distinct</strong></p></li><li><p>排序查询</p><ol><li><p>升序<br>默认</p></li><li><p>降序</p><p>select * from T_account order by usenum desc </p></li></ol></li></ul><p><strong>desc</strong></p><ul><li><p>伪列查询</p><ol><li><p><strong>ROWID</strong><br>获取每个数据的物理地址<br>select rowID ,t* form 地点 where 条件</p></li><li><p><strong>ROWNUM</strong><br>每次获取一行为 标识的一个行号<br>select rownum ,t*from </p></li></ol></li><li><p>聚合统计</p><ol><li><p>聚合函数</p><ul><li>sum 求和</li><li>avg 求平均数</li><li>max 求最大值</li><li>min 求最小值</li><li>count 求统计个数<ul><li>select count(*)from…where …</li></ul></li></ul></li><li><p>分组聚合Group by</p><ul><li>select areaid ,sum(money) from 表名 group by areaid </li></ul></li><li><p>分组后条件查询having</p><ul><li>select areaid ,sum(money) from 表名 group by areaid having 条件</li></ul></li></ol></li></ul><p><strong>总结</strong></p><p>select…from …where…group by…having</p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li>内连接</li><li></li><li>外连接<ol><li>左外连接查询</li><li>右外连接查询</li></ol></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li><p>单行子查询</p><ul><li>where 字句中的子查询<ol><li>只返回一条记录<ol><li>单行操作符  =    &gt;   &gt;=   &lt;    &lt;=   &lt;&gt;<br>select * from T_account where((条件包含条件)) </li></ol><ul><li>select 字句中的子查询</li></ul></li></ol></li></ul></li><li><p>多行子查询  in（范围） any all（记录允许多个记录）</p><ul><li><p>from字句中的子查询</p><p><em>关于多个表查询，先查两表关联的条件</em></p></li></ul></li><li><p>分页查询</p><ul><li>简单分页<ul><li>rownum  原理是按扫描的按顺序产生的，所以where条件不能用大于 或者等于</li></ul></li><li><p>基于排序分页</p></li><li></li></ul></li></ul><hr><p>子查询中空值的问题<br>      单行子查询的空值问题<br>    多行子查询中的null值问题<br>    如果表中有空值的话，不能用not in</p><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>行列转换</p><ul><li>单行函数</li></ul><ul><li>行列转化</li></ul><p>alter user scott account unlock；<br>alter user scott </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;oracle的简介&quot;&gt;&lt;a href=&quot;#oracle的简介&quot; class=&quot;headerlink&quot; title=&quot;oracle的简介&quot;&gt;&lt;/a&gt;oracle的简介&lt;/h1&gt;&lt;p&gt;tabs 查询所有的表&lt;/p&gt;
&lt;p&gt;中文乱码解决&lt;br&gt;1.检查服务器编码: 执行
      
    
    </summary>
    
      <category term="Oracle的基础知识" scheme="http://HackerFreedom.github.io/categories/Oracle%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="oracle基础知识" scheme="http://HackerFreedom.github.io/tags/oracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>oracle第三天</title>
    <link href="http://HackerFreedom.github.io/2018/02/02/oracle%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <id>http://HackerFreedom.github.io/2018/02/02/oracle第三天/</id>
    <published>2018-02-02T07:34:00.000Z</published>
    <updated>2018-02-05T13:27:07.560Z</updated>
    
    <content type="html"><![CDATA[<p>记录的结果是单行的，就是单行查询</p><p>#什么是视图  #<br> 视图是一种数据库对象，是从一个或者多个表达式或视图中导出的虚表，视图对应的数据并不真正地存储视图中。</p><ul><li><p>使用视图的优点：</p><ol><li>简化数据操作: 视图可以简化用户处理数据的方式。</li><li>着重于特定数据： 不必要的数据或敏感数据可以不出现在视图中</li><li>可以对于不同的用户进行限定访问。</li></ol></li><li><p>创建或修改视图语法<br>  create 【OR REPLACE】 [FORCE] VIEW view_name<br>  as subquery<br>  [wtth check option]<br>  [wtth reao only]</p><p>  OR REPLACE ：若所创建的试图已经存在，ORACLE 自动重建该视图；<br>  FORCE ：不管基表是否存在 ORACLE 都会自动创建该视图；<br>  subquery ：一条完整的 SELECT 语句，可以在该语句中定义别名；<br>  WITH CHECK OPTION ：插入或修改的数据行必须满足视图定义的约束；<br>  WITH READ ONLY ：该视图上不能进行任何 DML 操作。</p></li><li><p>删除视图语法<br>  DROP VIEW view_name</p></li><li><p>简单视图的创建和使用<br>只是单纯的单表查询，并没有聚合函数</p></li><li><p>带约束的视图<br>要注意我们只能修改带有除主键相关的数，因为修改不了。<br>会报错： ！<a href="/2018/02/02/oracle第三天/oracle01.png"></a>;</p></li><li><p>只读视图的创建于使用<br>创建语句时指定wtth read only 选项，如果如果要修改其中的语句，就会报错<br>！<a href="/2018/02/02/oracle第三天/oracle02.png"></a>;</p></li><li><p>创建带错误的视图<br>就是在不存在的表中给出提示</p></li></ul><ul><li>复杂的视图的创建和使用<br>所有复杂的视图，有聚合函数或者多表关联查询<br>！<a href="/2018/02/02/oracle第三天/oracle03.png"></a>;<br> <em>这里会遇到一个键保留列 的概念</em><br>  意思是说我们在视图中，该表中的主键会显示出来，而且是唯一非空的，也就是表的键值在一个连接着视图中也是键值，<br>  那么就称这个表为键保留表。<br>  所以非键保留表是不能更新的；</li></ul><p><em>主键的介绍</em><br>  关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键。<br>    主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。</p><pre><code>外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</code></pre><h2 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h2><ul><li>什么是物化视图<br>视图就是一个虚拟的表，基于它创建时指定的查询语句返回的结果集。（就是把一个每次访问都执行这个查询，封装起来，也叫实体化视图）</li></ul><ul><li><p><strong>创建物化视图 语法</strong></p><p>  CREATE meterialized VIEW view_name</p><p>  [BUILD IMMEDIATE | BUILD DEFERRED ]<br>  REFRESH [FAST|COMPLETE|FORCE]<br>  [<br>  ON [COMMIT |DEMAND ] | START WITH (start_time) NEXT<br>  (next_time)<br>  ]<br>  AS<br>  subquery</p><p>  BUILD IMMEDIATE 是在创建物化视图的时候就生成数据<br>  BUILD DEFERRED 则在创建时不生成数据，以后根据需要再生成数据。<br>  默认为 build immediate。<br>  刷新（refresh）：指当基表发生了 DML 操作后，物化视图何时采用哪种<br>  方式和基表进行同步。<br>  REFRESH 后跟着指定的刷新方法有三种： FAST、 COMPLETE、 FORCE。 FAST<br>  刷新采用增量刷新，只刷新自上次刷新以后进行的修改。<br>   COMPLETE 刷新对整个物化视图进行完全的刷新。<br>  如果选择 FORCE 方式，则 Oracle 在刷新时会去判断是否可以进行快速刷新，<br>  如果可以则采用 FAST 方式，否则采用 COMPLETE的方式。 FORCE 是默认的方式。</p><p>  刷新的模式有两种：ON DEMAND 和 ON COMMIT。<br>   ON DEMAND 指需要    手动刷新物化视图（默认）</p><pre><code>ON COMMIT 指在基表发生 COMMIT 操作时自动刷新。</code></pre></li></ul><ul><li><p>案例</p><ol><li><ol><li>创建手动刷新的物化视图<br>create materialized view mv_address<br>as<br>select ad.id ,ad.name adname,ar.name ar_name<br>form t_address ad  , t_area ar<br>where ad.areaid=ar.id</li></ol></li><li><ol><li>插入数据<br>insert into t_address values(8,’’,1,1);</li></ol></li><li><ol><li>要手动刷新物化视图，才能提交到数据<br>begin<br>  dbms_mview.refresh(‘mv_address’,’C’);<br>end;</li></ol></li></ol></li></ul><pre><code>    或者在命名行cmd中刷新物化视图    exec dbms_mview.refresh(&apos;mv_address&apos;,&apos;C&apos;)2. 1. 创建自动刷新的物化视图create materialized view mv_address refreshon commitas select ad.id ,ad.name adname,ar.name ar_nameform t_address ad  , t_area arwhere ad.areaid=ar.id创建此物化视图后，当 T_ADDRESS 表(基表）发生变化时，MV_ADDRESS2 自动跟着改变。 3. 1. 创建不生成数据的物化的视图create materialized view mv_address2 build deferredrefreshon commitas select ad.id ,ad.name adname,ar.name ar_nameform t_address ad  , t_area arwhere ad.areaid=ar.id3. 2. 查询结果为空3. 3. 执行下列语句后就生成了语句，由于创建是自动提交的刷新    begin         dbms_mview.refresh(&apos;mv_address2&apos;,&apos;C&apos;);    end 4. 1. 创建增量刷新的物化视图 4. 2. 如果要创建增量刷新的物化视图，必须首先要创建物化视图的日志     create materialized view log on t_address with rowid；    create materialized view log on t_area with rowid创建的物化视图日志名称为MLOG$_表名称    4. 3. 创建物化视图</code></pre><p><strong>注意创建增量的刷新的物化视图</strong></p><pre><code>1. 创建物化视图前提是要先创建物化视图的日志2. 在查询语句中，必须包含所有表的rowid（以towid方式建立物理化视图日志）3. 在物理化视图中，     SNAPTIME$$：用于表示刷新时间。    DMLTYPE$$：用于表示 DML 操作类型，I 表示 INSERT，D 表示 DELETE，U表示 UPDATE。OLD_NEW$$：用于表示这个值是新值还是旧值。 N（EW）表示新值，O（LD）表示旧值，U 表示 UPDATE 操作。CHANGE_VECTOR$$：表示修改矢量，用来表示被修改的是哪个或哪几个字段。此列是 RAW 类型，其实 Oracle 采用的方式就是用每个 BIT 位去映射一个列。插入操作显示为：FE, 删除显示为：OO 更新操作则根据更新字段的位置而显示不同的值键保留表的可以修改</code></pre><p><em>如果是自动刷新的话，在提交数据的时候会跳过日志，直接提交给视图中，</em></p><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><h3 id="什么是序列"><a href="#什么是序列" class="headerlink" title="什么是序列"></a>什么是序列</h3><p>序列是oracle中提供能产生唯一数字的数据库对象</p><h3 id="创建与使用"><a href="#创建与使用" class="headerlink" title="创建与使用"></a>创建与使用</h3><ul><li>创建序列语法：<ul><li>create sequence 序列名称</li><li>通过序列的伪列来访问序列的值<ul><li>nextval返回序列的下一值</li><li>currval 返回序列的当前值<br><em>注意：我们在刚建立序列后，无法提取当前值，只有先提取下一个值时才能再次提取当前值</em><br>提取下一个值<br>select 序列名.nextval from dual<br>提取当前值<br>select 序列名称.currval from dual</li></ul></li></ul></li><li>创建复杂序列<pre><code>CREATE SEQUENCE sequence //创建序列名称[INCREMENT BY n] //递增的序列值是 n 如果 n 是正数就递增,如果是负数就递减 默认是 1[START WITH n] //开始的值,递增默认是 minvalue 递减是 maxvalue[{MAXVALUE n | NOMAXVALUE}] //最大值[{MINVALUE n | NOMINVALUE}] //最小值[{CYCLE | NOCYCLE}] //循环/不循环[{CACHE n | NOCACHE}];//分配并存入到内存中</code></pre></li><li>案例<ol><li>有最大值的非循环序列<ol><li>创建序列语句：<br>create sequence seq_test1<br>increment by 10<br>start with 10<br>maxvalue 300<br>minvalue 20<br>以上的错误，是由于我们的开始值小于最小值 。开始值不能小于最小值，修改<br>create sequence seq_test1<br>increment by 10<br>start with 10<br>maxvalue 300<br>minvalue 5</li><li>有最大值的循环序列<br>create sequence seq_test2<br>increment by 10<br>start with 10<br>maxvalue 300<br>minvalue 5<br>cycle；</li></ol></li></ol></li></ul><p><em>循环的序列，第一次循环是从开始值开始循环，而第二次循环是从最小值开始循环。</em></p><ol><li><p>带缓存的序列：<br> create sequence seq_test3<br>   increment by 10<br>   start with 10<br>   maxvalue 300<br>   minvalue 5<br>   cycle<br>   cache 50;<br>我们缓存设定的值是 50，而最大值是 300，那么为什么还会提示这样的信息呢（CACHE must be less than one cycle）？<br>其实我们的 cache 虽然是 50，但是我们每次增长值是 10。这样 50 次缓存提取出<br>的数是 500 （50*10）</p><p>create sequence seq_test5<br>increment by 10<br>start with 10<br>maxvalue 501<br>minvalue 5<br>cycle<br>   cache 50;</p></li></ol><p><em>把最小值减 1，或把最大值加 1，都可以通过。</em></p><pre><code>4. 修改和删除序列    1. 修改序列：使用 ALTER SEQUENCE 语句修改序列，不能更改序列的 STARTWITH 参数    2. 删除序列： DROP SEQUENCE 序列名称;</code></pre><h4 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a>同义词</h4><p>同义词实质上就是指定方案对象的一个别名，，你可以创建公共同义词和私有同义词。其中，公共同义词属于 PUBLIC 特殊<br>用户组，数据库的所有用户都能访问；而私有同义词包含在特定用户的方案中，<br>只允许特定用户或者有基对象访问权限的用户进行访问<br>同义词本身不涉及安全，当你赋予一个同义词对象权限时，你实质上是在给<br>同义词的基对象赋予权限，同义词只是基对象的一个别名。</p><h4 id="创建使用同义词"><a href="#创建使用同义词" class="headerlink" title="创建使用同义词"></a>创建使用同义词</h4><ul><li><p>创建同义词的语法</p><p>  create 【public】 synonym for Object；<br>  其中 synonym 表示要创建的同义词的名称，object 表示表，视图，序列等我们要<br>  创建同义词的对象的名称。</p></li><li><p>案例</p><pre><code>`create synonym OWNERS for T_OWNERS;  使用同义词：select *from owners;`</code></pre></li><li>公有同义词 （所有用户都可以访问）</li><li>私有同义词 （只能被使用的用户调用访问）</li></ul><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul><li><p>什么是索引<br><em>索引是用于加速数据存取的数据对象。合理的使用索引可以大大降低 i/o 次数,从而提高数据访问性能</em><br>索引是有存储空间的，所以存储的每条记录都是有物理地址的，也就是我们rowid伪列</p></li><li><p>普通索引</p></li></ul><p>`create index 索引名称 on 表名(列名）``</p><p>索引性能的测试：<br><em>发现通过物理地址查询数据的效率高于通过普通索引</em>    </p><ul><li>唯一索引<ul><li>语法： `create unique index 索引名称 on 表名(列名）``</li></ul></li><li><p>复合索引</p><ul><li>语法： create index 索引名称 on 表名(列名。列名。。）``</li></ul><ul><li>反向键的索引<br>当某个字段的值为连续增长的值，如果构建标准索引，会形成歪脖子<br>树。这样会增加查询的层数，性能会下降。建立反向键索引，可以使索引的值变<br>得不规则，从而使索引树能够均匀分布。</li></ul></li></ul><ul><li><p>位图索引</p><p>位图索引适合创建在低基数列上<br><strong>优点</strong><br>减少响应时间，节省空间占用<br>create bitmap index 索引名称 on 表名（ 列名）</p></li></ul><p>物化视图，是不能upate</p><p>一次缓存的数量必须要小于一次</p><p>所以</p><p>序列：<br>    循环<br>        默认缓存想啊想和·cache 20<br>        缓存的数量小于一次循环的数量<br>索引：<br>只对 有特点的数据进行创建索引<br>    有特点的数据 （自增长的数据创建反向键索引比较合适）<br>    低基数创建位图索引标胶·比较合适</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录的结果是单行的，就是单行查询&lt;/p&gt;
&lt;p&gt;#什么是视图  #&lt;br&gt; 视图是一种数据库对象，是从一个或者多个表达式或视图中导出的虚表，视图对应的数据并不真正地存储视图中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用视图的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简化数据操作: 视图
      
    
    </summary>
    
      <category term="Oracle的基础知识" scheme="http://HackerFreedom.github.io/categories/Oracle%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="oracle基础知识" scheme="http://HackerFreedom.github.io/tags/oracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>hexo修改的地方</title>
    <link href="http://HackerFreedom.github.io/2018/02/01/hexo%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>http://HackerFreedom.github.io/2018/02/01/hexo修改的文件/</id>
    <published>2018-02-01T11:35:00.000Z</published>
    <updated>2018-02-02T01:53:53.460Z</updated>
    
    <content type="html"><![CDATA[<p>hexo clean #清除缓存 网页正常情况下可以忽略此条命令<br>hexo g #生成静态网页<br>hexo d #开始部署</p><p>npm install hexo -g #安装<br>npm update hexo -g #升级<br>hexo init #初始化</p><p>具体方法实现<br>切换到根目录下，然后运行如下代码</p><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><pre><code>$ npm install hexo-wordcount --save然后在/themes/next/layout/_partials/footer.swig文件尾部加上&lt;div class=&quot;theme-info&quot;&gt;  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;  &lt;span class=&quot;post-count&quot;&gt;博客全站共{{ totalcount &#40 site &#41 }}字&lt;/span&gt;&lt;/div&gt;</code></pre><p>这些异常一般是文章中使用了now（），小括号（）属于特殊字符，在编译文章时将now（）当函数处理了，结果找不到函数，就报错了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hexo clean #清除缓存 网页正常情况下可以忽略此条命令&lt;br&gt;hexo g #生成静态网页&lt;br&gt;hexo d #开始部署&lt;/p&gt;
&lt;p&gt;npm install hexo -g #安装&lt;br&gt;npm update hexo -g #升级&lt;br&gt;hexo init 
      
    
    </summary>
    
      <category term="Hexo教程" scheme="http://HackerFreedom.github.io/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo#文章標籤 可以省略" scheme="http://HackerFreedom.github.io/tags/hexo-%E6%96%87%E7%AB%A0%E6%A8%99%E7%B1%A4-%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>web阶段的总结</title>
    <link href="http://HackerFreedom.github.io/2018/01/31/web%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://HackerFreedom.github.io/2018/01/31/web阶段总结/</id>
    <published>2018-01-31T08:59:00.000Z</published>
    <updated>2018-02-01T11:25:29.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解什么是前端和后端"><a href="#理解什么是前端和后端" class="headerlink" title="理解什么是前端和后端"></a>理解什么是前端和后端</h1><p><img src="/2018/01/31/web阶段的总结/web01.jpg" alt="">;</p><p>更深刻的来说<br>就是java的三层架构：数据访问层（dao层） 业务逻辑层（service层） 界面层（ui）<br>Service 层–引用对应的dao数据库操作，业务逻辑层不仅可以处理自身需求的功能还可以调用dao层来完成扩展的功能，<br>这样确实是有利于开发和维护，同时也体现了MVC的设计模式中model层的功能体现。<br>Action层–&gt;引用对应的Service层，在这里结合Struts的配置文件，跳转到指定的页面，当然也能接受页面传递的请求数据，也可以做些计算处理、前端输入合法性检验(前端可修改网页绕过前端合法性检验，需在后台加一层)。</p><blockquote><p>Action像服务员，顾客点什么菜，菜上给几号桌，都是ta的职责，Service是厨师，action的菜单上的菜都是ta做<br>dao是厨房的小工，和原材料（通过hibernate操作数据库）打交道</p></blockquote><p><strong>对象调用的流程:jsp–action–service–dao–hebernate–数据库</strong></p><p>service 层在mvc框架中的<br>mvc框架由model，view，controller组成，执行流程一般是：在controller访问model获取数据，通过view渲染页面。<br>mvc模式是web开发中的基础模式，采用的是分层设计，各层之间职责分明。然而事与愿违，当我们日积月累的基于mvc模式开发之后，会逐渐的感受到层与层之间存在粘连和职责模棱两可的地方，这就是service层出现的重要原因。</p><p>在你设置hexo 背景图片的文件（/themes/next/source/css/_custom）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;理解什么是前端和后端&quot;&gt;&lt;a href=&quot;#理解什么是前端和后端&quot; class=&quot;headerlink&quot; title=&quot;理解什么是前端和后端&quot;&gt;&lt;/a&gt;理解什么是前端和后端&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/01/31/web阶段的总结/web01.j
      
    
    </summary>
    
      <category term="随笔" scheme="http://HackerFreedom.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="web阶段的总结" scheme="http://HackerFreedom.github.io/tags/web%E9%98%B6%E6%AE%B5%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Reflect&amp;Porxy</title>
    <link href="http://HackerFreedom.github.io/2018/01/29/Reflect/"/>
    <id>http://HackerFreedom.github.io/2018/01/29/Reflect/</id>
    <published>2018-01-29T06:01:02.000Z</published>
    <updated>2018-02-27T00:51:06.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h1><p>反射:简单说,就是动态加载一个类,并获取该类中的所有内容,并使用他们.(构造,成员变量,成员方法)<br><img src="/2018/01/29/Reflect/reflect01.png" alt="">;</p><p><em>优点</em></p><ol><li>反射提高程序的灵活性和扩展性；</li><li>降低耦合性，提高自适应能力；</li><li>它允许程序创建和控制任何类的对象，无序提前硬编码目标类</li></ol><p><em>缺点</em></p><ol><li>性能问题：使用反射基本是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li><li>使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，    反射代码比相应的直接代码更复杂。</li></ol><ul><li>java反射常用API<br><strong>class类的实例表示正在运行的java应用程序中的类和接口。枚举是一种类，注释是一种接口。</strong></li></ul><p>反射:动态加载一个类,得到Class对象,剖析Class对象,得到构造方法对象,成员变量对象,成员方法对象,并使用它们.<br>Class clazz = Class.forName(“com.itheima.Student”);<br>clazz.newInstance();</p><p>Student stu = new Student ();</p><h1 id="calss介绍及获取"><a href="#calss介绍及获取" class="headerlink" title="calss介绍及获取"></a>calss介绍及获取</h1><ul><li>获取class对象的三种方式<br>   class clazz=Class.forName(“”)</li></ul><p><img src="/2018/01/29/Reflect/reflect02.png" alt="">;</p><h1 id="Constructor介绍"><a href="#Constructor介绍" class="headerlink" title="Constructor介绍"></a>Constructor介绍</h1><ul><li>获取构造方法<ul><li>getConstructor（Class&lt;?&gt;…parameterTyps）</li><li>getDeclaredConstructor(Class&lt;?&gt;…parameterTypes);<br>总结: 有s获取多个,没s获取一个,Declared可获取private<br>最常用:<br>  Class.getConstructor().newInstance();<br>Class.newInstance()<h1 id="field介绍"><a href="#field介绍" class="headerlink" title="field介绍"></a>field介绍</h1><ul><li>获取成员变量</li><li>获取多个<br>getFields()<br>getDeclaredFields()    </li></ul></li><li>获取一个<br>  getField(“name”)<br>  getDeclaredField(“name”)<h1 id="Method获取介绍（重点-）"><a href="#Method获取介绍（重点-）" class="headerlink" title="Method获取介绍（重点 ）"></a>Method获取介绍（重点 ）</h1></li><li>获取成员方法</li><li>Class对象<br>Method  getMethod(String);<br>Method[]  getMethods(String);</li></ul></li></ul><p><strong>invoke方法介绍</strong><br><img src="/2018/01/29/Reflect/invoke01.png" alt="">;</p><p><em>invoke 参数1：方法所在的对象； 参数二：调用这个方法需要传递的参数   ；invoke 方法的返回值是被调用的方法的返回值</em></p><h1 id="method中-invoke方法使用注意事项"><a href="#method中-invoke方法使用注意事项" class="headerlink" title="method中 invoke方法使用注意事项"></a>method中 invoke方法使用注意事项</h1><p><em>如果方法是静态的，在通过invoke调用时不需要传递对象</em></p><p><img src="/2018/01/29/Reflect/invoke02.png" alt="">;<br><em>如果方法的参数是一个对象数组，通过invoke 调用要处理一下这个对象</em></p><p><img src="/2018/01/29/Reflect/invoke03.png" alt="">;<br>解决方案：强制转换类型<br>    将数组再套上一层数组</p><p><strong>反射总结</strong></p><blockquote><p>1.Class.forName(“包名.类名”);<br>2.Class.newInstance()<br>3.Class.getMethod(“方法名”).invoke(Object,args…);</p></blockquote><p><em>如何将map集合中的数据封装到JavaBean类中去</em></p><p><img src="/2018/01/29/Reflect/invoke04.png" alt="">;</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ol><li>静态代理：增强、包装、装饰者设计模式（Connection close、Request getParameter）</li><li>动态代理：Object Proxy.newProxyInstance(ClassLoader loader, Class [] interfaces, InvocationHandler h)</li></ol><h2 id="代理模式的介绍"><a href="#代理模式的介绍" class="headerlink" title="代理模式的介绍"></a>代理模式的介绍</h2><p>即proxyPatterm<br>代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。<br>总结来说就是，为其需找一个代替身（所谓影分身！！！）使其更加灵活，多变</p><p><strong>通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略（Spring的AOP机制），设计上获得更大的灵活性。</strong></p><ol><li>组成<br>抽象角色： 通过接口或者是抽象类声明真实角色实现的业务方法<br>代理角色： 实现抽象角色，是真实角色的代理<br>真实角色： 实现抽象角色，定义真实角色要实现的业务逻辑</li></ol><p>2.分类</p><ul><li>静态代理</li><li>动态代理</li><li><em>使用Proxy完成动态代理对象的创建</em><br>动态代理是在内存中直接生成代理对象<br><img src="/2018/01/29/Reflect/Proxy01.png" alt="">;</li></ul><ul><li><p><strong>java.lang.reflect.Proxy帮助我们完成动态代理创建</strong><br> // 方法 1: 该方法用于获取指定代理对象所关联的调用处理器<br> public static InvocationHandler getInvocationHandler(Object proxy) </p><p> // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象<br> public static Class&lt;?&gt; getProxyClass(ClassLoader loader,<br> Class&lt;?&gt;… interfaces)</p><p> // 方法 3：该方法用于判断指定类对象是否是一个动态代理类<br> public static boolean isProxyClass(Class&lt;?&gt; cl) </p><p> // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例<br> public static Object newProxyInstance(ClassLoader loader,<br>  Class&lt;?&gt;[] interfaces,InvocationHandler h)</p></li></ul><ul><li><p><strong>invocationHandler:调用处理器接口，自定义invokle方法，用于实现对于真正委托类的代理访问。</strong></p><p>  /<em>*<br>   该方法负责集中处理动态代理类上的所有方法调用。<br>   第一个参数既是代理类实例，<br>   第二个参数是被调用的方法对象<br>   第三个方法是调用参数，方法的参数。<br>   调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行  </em>/<br>  public Object invoke(Object proxy, Method method, Object[] args)<br>  throws Throwable;</p></li></ul><ul><li><strong>java.lang.ClassLoader：类装载器类</strong>，将类的字节码装载到 Java 虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy类与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。 </li></ul><h2 id="动态代理机制"><a href="#动态代理机制" class="headerlink" title="动态代理机制"></a>动态代理机制</h2><p>对于一个动态代理的创建<br>    使用Proxy.newProxyInestance（classloader，Interface,invocationHandler）<br><img src="/2018/01/29/Reflect/Proxy.png" alt="动态代理">;</p><p>总结</p><blockquote><p>1.创建一个接口(抽象角色)<br>2.创建一个实现类实现接口(真实角色)<br>3.创建一个测试类,在测试类中,创建真实对象<br>a)创建代理对象(Proxy.newProxyInstance)<br>b)调用代理对象的方法</p><p>掌握Proxy.newProxyInstance()方法的使用(理解各参数的意义,返回值）</p></blockquote><h3 id="注解概述"><a href="#注解概述" class="headerlink" title="注解概述"></a>注解概述</h3><ol><li>注解的作用</li></ol><p><img src="/2018/01/29/Reflect/annotation01.png" alt=""></p><ol><li>java基本内置注解</li></ol><ul><li>@override实现或者重写父类或接口中的方法</li><li>@Deprecated用来标识过时的方法</li><li>@SupperssWarnnings(“all”)取消警告</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是一种基本注解，但是它是特殊的注解的标记，作用和目的就是给其他的普通注解进行解释说明</p><p><strong>元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。</strong></p><ul><li>@Retention</li></ul><p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。</p><blockquote><p>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。<br> RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。<br>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们</p></blockquote><ul><li>@Documented</li></ul><p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。</p><ul><li><p>@Target<br>当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。</p><blockquote><p><strong>ElementType.ANNOTATION_TYPE</strong> 可以给一个注解进行注解<br>ElementType.CONSTRUCTOR 可以给构造方法进行注解<br><strong>ElementType.FIELD</strong> 可以给属性进行注解<br>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解<br><strong>ElementType.METHOD</strong> 可以给方法进行注解<br>ElementType.PACKAGE 可以给一个包进行注解<br>ElementType.PARAMETER 可以给一个方法内的参数进行注解<br>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</p></blockquote></li><li><p>@Inherited<br>Inherited 是继承的意思<br>注解Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。</p></li><li><p>@Repeatable<br>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射介绍&quot;&gt;&lt;a href=&quot;#反射介绍&quot; class=&quot;headerlink&quot; title=&quot;反射介绍&quot;&gt;&lt;/a&gt;反射介绍&lt;/h1&gt;&lt;p&gt;反射:简单说,就是动态加载一个类,并获取该类中的所有内容,并使用他们.(构造,成员变量,成员方法)&lt;br&gt;&lt;img src=
      
    
    </summary>
    
      <category term="反射" scheme="http://HackerFreedom.github.io/categories/%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="反射基本知识" scheme="http://HackerFreedom.github.io/tags/%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>p2p项目</title>
    <link href="http://HackerFreedom.github.io/2018/01/28/p2p%E9%A1%B9%E7%9B%AE%E6%80%9D%E8%B7%AF/"/>
    <id>http://HackerFreedom.github.io/2018/01/28/p2p项目思路/</id>
    <published>2018-01-28T06:34:31.000Z</published>
    <updated>2018-02-27T00:53:51.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="账户中心-产品购买"><a href="#账户中心-产品购买" class="headerlink" title="账户中心-产品购买"></a>账户中心-产品购买</h2><p>思路分析：： 产品购买，首先要对产品进行查询，在p2p_home中要查询产品信息，在p2p_management中提供<br>产品的CRUD操作，文档说要用到跨域（但是跨域的概念是 服务器中的端口 协议  不同）</p><ol><li>用户的账户表中信息一定要改变</li><li>在product_account 中间表中插入 money 和 interest的字段名；</li></ol><p><em>整体思路</em></p><ol><li>产品信息要在moto.html中展现出来</li><li>moto.js文件中拼装</li><li><p>moto.html中产品信息生成 （在我要购买提加点击事件onclick） 写函数的时候看是否有参数是看在servlet是否需要参数接受<br>然后处理购买后的数据（）<br>配置结果–本金/</p></li><li><p>完成购买操作（金额 和产品信息传递给服务器，在服务器进行操作，修改账户信息，向product——account 修改账户信息，）</p></li><li><p>修改账户信息，向product_account表中插入数据（敏感数据的处理（bigdecimal的处理））</p></li><li>在product中插入数据  根据pid查询查询产品</li><li><p>attar  prop 是什么属性</p><p> 多表联查；</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;账户中心-产品购买&quot;&gt;&lt;a href=&quot;#账户中心-产品购买&quot; class=&quot;headerlink&quot; title=&quot;账户中心-产品购买&quot;&gt;&lt;/a&gt;账户中心-产品购买&lt;/h2&gt;&lt;p&gt;思路分析：： 产品购买，首先要对产品进行查询，在p2p_home中要查询产品信息，在
      
    
    </summary>
    
      <category term="金融p2p项目" scheme="http://HackerFreedom.github.io/categories/%E9%87%91%E8%9E%8Dp2p%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="p2p项目" scheme="http://HackerFreedom.github.io/tags/p2p%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>面试-试题</title>
    <link href="http://HackerFreedom.github.io/2018/01/28/%E9%9D%A2%E8%AF%95/"/>
    <id>http://HackerFreedom.github.io/2018/01/28/面试/</id>
    <published>2018-01-28T06:15:14.000Z</published>
    <updated>2018-03-05T06:09:37.841Z</updated>
    
    <content type="html"><![CDATA[<ol><li><em>**</em>Spring的DI是什么（学员注：除了IOC，AOP这些概念，还不太清楚DI的概念）</li><li>*任意数字序列”123456”之类，输出它们所有的排列组合</li><li><p><strong>*</strong>什么是AOP（学员注：会用，但感觉说不清楚）<br>我注：由上面这些题，可以看出，思想很重要，只有琢磨思想和原理的人才能很好地回答这些问题！</p><p> String str = “xafdvs”;<br> char[] arr1 = str.toCharArray();<br> char[] arr2 = Arrays.copyOf(arr1,arr1.length);<br> for(int i=0;i&lt;arr1.length-1;i++)<br> {<br> for(int j = i+1;j&lt;arr2.length;j++){<br> syso: arr1[i] + “,” + arr2[j];<br> }<br> }</p></li></ol><p>1.概念介绍：所谓AOP，即Aspect orientied program,就是面向方面的编程，<br>2.解释什么是方面：贯穿到系统的各个模块中的系统一个功能就是一个方面，<br>比如，记录日志，统一异常处理，事务处理，全限检查，这些功能都是软件系统<br>的一个面，而不是一点，在各个模块中都要出现。<br>3.什么是面向方面编程：把系统的一个方面的功能封装成对象的形式来处理<br>4.怎么进行面向方面编程：把功能模块对应的对象作为切面嵌入到原来的各个系统模块中，<br>采用代理技术，代理会调用目标，同时把切面功能的代码（对象）加入进来，所以，<br>用spring配置代理对象时只要要配两个属性，分别表示目标和切面对象（Advisor）。</p><p>多线程的<br>异常</p><p>事务回滚</p><p>事务的隔离<br>Serializable </p><p>容器<br>Collections是容器的工具类<br>Collection是</p><p>反射</p><p>乐观锁、aop、js加密、防止表单重复提交、springboot</p><p>Java集合类框架的基本接口有哪些</p><p>json和json 阿里中的区别</p><p>内连接和外连接</p><p>三种状态的概述（hibernate）</p><p>你只需要努力，加油！！</p><p>ogm格式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;em&gt;**&lt;/em&gt;Spring的DI是什么（学员注：除了IOC，AOP这些概念，还不太清楚DI的概念）&lt;/li&gt;
&lt;li&gt;*任意数字序列”123456”之类，输出它们所有的排列组合&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;*&lt;/strong&gt;什么是AOP（学
      
    
    </summary>
    
      <category term="面试" scheme="http://HackerFreedom.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://HackerFreedom.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Cookie-Session</title>
    <link href="http://HackerFreedom.github.io/2018/01/28/Cookie-Session/"/>
    <id>http://HackerFreedom.github.io/2018/01/28/Cookie-Session/</id>
    <published>2018-01-28T06:15:14.000Z</published>
    <updated>2018-02-27T02:41:18.161Z</updated>
    
    <content type="html"><![CDATA[<p>DDL是tra  删除命令，没有事务回滚</p><h1 id="会话技术的概述"><a href="#会话技术的概述" class="headerlink" title="会话技术的概述"></a>会话技术的概述</h1><p>简单来说，就是用户打开浏览器，访问web资源，然后关闭浏览器的整个过程。而用户每次访问留下的数据，就需要<br>我们用会话技术来保存了。</p><p><img src="/2018/01/28/Cookie-Session/main01.png" alt="requset请求的数据保存">;</p><h1 id="会话技术的实现原理"><a href="#会话技术的实现原理" class="headerlink" title="会话技术的实现原理"></a>会话技术的实现原理</h1><ul><li>会话技术的分类<ol><li>会话技术分为cookie 和session <ul><li>cookie属于客户端技术<br> 通过响应头的形式来保存信息</li><li>session属于服务端技术<br> 会在服务器中开辟一处空间来存储数据<br><strong>cookie和session的区别</strong><br>   cookie是把数据保存到浏览器中，session是把数据存储到服务器中</li></ul></li></ol></li><li>Cookie和Session的实现原理<br><img src="/2018/01/28/Cookie-Session/main02.png" alt="cookie和session的实现">;<br><img src="/2018/01/28/Cookie-Session/main03.png" alt="cookie和session的实现">;</li></ul><h2 id="获取Cookie的方法"><a href="#获取Cookie的方法" class="headerlink" title="获取Cookie的方法"></a>获取Cookie的方法</h2><pre><code>- 创建一个cookie1. getName () 返回Cookie的key2. getValue（） 3. setValue- 保存一个cookie1. addcookie() -- HttpServletResponse接口的方法- 获取一个cookie1. getCookies()  --HttpServletRequest接口的方法</code></pre><p><em>可以记录用户第一次访问的时间，用Cookies的方法</em><br><img src="/2018/01/28/Cookie-Session/cookie01.png" alt=""></p><h2 id="Cookie的分类"><a href="#Cookie的分类" class="headerlink" title="Cookie的分类"></a>Cookie的分类</h2><ul><li><em>会话级别的Cookie</em><br>  顾名思义，它存在的时间默认是一次会话，直到关闭浏览器</li><li><em>持久化的Cookie</em><ul><li>见明知意，它是设置Cookie的有效时间，数据会被序列化，既存储在硬盘上了；</li></ul></li></ul><p><img src="/2018/01/28/Cookie-Session/cookie02.png" alt="cookie的设置"></p><p><strong>Cookies要注意的点</strong><br>1 浏览器存储cookie有大小和个数的限制，各种浏览器不宜<br>2、cookie默认是一次会话结束就消失，但是要删除持久化的cookie，只需要调用setMaxAge(0);<br><em>但是要设置cookie相同的path</em></p><h3 id="Session的概述"><a href="#Session的概述" class="headerlink" title="Session的概述"></a>Session的概述</h3><p>Session称为是一次会话，Cookie将用户产生的私有数据保存到浏览器端，而Session将用户产生的私有的数据保存到服务器端</p><p>cookie和session的区别<br>Cookie的局限性：</p><ul><li>Cookie保存的数据是有个数和大小的限制的。<ul><li>数据是保存客户端浏览器上（相对不是很安全）</li></ul></li></ul><p>session:</p><pre><code>- Session没有个数和大小限制- 数据保存到服务器上</code></pre><p><strong>Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到Session对象</strong></p><h3 id="Session的原理"><a href="#Session的原理" class="headerlink" title="Session的原理"></a>Session的原理</h3><p>Session其实是基于Cookie实现的，因为服务器会将一个唯一的SessionId写到Cookie里面，响应给浏览器，浏览器再次访问服务器(浏览器不关闭)会带着这个Cookie里面的SessionId来找到对应的区域数据。</p><p>保存sessionID的cookie默认是会话级别的,只存在于浏览器的内存中,浏览器窗口关了就没了。</p><h3 id="Session作为域对象存储数据"><a href="#Session作为域对象存储数据" class="headerlink" title="Session作为域对象存储数据"></a>Session作为域对象存储数据</h3><p>Session作为域对象的API</p><ul><li>setAttribute (string name,Object value)  存入数据</li><li>getAttribute(String name)   获取数据</li><li>removeAttribute(String name)   移除数据</li></ul><h3 id="Servlet数据访问范围的总结"><a href="#Servlet数据访问范围的总结" class="headerlink" title="Servlet数据访问范围的总结"></a>Servlet数据访问范围的总结</h3><pre><code>1、请求范围（ServletRequest） a)、何时创建和销毁的创建：当用户向服务器发送一次请求，服务器创建一个request对象。销毁：当服务器对这次请求作出了响应，服务器就会销毁这个request对象。b)、如何存取数据存数据：void setAttribute(String name,Object value);取数据：Object getAttribute(String name);c)、作用范围：一次请求。（转发就是一次请求）。2、会话范围（HttpSession）a)、何时创建和销毁的创建：服务器端第一次调用getSession()方法的时候。(测试访问jsp.html,servlet)销毁：三种情况。①、Session过期，默认的过期时间30分钟(web.xml中配置)。②、非正常关闭服务器。（正常关闭服务器—session会被序列化）。③、手动调用session.invalidate();b)、如何存取数据存数据：void setAttribute(String name,Object value);取数据：Object getAttribute(String name);c)、作用范围：一次会话（多次请求）3、应用范围（ServletContext）a)、何时创建和销毁的创建：服务器启动的时候创建，为每个web项目创建一个单独ServletContext对象。 销毁：服务器关闭的时候，或者项目从服务器中移除的时候。b)、如何存取数据存数据：void setAttribute(String name,Object value);取数据：Object getAttribute(String name);c)、作用范围：整个应用</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DDL是tra  删除命令，没有事务回滚&lt;/p&gt;
&lt;h1 id=&quot;会话技术的概述&quot;&gt;&lt;a href=&quot;#会话技术的概述&quot; class=&quot;headerlink&quot; title=&quot;会话技术的概述&quot;&gt;&lt;/a&gt;会话技术的概述&lt;/h1&gt;&lt;p&gt;简单来说，就是用户打开浏览器，访问web资源
      
    
    </summary>
    
      <category term="缓存技术" scheme="http://HackerFreedom.github.io/categories/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Cookie-Session基础" scheme="http://HackerFreedom.github.io/tags/Cookie-Session%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>jsp&amp;el&amp;jstl</title>
    <link href="http://HackerFreedom.github.io/2018/01/28/jsp-el-jstl/"/>
    <id>http://HackerFreedom.github.io/2018/01/28/jsp-el-jstl/</id>
    <published>2018-01-28T06:15:14.000Z</published>
    <updated>2018-02-27T02:39:00.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="jsp的基本介绍"><a href="#jsp的基本介绍" class="headerlink" title="jsp的基本介绍"></a>jsp的基本介绍</h2><p>Servlet技术生成动态网页的时候很麻烦，需要通过response获得输出流，调用print方法进行打印的。这种编程方式很麻烦，而且美工也不容易处理。SUN公司为了简化动态网页开发，推出JSP</p><ul><li><p>JSP脚本元素<br>&lt;%!    %&gt;    :JSP声明 翻译成 Servlet成员部分的内容。声明变量，方法，内部类。<br>&lt;%= %&gt;    :翻译out.print(),在service方法内部。用于生成HTML页面源码。<br>&lt;%    %&gt;    :嵌入Java代码 翻译成service方法内部的代码块。声明变量，内部类</p></li><li><p>JSP的运行原理<br>JSP在执行时，会被服务器翻译为Servlet编译执行，JSP就是一个Servlet。</p></li></ul><h2 id="JSP的指令元素的概述"><a href="#JSP的指令元素的概述" class="headerlink" title="JSP的指令元素的概述"></a>JSP的指令元素的概述</h2><ul><li>Jsp有如下三大指令：<blockquote><p>page指令：用来设置jsp页面的某些属性和行为的；例如设置字符集等。。。<br>include指令：用来设置jsp页面包含哪些其他页面。<br>taglib指令：用来设置jsp页面引入了哪些标签库。</p></blockquote></li></ul><h2 id="Page指令属性"><a href="#Page指令属性" class="headerlink" title="Page指令属性"></a>Page指令属性</h2><blockquote><p>import属性：        用于导入Java包或类。<br>一次导入多个包&lt;%@ page import=”java.util.Date , java.util.List” %&gt;<br>contentType属性：标明JSP被浏览器解析和打开的时候采用的默认的字符集。<br>pageEncoding属性：JSP文件及JSP翻译后的Servlet保存到硬盘上采用字符集。</p></blockquote><p>##JSP的指令-include和taglib指令  ##</p><ul><li>include指令作用：用来设置jsp页面静态包含其他页面</li><li>2、include指令包含（静态包含）的原理和注意事项：<br><strong> 相当于代码复制,多个JSP会被翻译成一个Servlet</strong><br>  <img src="/2018/01/28/jsp-el-jstl/jsp01.png" alt="">;<br>  注意地方：<br>  应该将被包含的页面的结构去掉。<br>  在被包含的页面中定义变量，在包含的页面中还可以使用。</li></ul><h2 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h2><p><strong>内置对象就是可以在JSP页面中直接使用的对象。</strong></p><blockquote><p>request：客户端向服务器发送的请求对象。————————HttpServletRequest<br>response：服务器向客户端作的响应对象。————————–HttpServletResponse<br>session：客户端和服务器之间的会话对象。————————-HttpSession<br>application：整个应用——————————————————-ServletContext<br>page：当前jsp页面被翻译成的Servlet对象————————-Object<br>out：页面输出内容的对象————————————————-JspWriter<br>pageContext：当前jsp页面的上下文对象—————————–PageContext<br>config：当前jsp的ServletConfig对象———————————-ServletConfig<br>exception：当前页面的异常对象，只有当前页面的page指令中指明了isErrorPage=”true”才有此对象。——– Throwable</p></blockquote><p><em>pageContext对象的概述</em><br>pageContext对象<br>    可以存值，取值，移除值，查找值</p><pre><code>pageContext的作用:1.作为域对象保存数据获取其他8大内置对象</code></pre><p><img src="/2018/01/28/jsp-el-jstl/jsp02.png" alt="获取其它的内置对象">);</p><blockquote><p>在JSP页面中可以直接使用out,request对象,为什么还需要用pageContext获取?<br>可以作为参数传递.</p></blockquote><h2 id="jsp四个作用范围"><a href="#jsp四个作用范围" class="headerlink" title="jsp四个作用范围"></a>jsp四个作用范围</h2><p>pageContext ：代表page域，就是指当前页面范围<br>requset：他是代表一个求链<br>session：整个回话，<br>aplication：整个web应用（servletContext）</p><p>PAGE_SCOPE：页面范围<br>    页面范围：指的是在当前的页面内有效，出了这个页面，用pageContext保存的数据就无效了。<br>REQUEST_SCOPE：请求范围<br>    从客户端向服务器发送一次请求，直到服务器作出了响应之后，数据就无效，相当于Request域，也可以使用Request取值。<br>SESSION_SCOPE：会话范围<br>    从打开浏览器到关闭浏览器数以一次会话，在这个会话内数据都有效，相当于Session域。<br>APPLICATION_SCOPE：应用范围<br>    在整个应用中任意的地方都可以获取，相当于ServletContext域</p><p><em>在page,request,session.application范围依次查找(findAttribute)</em></p><h2 id="总结一点："><a href="#总结一点：" class="headerlink" title="##总结一点："></a>##总结一点：</h2><p>JSP=html+java+jsp特有东西<br>    a)JSP注释  // /**/  &lt;%– JSP注释 –%&gt;<br>    b)JSP页面指令<br>        1.&lt;%@ page import=”” %&gt;<br>        2.&lt;%@ include file=”” %&gt; 静态包含  代码复制<br>        3.&lt;%@ taglib uri=”” prefix=”” &gt;<br>    c)JSP内置对象<br>        1.pageContext request,response，session,application,,out,config,page,exception<br>        2.pageContext 的作用<br>    i.可以操作各个域<br>    a)findAttribute(“name”);</p><pre><code>2.  可以获取其他8个内置对象</code></pre><h2 id="JSP动作标签"><a href="#JSP动作标签" class="headerlink" title="JSP动作标签"></a>JSP动作标签</h2><p>JSP的动作标签用于在JSP页面中提供业务逻辑功能，避免在JSP页面中直接编写Java代码，造成jsp页面难以维护。<br>常用动作标签：<br>    <jsp:forward>    ：请求转发。<br>    <jsp:include>：包含（动态包含）。<br>    <jsp:param>：传递参数<br><img src="/2018/01/28/jsp-el-jstl/jsp03.png" alt="静态包含和动态包含的区别">;</jsp:param></jsp:include></jsp:forward></p><p>jsp中静态包含(include指令)与动态包含(include标签)区别?<br>1.静态包含包含的是内容，而动态包含包含的是结果。<br>2.静态包含不可以传递参数 ,而动态包含可以传递参数</p><p>静态包含:(代码拷贝,合一个文件),动态:(独立Java文件)<br>开发如何选择:<br>没有特殊需求,2个都可以<br><strong>被包含文件独立性高,用jsp:include 标签</strong></p><h3 id="ELd的概述"><a href="#ELd的概述" class="headerlink" title="ELd的概述"></a>ELd的概述</h3><p>EL主要是用来取代我们jsp页面的java代码，jsp页面一般是起显示数据作用的，所以不应该出现java代码，有java代码也不利于维护和合作开发，故出现了EL表达式。</p><blockquote><p>EL作用: 获取域中数据、执行运算、获取web常用对象。</p><p>  语法：${ EL表达式}</p></blockquote><h3 id="EL获取数据（重点）"><a href="#EL获取数据（重点）" class="headerlink" title="EL获取数据（重点）"></a>EL获取数据（重点）</h3><p>EL表达式语句在执行的时候，会调用pageContext.findAttribute()方法。分别从<em>page、request、session、application</em>范围查找相应对象，找到就会<em>返回相应对象，找不到返回””(不是null，是空的字符串)</em>。EL所获取的数据需要在四个作用范围中</p><h3 id="EL获取数组和集合中的数据"><a href="#EL获取数组和集合中的数据" class="headerlink" title="EL获取数组和集合中的数据"></a>EL获取数组和集合中的数据</h3><ol><li>El获取数组中的数据</li></ol><p><img src="/2018/01/28/jsp-el-jstl/EL01.png" alt="">;</p><ol><li><p>EL获取list集合的数据<br><img src="/2018/01/28/jsp-el-jstl/EL02.png" alt="">;</p></li><li><p>EL获取map集合的数据</p></li></ol><p><img src="/2018/01/28/jsp-el-jstl/EL03.png" alt="">;</p><blockquote><p>1.map集合的键要是String类型<br>2.当key中有特殊字符点时，map集合获取值就不能使用.了,使用下标的方式[“key”]</p></blockquote><h3 id="EL执行的运算"><a href="#EL执行的运算" class="headerlink" title="EL执行的运算"></a>EL执行的运算</h3><ol><li>算术运算</li><li>关系运算</li><li>逻辑运算</li><li>三元运算</li><li>empty运算</li></ol><p>empty用于集合,可以判断集合是否有元素,size()=0</p><p>&lt;%<br>List list = new ArrayList<string>();<br>request.setAttribute(“list”,list);<br>%&gt;<br>${empty list}  –返回true ,没有元素</string></p><h3 id="EL获取web开发常用对象"><a href="#EL获取web开发常用对象" class="headerlink" title="EL获取web开发常用对象"></a>EL获取web开发常用对象</h3><p><strong>掌握param、paramValues、cookie、pageContext以及四个域对象的含义和用法</strong><br><img src="/2018/01/28/jsp-el-jstl/EL04.png" alt="">;</p><p><strong>最常用</strong></p><blockquote><p>${cookie.remember.value}<br>${param[“name”]}</p><form action="”${pageContext.request.contextPath}/Servlet”" method="”post”"></form></blockquote><h4 id="JSTL概述"><a href="#JSTL概述" class="headerlink" title="JSTL概述"></a>JSTL概述</h4><p>是JSP标准标签库(JSTL)是一个jsp标签集合，封装了jsp应用的通用核心功能<br><em>JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签</em></p><p>JSTL分为i下面5类</p><blockquote><p>核心标签—————————————–c标签<br>格式化标签（国际化标签）—————-fmt标签<br>SQL 标签—————————————–sql标签<br>XML 标签—————————————-xml标签<br>JSTL 函数—————————————（EL函数）</p></blockquote><h4 id="JSTL的if标签属性"><a href="#JSTL的if标签属性" class="headerlink" title="JSTL的if标签属性"></a>JSTL的if标签属性</h4><ol><li>test：条件</li><li>var：将test中的条件的值符给一个变量</li><li>scope： 作用范围</li></ol><p><img src="/2018/01/28/jsp-el-jstl/JSTL01.png" alt="">;</p><h4 id="JSTL的foreach标签（重点）"><a href="#JSTL的foreach标签（重点）" class="headerlink" title="JSTL的foreach标签（重点）"></a>JSTL的foreach标签（重点）</h4><ol><li>items：要被循环的信息</li><li>begin：开始的元素</li><li>end:最后一个元素</li><li>step：每一次增长的值</li><li>var：代表当前条目的变量名称</li><li>varStatus：代表循环抓太多变量名称<br><img src="/2018/01/28/jsp-el-jstl/JSTL02.png" alt="foreach基本使用">;<br><img src="/2018/01/28/jsp-el-jstl/JSTL03.png" alt="foreach遍历数组">;</li></ol><p><img src="/2018/01/28/jsp-el-jstl/JSTL04.png" alt="foreach遍历list集合">;</p><p><img src="/2018/01/28/jsp-el-jstl/JSTL05.png" alt="foreach遍历map集合">;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JSP&quot;&gt;&lt;a href=&quot;#JSP&quot; class=&quot;headerlink&quot; title=&quot;JSP&quot;&gt;&lt;/a&gt;JSP&lt;/h1&gt;&lt;h2 id=&quot;jsp的基本介绍&quot;&gt;&lt;a href=&quot;#jsp的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;jsp的基
      
    
    </summary>
    
      <category term="JSP" scheme="http://HackerFreedom.github.io/categories/JSP/"/>
    
    
      <category term="jsp&amp;el&amp;jstl基本知识" scheme="http://HackerFreedom.github.io/tags/jsp-el-jstl%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>大学时的生活</title>
    <link href="http://HackerFreedom.github.io/2018/01/28/Memoirs/"/>
    <id>http://HackerFreedom.github.io/2018/01/28/Memoirs/</id>
    <published>2018-01-28T00:50:56.000Z</published>
    <updated>2018-02-28T01:24:53.899Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/01/28/Memoirs/bg.png" alt=""><br><a id="more"></a><br>2015年我只为it梦来到了这个校园<br>2年时间我留下很多难难忘的回忆，和一个一生都忘不掉的人。<br>而这正是我，唯一依依不舍的理由。<br>感谢这个大学，即使现在还是一无所有，没有任何地点。<br>我还是那个热血的我，好奇的我，这一生我只想做一个有梦就追的男孩。<br>    当你想放弃的时候，你就想想当初为何要走，想走就继续，因为梦想还在，而你放弃，它就会一点点的侵犯你整个思想，直到你为之后悔莫及。<br>    当初爱上你，不是因为你的美丽，而是你在特殊的时间，给了我别人给不了的感觉，谢谢你陪我走过了这365天</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/01/28/Memoirs/bg.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://HackerFreedom.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="时尚" scheme="http://HackerFreedom.github.io/tags/%E6%97%B6%E5%B0%9A/"/>
    
  </entry>
  
</feed>
